/*
Copyright 2023 The Vitess Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
// Code generated by ASTHelperGen. DO NOT EDIT.

package sqlparser

// COWSQLNode creates a deep clone of the input.
func (c cow) COWSQLNode(in SQLNode) (SQLNode, bool) {
	if in == nil {
		return nil, false
	}
	if c.old == in {
		return c.new, true
	}
	switch in := in.(type) {
	case *AddColumns:
		return c.COWRefOfAddColumns(in)
	case *AddConstraintDefinition:
		return c.COWRefOfAddConstraintDefinition(in)
	case *AddIndexDefinition:
		return c.COWRefOfAddIndexDefinition(in)
	case AlgorithmValue:
		return in
	case *AliasedExpr:
		return c.COWRefOfAliasedExpr(in)
	case *AliasedTableExpr:
		return c.COWRefOfAliasedTableExpr(in)
	case *AlterCharset:
		return c.COWRefOfAlterCharset(in)
	case *AlterCheck:
		return c.COWRefOfAlterCheck(in)
	case *AlterColumn:
		return c.COWRefOfAlterColumn(in)
	case *AlterDatabase:
		return c.COWRefOfAlterDatabase(in)
	case *AlterIndex:
		return c.COWRefOfAlterIndex(in)
	case *AlterMigration:
		return c.COWRefOfAlterMigration(in)
	case *AlterTable:
		return c.COWRefOfAlterTable(in)
	case *AlterView:
		return c.COWRefOfAlterView(in)
	case *AlterVschema:
		return c.COWRefOfAlterVschema(in)
	case *AndExpr:
		return c.COWRefOfAndExpr(in)
	case Argument:
		return in
	case *ArgumentLessWindowExpr:
		return c.COWRefOfArgumentLessWindowExpr(in)
	case *AutoIncSpec:
		return c.COWRefOfAutoIncSpec(in)
	case *Avg:
		return c.COWRefOfAvg(in)
	case *Begin:
		return c.COWRefOfBegin(in)
	case *BetweenExpr:
		return c.COWRefOfBetweenExpr(in)
	case *BinaryExpr:
		return c.COWRefOfBinaryExpr(in)
	case *BitAnd:
		return c.COWRefOfBitAnd(in)
	case *BitOr:
		return c.COWRefOfBitOr(in)
	case *BitXor:
		return c.COWRefOfBitXor(in)
	case BoolVal:
		return in
	case *CallProc:
		return c.COWRefOfCallProc(in)
	case *CaseExpr:
		return c.COWRefOfCaseExpr(in)
	case *CastExpr:
		return c.COWRefOfCastExpr(in)
	case *ChangeColumn:
		return c.COWRefOfChangeColumn(in)
	case *CharExpr:
		return c.COWRefOfCharExpr(in)
	case *CheckConstraintDefinition:
		return c.COWRefOfCheckConstraintDefinition(in)
	case *ColName:
		return c.COWRefOfColName(in)
	case *CollateExpr:
		return c.COWRefOfCollateExpr(in)
	case *ColumnDefinition:
		return c.COWRefOfColumnDefinition(in)
	case *ColumnType:
		return c.COWRefOfColumnType(in)
	case Columns:
		return c.COWColumns(in)
	case *CommentOnly:
		return c.COWRefOfCommentOnly(in)
	case *Commit:
		return c.COWRefOfCommit(in)
	case *CommonTableExpr:
		return c.COWRefOfCommonTableExpr(in)
	case *ComparisonExpr:
		return c.COWRefOfComparisonExpr(in)
	case *ConstraintDefinition:
		return c.COWRefOfConstraintDefinition(in)
	case *ConvertExpr:
		return c.COWRefOfConvertExpr(in)
	case *ConvertType:
		return c.COWRefOfConvertType(in)
	case *ConvertUsingExpr:
		return c.COWRefOfConvertUsingExpr(in)
	case *Count:
		return c.COWRefOfCount(in)
	case *CountStar:
		return c.COWRefOfCountStar(in)
	case *CreateDatabase:
		return c.COWRefOfCreateDatabase(in)
	case *CreateTable:
		return c.COWRefOfCreateTable(in)
	case *CreateView:
		return c.COWRefOfCreateView(in)
	case *CurTimeFuncExpr:
		return c.COWRefOfCurTimeFuncExpr(in)
	case *DeallocateStmt:
		return c.COWRefOfDeallocateStmt(in)
	case *Default:
		return c.COWRefOfDefault(in)
	case *Definer:
		return c.COWRefOfDefiner(in)
	case *Delete:
		return c.COWRefOfDelete(in)
	case *DerivedTable:
		return c.COWRefOfDerivedTable(in)
	case *DropColumn:
		return c.COWRefOfDropColumn(in)
	case *DropDatabase:
		return c.COWRefOfDropDatabase(in)
	case *DropKey:
		return c.COWRefOfDropKey(in)
	case *DropTable:
		return c.COWRefOfDropTable(in)
	case *DropView:
		return c.COWRefOfDropView(in)
	case *ExecuteStmt:
		return c.COWRefOfExecuteStmt(in)
	case *ExistsExpr:
		return c.COWRefOfExistsExpr(in)
	case *ExplainStmt:
		return c.COWRefOfExplainStmt(in)
	case *ExplainTab:
		return c.COWRefOfExplainTab(in)
	case Exprs:
		return c.COWExprs(in)
	case *ExtractFuncExpr:
		return c.COWRefOfExtractFuncExpr(in)
	case *ExtractValueExpr:
		return c.COWRefOfExtractValueExpr(in)
	case *ExtractedSubquery:
		return c.COWRefOfExtractedSubquery(in)
	case *FirstOrLastValueExpr:
		return c.COWRefOfFirstOrLastValueExpr(in)
	case *Flush:
		return c.COWRefOfFlush(in)
	case *Force:
		return c.COWRefOfForce(in)
	case *ForeignKeyDefinition:
		return c.COWRefOfForeignKeyDefinition(in)
	case *FrameClause:
		return c.COWRefOfFrameClause(in)
	case *FramePoint:
		return c.COWRefOfFramePoint(in)
	case *FromFirstLastClause:
		return c.COWRefOfFromFirstLastClause(in)
	case *FuncExpr:
		return c.COWRefOfFuncExpr(in)
	case *GTIDFuncExpr:
		return c.COWRefOfGTIDFuncExpr(in)
	case GroupBy:
		return c.COWGroupBy(in)
	case *GroupConcatExpr:
		return c.COWRefOfGroupConcatExpr(in)
	case IdentifierCI:
		return c.COWIdentifierCI(in)
	case IdentifierCS:
		return c.COWIdentifierCS(in)
	case *IndexDefinition:
		return c.COWRefOfIndexDefinition(in)
	case *IndexHint:
		return c.COWRefOfIndexHint(in)
	case IndexHints:
		return c.COWIndexHints(in)
	case *IndexInfo:
		return c.COWRefOfIndexInfo(in)
	case *Insert:
		return c.COWRefOfInsert(in)
	case *InsertExpr:
		return c.COWRefOfInsertExpr(in)
	case *IntervalExpr:
		return c.COWRefOfIntervalExpr(in)
	case *IntervalFuncExpr:
		return c.COWRefOfIntervalFuncExpr(in)
	case *IntroducerExpr:
		return c.COWRefOfIntroducerExpr(in)
	case *IsExpr:
		return c.COWRefOfIsExpr(in)
	case *JSONArrayExpr:
		return c.COWRefOfJSONArrayExpr(in)
	case *JSONAttributesExpr:
		return c.COWRefOfJSONAttributesExpr(in)
	case *JSONContainsExpr:
		return c.COWRefOfJSONContainsExpr(in)
	case *JSONContainsPathExpr:
		return c.COWRefOfJSONContainsPathExpr(in)
	case *JSONExtractExpr:
		return c.COWRefOfJSONExtractExpr(in)
	case *JSONKeysExpr:
		return c.COWRefOfJSONKeysExpr(in)
	case *JSONObjectExpr:
		return c.COWRefOfJSONObjectExpr(in)
	case JSONObjectParam:
		return c.COWJSONObjectParam(in)
	case *JSONOverlapsExpr:
		return c.COWRefOfJSONOverlapsExpr(in)
	case *JSONPrettyExpr:
		return c.COWRefOfJSONPrettyExpr(in)
	case *JSONQuoteExpr:
		return c.COWRefOfJSONQuoteExpr(in)
	case *JSONRemoveExpr:
		return c.COWRefOfJSONRemoveExpr(in)
	case *JSONSchemaValidFuncExpr:
		return c.COWRefOfJSONSchemaValidFuncExpr(in)
	case *JSONSchemaValidationReportFuncExpr:
		return c.COWRefOfJSONSchemaValidationReportFuncExpr(in)
	case *JSONSearchExpr:
		return c.COWRefOfJSONSearchExpr(in)
	case *JSONStorageFreeExpr:
		return c.COWRefOfJSONStorageFreeExpr(in)
	case *JSONStorageSizeExpr:
		return c.COWRefOfJSONStorageSizeExpr(in)
	case *JSONTableExpr:
		return c.COWRefOfJSONTableExpr(in)
	case *JSONUnquoteExpr:
		return c.COWRefOfJSONUnquoteExpr(in)
	case *JSONValueExpr:
		return c.COWRefOfJSONValueExpr(in)
	case *JSONValueMergeExpr:
		return c.COWRefOfJSONValueMergeExpr(in)
	case *JSONValueModifierExpr:
		return c.COWRefOfJSONValueModifierExpr(in)
	case *JoinCondition:
		return c.COWRefOfJoinCondition(in)
	case *JoinTableExpr:
		return c.COWRefOfJoinTableExpr(in)
	case *JtColumnDefinition:
		return c.COWRefOfJtColumnDefinition(in)
	case *JtOnResponse:
		return c.COWRefOfJtOnResponse(in)
	case *KeyState:
		return c.COWRefOfKeyState(in)
	case *LagLeadExpr:
		return c.COWRefOfLagLeadExpr(in)
	case *Limit:
		return c.COWRefOfLimit(in)
	case ListArg:
		return in
	case *Literal:
		return c.COWRefOfLiteral(in)
	case *Load:
		return c.COWRefOfLoad(in)
	case *LocateExpr:
		return c.COWRefOfLocateExpr(in)
	case *LockOption:
		return c.COWRefOfLockOption(in)
	case *LockTables:
		return c.COWRefOfLockTables(in)
	case *LockingFunc:
		return c.COWRefOfLockingFunc(in)
	case MatchAction:
		return in
	case *MatchExpr:
		return c.COWRefOfMatchExpr(in)
	case *Max:
		return c.COWRefOfMax(in)
	case *MemberOfExpr:
		return c.COWRefOfMemberOfExpr(in)
	case *Min:
		return c.COWRefOfMin(in)
	case *ModifyColumn:
		return c.COWRefOfModifyColumn(in)
	case *NTHValueExpr:
		return c.COWRefOfNTHValueExpr(in)
	case *NamedWindow:
		return c.COWRefOfNamedWindow(in)
	case NamedWindows:
		return c.COWNamedWindows(in)
	case *Nextval:
		return c.COWRefOfNextval(in)
	case *NotExpr:
		return c.COWRefOfNotExpr(in)
	case *NtileExpr:
		return c.COWRefOfNtileExpr(in)
	case *NullTreatmentClause:
		return c.COWRefOfNullTreatmentClause(in)
	case *NullVal:
		return c.COWRefOfNullVal(in)
	case *Offset:
		return c.COWRefOfOffset(in)
	case OnDup:
		return c.COWOnDup(in)
	case *OptLike:
		return c.COWRefOfOptLike(in)
	case *OrExpr:
		return c.COWRefOfOrExpr(in)
	case *Order:
		return c.COWRefOfOrder(in)
	case OrderBy:
		return c.COWOrderBy(in)
	case *OrderByOption:
		return c.COWRefOfOrderByOption(in)
	case *OtherAdmin:
		return c.COWRefOfOtherAdmin(in)
	case *OtherRead:
		return c.COWRefOfOtherRead(in)
	case *OverClause:
		return c.COWRefOfOverClause(in)
	case *ParenTableExpr:
		return c.COWRefOfParenTableExpr(in)
	case *ParsedComments:
		return c.COWRefOfParsedComments(in)
	case *PartitionDefinition:
		return c.COWRefOfPartitionDefinition(in)
	case *PartitionDefinitionOptions:
		return c.COWRefOfPartitionDefinitionOptions(in)
	case *PartitionEngine:
		return c.COWRefOfPartitionEngine(in)
	case *PartitionOption:
		return c.COWRefOfPartitionOption(in)
	case *PartitionSpec:
		return c.COWRefOfPartitionSpec(in)
	case *PartitionValueRange:
		return c.COWRefOfPartitionValueRange(in)
	case Partitions:
		return c.COWPartitions(in)
	case *PerformanceSchemaFuncExpr:
		return c.COWRefOfPerformanceSchemaFuncExpr(in)
	case *PrepareStmt:
		return c.COWRefOfPrepareStmt(in)
	case ReferenceAction:
		return in
	case *ReferenceDefinition:
		return c.COWRefOfReferenceDefinition(in)
	case *RegexpInstrExpr:
		return c.COWRefOfRegexpInstrExpr(in)
	case *RegexpLikeExpr:
		return c.COWRefOfRegexpLikeExpr(in)
	case *RegexpReplaceExpr:
		return c.COWRefOfRegexpReplaceExpr(in)
	case *RegexpSubstrExpr:
		return c.COWRefOfRegexpSubstrExpr(in)
	case *Release:
		return c.COWRefOfRelease(in)
	case *RenameColumn:
		return c.COWRefOfRenameColumn(in)
	case *RenameIndex:
		return c.COWRefOfRenameIndex(in)
	case *RenameTable:
		return c.COWRefOfRenameTable(in)
	case *RenameTableName:
		return c.COWRefOfRenameTableName(in)
	case *RevertMigration:
		return c.COWRefOfRevertMigration(in)
	case *Rollback:
		return c.COWRefOfRollback(in)
	case RootNode:
		return c.COWRootNode(in)
	case *SRollback:
		return c.COWRefOfSRollback(in)
	case *Savepoint:
		return c.COWRefOfSavepoint(in)
	case *Select:
		return c.COWRefOfSelect(in)
	case SelectExprs:
		return c.COWSelectExprs(in)
	case *SelectInto:
		return c.COWRefOfSelectInto(in)
	case *Set:
		return c.COWRefOfSet(in)
	case *SetExpr:
		return c.COWRefOfSetExpr(in)
	case SetExprs:
		return c.COWSetExprs(in)
	case *Show:
		return c.COWRefOfShow(in)
	case *ShowBasic:
		return c.COWRefOfShowBasic(in)
	case *ShowCreate:
		return c.COWRefOfShowCreate(in)
	case *ShowFilter:
		return c.COWRefOfShowFilter(in)
	case *ShowMigrationLogs:
		return c.COWRefOfShowMigrationLogs(in)
	case *ShowOther:
		return c.COWRefOfShowOther(in)
	case *ShowThrottledApps:
		return c.COWRefOfShowThrottledApps(in)
	case *ShowThrottlerStatus:
		return c.COWRefOfShowThrottlerStatus(in)
	case *StarExpr:
		return c.COWRefOfStarExpr(in)
	case *Std:
		return c.COWRefOfStd(in)
	case *StdDev:
		return c.COWRefOfStdDev(in)
	case *StdPop:
		return c.COWRefOfStdPop(in)
	case *StdSamp:
		return c.COWRefOfStdSamp(in)
	case *Stream:
		return c.COWRefOfStream(in)
	case *SubPartition:
		return c.COWRefOfSubPartition(in)
	case *SubPartitionDefinition:
		return c.COWRefOfSubPartitionDefinition(in)
	case *SubPartitionDefinitionOptions:
		return c.COWRefOfSubPartitionDefinitionOptions(in)
	case SubPartitionDefinitions:
		return c.COWSubPartitionDefinitions(in)
	case *Subquery:
		return c.COWRefOfSubquery(in)
	case *SubstrExpr:
		return c.COWRefOfSubstrExpr(in)
	case *Sum:
		return c.COWRefOfSum(in)
	case TableExprs:
		return c.COWTableExprs(in)
	case TableName:
		return c.COWTableName(in)
	case TableNames:
		return c.COWTableNames(in)
	case TableOptions:
		return c.COWTableOptions(in)
	case *TableSpec:
		return c.COWRefOfTableSpec(in)
	case *TablespaceOperation:
		return c.COWRefOfTablespaceOperation(in)
	case *TimestampFuncExpr:
		return c.COWRefOfTimestampFuncExpr(in)
	case *TrimFuncExpr:
		return c.COWRefOfTrimFuncExpr(in)
	case *TruncateTable:
		return c.COWRefOfTruncateTable(in)
	case *UnaryExpr:
		return c.COWRefOfUnaryExpr(in)
	case *Union:
		return c.COWRefOfUnion(in)
	case *UnlockTables:
		return c.COWRefOfUnlockTables(in)
	case *Update:
		return c.COWRefOfUpdate(in)
	case *UpdateExpr:
		return c.COWRefOfUpdateExpr(in)
	case UpdateExprs:
		return c.COWUpdateExprs(in)
	case *UpdateXMLExpr:
		return c.COWRefOfUpdateXMLExpr(in)
	case *Use:
		return c.COWRefOfUse(in)
	case *VExplainStmt:
		return c.COWRefOfVExplainStmt(in)
	case *VStream:
		return c.COWRefOfVStream(in)
	case ValTuple:
		return c.COWValTuple(in)
	case *Validation:
		return c.COWRefOfValidation(in)
	case Values:
		return c.COWValues(in)
	case *ValuesFuncExpr:
		return c.COWRefOfValuesFuncExpr(in)
	case *VarPop:
		return c.COWRefOfVarPop(in)
	case *VarSamp:
		return c.COWRefOfVarSamp(in)
	case *Variable:
		return c.COWRefOfVariable(in)
	case *Variance:
		return c.COWRefOfVariance(in)
	case VindexParam:
		return c.COWVindexParam(in)
	case *VindexSpec:
		return c.COWRefOfVindexSpec(in)
	case *WeightStringFuncExpr:
		return c.COWRefOfWeightStringFuncExpr(in)
	case *When:
		return c.COWRefOfWhen(in)
	case *Where:
		return c.COWRefOfWhere(in)
	case *WindowDefinition:
		return c.COWRefOfWindowDefinition(in)
	case WindowDefinitions:
		return c.COWWindowDefinitions(in)
	case *WindowSpecification:
		return c.COWRefOfWindowSpecification(in)
	case *With:
		return c.COWRefOfWith(in)
	case *XorExpr:
		return c.COWRefOfXorExpr(in)
	default:
		// this should never happen
		return nil
	}
}

// COWRefOfAddColumns creates a deep clone of the input.
func (c cow) COWRefOfAddColumns(n *AddColumns) (*AddColumns, bool) {
	if n == nil {
		return nil, false
	}
	Columns, changedColumns := c.COWSliceOfRefOfColumnDefinition(n.Columns)
	After, changedAfter := c.COWRefOfColName(n.After)
	if changedColumns || changedAfter {
		out := *n
		out.Columns = Columns
		out.After = After
		return &out, true
	}
	return n, false
}

// COWRefOfAddConstraintDefinition creates a deep clone of the input.
func (c cow) COWRefOfAddConstraintDefinition(n *AddConstraintDefinition) (*AddConstraintDefinition, bool) {
	if n == nil {
		return nil, false
	}
	ConstraintDefinition, changedConstraintDefinition := c.COWRefOfConstraintDefinition(n.ConstraintDefinition)
	if changedConstraintDefinition {
		out := *n
		out.ConstraintDefinition = ConstraintDefinition
		return &out, true
	}
	return n, false
}

// COWRefOfAddIndexDefinition creates a deep clone of the input.
func (c cow) COWRefOfAddIndexDefinition(n *AddIndexDefinition) (*AddIndexDefinition, bool) {
	if n == nil {
		return nil, false
	}
	IndexDefinition, changedIndexDefinition := c.COWRefOfIndexDefinition(n.IndexDefinition)
	if changedIndexDefinition {
		out := *n
		out.IndexDefinition = IndexDefinition
		return &out, true
	}
	return n, false
}

// COWRefOfAliasedExpr creates a deep clone of the input.
func (c cow) COWRefOfAliasedExpr(n *AliasedExpr) (*AliasedExpr, bool) {
	if n == nil {
		return nil, false
	}
	Expr, changedExpr := c.COWExpr(n.Expr)
	As, changedAs := c.COWIdentifierCI(n.As)
	if changedExpr || changedAs {
		out := *n
		out.Expr = Expr
		out.As = As
		return &out, true
	}
	return n, false
}

// COWRefOfAliasedTableExpr creates a deep clone of the input.
func (c cow) COWRefOfAliasedTableExpr(n *AliasedTableExpr) (*AliasedTableExpr, bool) {
	if n == nil {
		return nil, false
	}
	Expr, changedExpr := c.COWSimpleTableExpr(n.Expr)
	Partitions, changedPartitions := c.COWPartitions(n.Partitions)
	As, changedAs := c.COWIdentifierCS(n.As)
	Hints, changedHints := c.COWIndexHints(n.Hints)
	Columns, changedColumns := c.COWColumns(n.Columns)
	if changedExpr || changedPartitions || changedAs || changedHints || changedColumns {
		out := *n
		out.Expr = Expr
		out.Partitions = Partitions
		out.As = As
		out.Hints = Hints
		out.Columns = Columns
		return &out, true
	}
	return n, false
}

// COWRefOfAlterCharset creates a deep clone of the input.
func (c cow) COWRefOfAlterCharset(n *AlterCharset) (*AlterCharset, bool) {
	if n == nil {
		return nil, false
	}
	return n, false
}

// COWRefOfAlterCheck creates a deep clone of the input.
func (c cow) COWRefOfAlterCheck(n *AlterCheck) (*AlterCheck, bool) {
	if n == nil {
		return nil, false
	}
	Name, changedName := c.COWIdentifierCI(n.Name)
	if changedName {
		out := *n
		out.Name = Name
		return &out, true
	}
	return n, false
}

// COWRefOfAlterColumn creates a deep clone of the input.
func (c cow) COWRefOfAlterColumn(n *AlterColumn) (*AlterColumn, bool) {
	if n == nil {
		return nil, false
	}
	Column, changedColumn := c.COWRefOfColName(n.Column)
	DefaultVal, changedDefaultVal := c.COWExpr(n.DefaultVal)
	Invisible, changedInvisible := c.COWRefOfBool(n.Invisible)
	if changedColumn || changedDefaultVal || changedInvisible {
		out := *n
		out.Column = Column
		out.DefaultVal = DefaultVal
		out.Invisible = Invisible
		return &out, true
	}
	return n, false
}

// COWRefOfAlterDatabase creates a deep clone of the input.
func (c cow) COWRefOfAlterDatabase(n *AlterDatabase) (*AlterDatabase, bool) {
	if n == nil {
		return nil, false
	}
	DBName, changedDBName := c.COWIdentifierCS(n.DBName)
	AlterOptions, changedAlterOptions := c.COWSliceOfDatabaseOption(n.AlterOptions)
	if changedDBName || changedAlterOptions {
		out := *n
		out.DBName = DBName
		out.AlterOptions = AlterOptions
		return &out, true
	}
	return n, false
}

// COWRefOfAlterIndex creates a deep clone of the input.
func (c cow) COWRefOfAlterIndex(n *AlterIndex) (*AlterIndex, bool) {
	if n == nil {
		return nil, false
	}
	Name, changedName := c.COWIdentifierCI(n.Name)
	if changedName {
		out := *n
		out.Name = Name
		return &out, true
	}
	return n, false
}

// COWRefOfAlterMigration creates a deep clone of the input.
func (c cow) COWRefOfAlterMigration(n *AlterMigration) (*AlterMigration, bool) {
	if n == nil {
		return nil, false
	}
	Ratio, changedRatio := c.COWRefOfLiteral(n.Ratio)
	if changedRatio {
		out := *n
		out.Ratio = Ratio
		return &out, true
	}
	return n, false
}

// COWRefOfAlterTable creates a deep clone of the input.
func (c cow) COWRefOfAlterTable(n *AlterTable) (*AlterTable, bool) {
	if n == nil {
		return nil, false
	}
	Table, changedTable := c.COWTableName(n.Table)
	AlterOptions, changedAlterOptions := c.COWSliceOfAlterOption(n.AlterOptions)
	PartitionSpec, changedPartitionSpec := c.COWRefOfPartitionSpec(n.PartitionSpec)
	PartitionOption, changedPartitionOption := c.COWRefOfPartitionOption(n.PartitionOption)
	Comments, changedComments := c.COWRefOfParsedComments(n.Comments)
	if changedTable || changedAlterOptions || changedPartitionSpec || changedPartitionOption || changedComments {
		out := *n
		out.Table = Table
		out.AlterOptions = AlterOptions
		out.PartitionSpec = PartitionSpec
		out.PartitionOption = PartitionOption
		out.Comments = Comments
		return &out, true
	}
	return n, false
}

// COWRefOfAlterView creates a deep clone of the input.
func (c cow) COWRefOfAlterView(n *AlterView) (*AlterView, bool) {
	if n == nil {
		return nil, false
	}
	ViewName, changedViewName := c.COWTableName(n.ViewName)
	Definer, changedDefiner := c.COWRefOfDefiner(n.Definer)
	Columns, changedColumns := c.COWColumns(n.Columns)
	Select, changedSelect := c.COWSelectStatement(n.Select)
	Comments, changedComments := c.COWRefOfParsedComments(n.Comments)
	if changedViewName || changedDefiner || changedColumns || changedSelect || changedComments {
		out := *n
		out.ViewName = ViewName
		out.Definer = Definer
		out.Columns = Columns
		out.Select = Select
		out.Comments = Comments
		return &out, true
	}
	return n, false
}

// COWRefOfAlterVschema creates a deep clone of the input.
func (c cow) COWRefOfAlterVschema(n *AlterVschema) (*AlterVschema, bool) {
	if n == nil {
		return nil, false
	}
	Table, changedTable := c.COWTableName(n.Table)
	VindexSpec, changedVindexSpec := c.COWRefOfVindexSpec(n.VindexSpec)
	VindexCols, changedVindexCols := c.COWSliceOfIdentifierCI(n.VindexCols)
	AutoIncSpec, changedAutoIncSpec := c.COWRefOfAutoIncSpec(n.AutoIncSpec)
	if changedTable || changedVindexSpec || changedVindexCols || changedAutoIncSpec {
		out := *n
		out.Table = Table
		out.VindexSpec = VindexSpec
		out.VindexCols = VindexCols
		out.AutoIncSpec = AutoIncSpec
		return &out, true
	}
	return n, false
}

// COWRefOfAndExpr creates a deep clone of the input.
func (c cow) COWRefOfAndExpr(n *AndExpr) (*AndExpr, bool) {
	if n == nil {
		return nil, false
	}
	Left, changedLeft := c.COWExpr(n.Left)
	Right, changedRight := c.COWExpr(n.Right)
	if changedLeft || changedRight {
		out := *n
		out.Left = Left
		out.Right = Right
		return &out, true
	}
	return n, false
}

// COWRefOfArgumentLessWindowExpr creates a deep clone of the input.
func (c cow) COWRefOfArgumentLessWindowExpr(n *ArgumentLessWindowExpr) (*ArgumentLessWindowExpr, bool) {
	if n == nil {
		return nil, false
	}
	OverClause, changedOverClause := c.COWRefOfOverClause(n.OverClause)
	if changedOverClause {
		out := *n
		out.OverClause = OverClause
		return &out, true
	}
	return n, false
}

// COWRefOfAutoIncSpec creates a deep clone of the input.
func (c cow) COWRefOfAutoIncSpec(n *AutoIncSpec) (*AutoIncSpec, bool) {
	if n == nil {
		return nil, false
	}
	Column, changedColumn := c.COWIdentifierCI(n.Column)
	Sequence, changedSequence := c.COWTableName(n.Sequence)
	if changedColumn || changedSequence {
		out := *n
		out.Column = Column
		out.Sequence = Sequence
		return &out, true
	}
	return n, false
}

// COWRefOfAvg creates a deep clone of the input.
func (c cow) COWRefOfAvg(n *Avg) (*Avg, bool) {
	if n == nil {
		return nil, false
	}
	Arg, changedArg := c.COWExpr(n.Arg)
	if changedArg {
		out := *n
		out.Arg = Arg
		return &out, true
	}
	return n, false
}

// COWRefOfBegin creates a deep clone of the input.
func (c cow) COWRefOfBegin(n *Begin) (*Begin, bool) {
	if n == nil {
		return nil, false
	}
	TxAccessModes, changedTxAccessModes := c.COWSliceOfTxAccessMode(n.TxAccessModes)
	if changedTxAccessModes {
		out := *n
		out.TxAccessModes = TxAccessModes
		return &out, true
	}
	return n, false
}

// COWRefOfBetweenExpr creates a deep clone of the input.
func (c cow) COWRefOfBetweenExpr(n *BetweenExpr) (*BetweenExpr, bool) {
	if n == nil {
		return nil, false
	}
	Left, changedLeft := c.COWExpr(n.Left)
	From, changedFrom := c.COWExpr(n.From)
	To, changedTo := c.COWExpr(n.To)
	if changedLeft || changedFrom || changedTo {
		out := *n
		out.Left = Left
		out.From = From
		out.To = To
		return &out, true
	}
	return n, false
}

// COWRefOfBinaryExpr creates a deep clone of the input.
func (c cow) COWRefOfBinaryExpr(n *BinaryExpr) (*BinaryExpr, bool) {
	if n == nil {
		return nil, false
	}
	Left, changedLeft := c.COWExpr(n.Left)
	Right, changedRight := c.COWExpr(n.Right)
	if changedLeft || changedRight {
		out := *n
		out.Left = Left
		out.Right = Right
		return &out, true
	}
	return n, false
}

// COWRefOfBitAnd creates a deep clone of the input.
func (c cow) COWRefOfBitAnd(n *BitAnd) (*BitAnd, bool) {
	if n == nil {
		return nil, false
	}
	Arg, changedArg := c.COWExpr(n.Arg)
	if changedArg {
		out := *n
		out.Arg = Arg
		return &out, true
	}
	return n, false
}

// COWRefOfBitOr creates a deep clone of the input.
func (c cow) COWRefOfBitOr(n *BitOr) (*BitOr, bool) {
	if n == nil {
		return nil, false
	}
	Arg, changedArg := c.COWExpr(n.Arg)
	if changedArg {
		out := *n
		out.Arg = Arg
		return &out, true
	}
	return n, false
}

// COWRefOfBitXor creates a deep clone of the input.
func (c cow) COWRefOfBitXor(n *BitXor) (*BitXor, bool) {
	if n == nil {
		return nil, false
	}
	Arg, changedArg := c.COWExpr(n.Arg)
	if changedArg {
		out := *n
		out.Arg = Arg
		return &out, true
	}
	return n, false
}

// COWRefOfCallProc creates a deep clone of the input.
func (c cow) COWRefOfCallProc(n *CallProc) (*CallProc, bool) {
	if n == nil {
		return nil, false
	}
	Name, changedName := c.COWTableName(n.Name)
	Params, changedParams := c.COWExprs(n.Params)
	if changedName || changedParams {
		out := *n
		out.Name = Name
		out.Params = Params
		return &out, true
	}
	return n, false
}

// COWRefOfCaseExpr creates a deep clone of the input.
func (c cow) COWRefOfCaseExpr(n *CaseExpr) (*CaseExpr, bool) {
	if n == nil {
		return nil, false
	}
	Expr, changedExpr := c.COWExpr(n.Expr)
	Whens, changedWhens := c.COWSliceOfRefOfWhen(n.Whens)
	Else, changedElse := c.COWExpr(n.Else)
	if changedExpr || changedWhens || changedElse {
		out := *n
		out.Expr = Expr
		out.Whens = Whens
		out.Else = Else
		return &out, true
	}
	return n, false
}

// COWRefOfCastExpr creates a deep clone of the input.
func (c cow) COWRefOfCastExpr(n *CastExpr) (*CastExpr, bool) {
	if n == nil {
		return nil, false
	}
	Expr, changedExpr := c.COWExpr(n.Expr)
	Type, changedType := c.COWRefOfConvertType(n.Type)
	if changedExpr || changedType {
		out := *n
		out.Expr = Expr
		out.Type = Type
		return &out, true
	}
	return n, false
}

// COWRefOfChangeColumn creates a deep clone of the input.
func (c cow) COWRefOfChangeColumn(n *ChangeColumn) (*ChangeColumn, bool) {
	if n == nil {
		return nil, false
	}
	OldColumn, changedOldColumn := c.COWRefOfColName(n.OldColumn)
	NewColDefinition, changedNewColDefinition := c.COWRefOfColumnDefinition(n.NewColDefinition)
	After, changedAfter := c.COWRefOfColName(n.After)
	if changedOldColumn || changedNewColDefinition || changedAfter {
		out := *n
		out.OldColumn = OldColumn
		out.NewColDefinition = NewColDefinition
		out.After = After
		return &out, true
	}
	return n, false
}

// COWRefOfCharExpr creates a deep clone of the input.
func (c cow) COWRefOfCharExpr(n *CharExpr) (*CharExpr, bool) {
	if n == nil {
		return nil, false
	}
	Exprs, changedExprs := c.COWExprs(n.Exprs)
	if changedExprs {
		out := *n
		out.Exprs = Exprs
		return &out, true
	}
	return n, false
}

// COWRefOfCheckConstraintDefinition creates a deep clone of the input.
func (c cow) COWRefOfCheckConstraintDefinition(n *CheckConstraintDefinition) (*CheckConstraintDefinition, bool) {
	if n == nil {
		return nil, false
	}
	Expr, changedExpr := c.COWExpr(n.Expr)
	if changedExpr {
		out := *n
		out.Expr = Expr
		return &out, true
	}
	return n, false
}

// COWRefOfColName creates a deep clone of the input.
func (c cow) COWRefOfColName(n *ColName) (*ColName, bool) {
	if n == nil {
		return nil, false
	}
	Metadata, changedMetadata := n.Metadata
	Name, changedName := c.COWIdentifierCI(n.Name)
	Qualifier, changedQualifier := c.COWTableName(n.Qualifier)
	if changedMetadata || changedName || changedQualifier {
		out := *n
		out.Metadata = Metadata
		out.Name = Name
		out.Qualifier = Qualifier
		return &out, true
	}
	return n, false
}

// COWRefOfCollateExpr creates a deep clone of the input.
func (c cow) COWRefOfCollateExpr(n *CollateExpr) (*CollateExpr, bool) {
	if n == nil {
		return nil, false
	}
	Expr, changedExpr := c.COWExpr(n.Expr)
	if changedExpr {
		out := *n
		out.Expr = Expr
		return &out, true
	}
	return n, false
}

// COWRefOfColumnDefinition creates a deep clone of the input.
func (c cow) COWRefOfColumnDefinition(n *ColumnDefinition) (*ColumnDefinition, bool) {
	if n == nil {
		return nil, false
	}
	Name, changedName := c.COWIdentifierCI(n.Name)
	Type, changedType := c.COWColumnType(n.Type)
	if changedName || changedType {
		out := *n
		out.Name = Name
		out.Type = Type
		return &out, true
	}
	return n, false
}

// COWRefOfColumnType creates a deep clone of the input.
func (c cow) COWRefOfColumnType(n *ColumnType) (*ColumnType, bool) {
	if n == nil {
		return nil, false
	}
	Options, changedOptions := c.COWRefOfColumnTypeOptions(n.Options)
	Length, changedLength := c.COWRefOfLiteral(n.Length)
	Scale, changedScale := c.COWRefOfLiteral(n.Scale)
	Charset, changedCharset := c.COWColumnCharset(n.Charset)
	EnumValues, changedEnumValues := c.COWSliceOfString(n.EnumValues)
	if changedOptions || changedLength || changedScale || changedCharset || changedEnumValues {
		out := *n
		out.Options = Options
		out.Length = Length
		out.Scale = Scale
		out.Charset = Charset
		out.EnumValues = EnumValues
		return &out, true
	}
	return n, false
}

// COWColumns creates a deep clone of the input.
func COWColumns(n Columns) Columns {
	if n == nil {
		return nil
	}
	res := make(Columns, len(n))
	for i, x := range n {
		res[i] = c.COWIdentifierCI(x)
	}
	return res
}

// COWRefOfCommentOnly creates a deep clone of the input.
func (c cow) COWRefOfCommentOnly(n *CommentOnly) (*CommentOnly, bool) {
	if n == nil {
		return nil, false
	}
	Comments, changedComments := c.COWSliceOfString(n.Comments)
	if changedComments {
		out := *n
		out.Comments = Comments
		return &out, true
	}
	return n, false
}

// COWRefOfCommit creates a deep clone of the input.
func (c cow) COWRefOfCommit(n *Commit) (*Commit, bool) {
	if n == nil {
		return nil, false
	}
	return n, false
}

// COWRefOfCommonTableExpr creates a deep clone of the input.
func (c cow) COWRefOfCommonTableExpr(n *CommonTableExpr) (*CommonTableExpr, bool) {
	if n == nil {
		return nil, false
	}
	ID, changedID := c.COWIdentifierCS(n.ID)
	Columns, changedColumns := c.COWColumns(n.Columns)
	Subquery, changedSubquery := c.COWRefOfSubquery(n.Subquery)
	if changedID || changedColumns || changedSubquery {
		out := *n
		out.ID = ID
		out.Columns = Columns
		out.Subquery = Subquery
		return &out, true
	}
	return n, false
}

// COWRefOfComparisonExpr creates a deep clone of the input.
func (c cow) COWRefOfComparisonExpr(n *ComparisonExpr) (*ComparisonExpr, bool) {
	if n == nil {
		return nil, false
	}
	Left, changedLeft := c.COWExpr(n.Left)
	Right, changedRight := c.COWExpr(n.Right)
	Escape, changedEscape := c.COWExpr(n.Escape)
	if changedLeft || changedRight || changedEscape {
		out := *n
		out.Left = Left
		out.Right = Right
		out.Escape = Escape
		return &out, true
	}
	return n, false
}

// COWRefOfConstraintDefinition creates a deep clone of the input.
func (c cow) COWRefOfConstraintDefinition(n *ConstraintDefinition) (*ConstraintDefinition, bool) {
	if n == nil {
		return nil, false
	}
	Name, changedName := c.COWIdentifierCI(n.Name)
	Details, changedDetails := c.COWConstraintInfo(n.Details)
	if changedName || changedDetails {
		out := *n
		out.Name = Name
		out.Details = Details
		return &out, true
	}
	return n, false
}

// COWRefOfConvertExpr creates a deep clone of the input.
func (c cow) COWRefOfConvertExpr(n *ConvertExpr) (*ConvertExpr, bool) {
	if n == nil {
		return nil, false
	}
	Expr, changedExpr := c.COWExpr(n.Expr)
	Type, changedType := c.COWRefOfConvertType(n.Type)
	if changedExpr || changedType {
		out := *n
		out.Expr = Expr
		out.Type = Type
		return &out, true
	}
	return n, false
}

// COWRefOfConvertType creates a deep clone of the input.
func (c cow) COWRefOfConvertType(n *ConvertType) (*ConvertType, bool) {
	if n == nil {
		return nil, false
	}
	Length, changedLength := c.COWRefOfLiteral(n.Length)
	Scale, changedScale := c.COWRefOfLiteral(n.Scale)
	Charset, changedCharset := c.COWColumnCharset(n.Charset)
	if changedLength || changedScale || changedCharset {
		out := *n
		out.Length = Length
		out.Scale = Scale
		out.Charset = Charset
		return &out, true
	}
	return n, false
}

// COWRefOfConvertUsingExpr creates a deep clone of the input.
func (c cow) COWRefOfConvertUsingExpr(n *ConvertUsingExpr) (*ConvertUsingExpr, bool) {
	if n == nil {
		return nil, false
	}
	Expr, changedExpr := c.COWExpr(n.Expr)
	if changedExpr {
		out := *n
		out.Expr = Expr
		return &out, true
	}
	return n, false
}

// COWRefOfCount creates a deep clone of the input.
func (c cow) COWRefOfCount(n *Count) (*Count, bool) {
	if n == nil {
		return nil, false
	}
	Args, changedArgs := c.COWExprs(n.Args)
	if changedArgs {
		out := *n
		out.Args = Args
		return &out, true
	}
	return n, false
}

// COWRefOfCountStar creates a deep clone of the input.
func (c cow) COWRefOfCountStar(n *CountStar) (*CountStar, bool) {
	if n == nil {
		return nil, false
	}
	return n, false
}

// COWRefOfCreateDatabase creates a deep clone of the input.
func (c cow) COWRefOfCreateDatabase(n *CreateDatabase) (*CreateDatabase, bool) {
	if n == nil {
		return nil, false
	}
	Comments, changedComments := c.COWRefOfParsedComments(n.Comments)
	DBName, changedDBName := c.COWIdentifierCS(n.DBName)
	CreateOptions, changedCreateOptions := c.COWSliceOfDatabaseOption(n.CreateOptions)
	if changedComments || changedDBName || changedCreateOptions {
		out := *n
		out.Comments = Comments
		out.DBName = DBName
		out.CreateOptions = CreateOptions
		return &out, true
	}
	return n, false
}

// COWRefOfCreateTable creates a deep clone of the input.
func (c cow) COWRefOfCreateTable(n *CreateTable) (*CreateTable, bool) {
	if n == nil {
		return nil, false
	}
	Table, changedTable := c.COWTableName(n.Table)
	TableSpec, changedTableSpec := c.COWRefOfTableSpec(n.TableSpec)
	OptLike, changedOptLike := c.COWRefOfOptLike(n.OptLike)
	Comments, changedComments := c.COWRefOfParsedComments(n.Comments)
	if changedTable || changedTableSpec || changedOptLike || changedComments {
		out := *n
		out.Table = Table
		out.TableSpec = TableSpec
		out.OptLike = OptLike
		out.Comments = Comments
		return &out, true
	}
	return n, false
}

// COWRefOfCreateView creates a deep clone of the input.
func (c cow) COWRefOfCreateView(n *CreateView) (*CreateView, bool) {
	if n == nil {
		return nil, false
	}
	ViewName, changedViewName := c.COWTableName(n.ViewName)
	Definer, changedDefiner := c.COWRefOfDefiner(n.Definer)
	Columns, changedColumns := c.COWColumns(n.Columns)
	Select, changedSelect := c.COWSelectStatement(n.Select)
	Comments, changedComments := c.COWRefOfParsedComments(n.Comments)
	if changedViewName || changedDefiner || changedColumns || changedSelect || changedComments {
		out := *n
		out.ViewName = ViewName
		out.Definer = Definer
		out.Columns = Columns
		out.Select = Select
		out.Comments = Comments
		return &out, true
	}
	return n, false
}

// COWRefOfCurTimeFuncExpr creates a deep clone of the input.
func (c cow) COWRefOfCurTimeFuncExpr(n *CurTimeFuncExpr) (*CurTimeFuncExpr, bool) {
	if n == nil {
		return nil, false
	}
	Name, changedName := c.COWIdentifierCI(n.Name)
	Fsp, changedFsp := c.COWExpr(n.Fsp)
	if changedName || changedFsp {
		out := *n
		out.Name = Name
		out.Fsp = Fsp
		return &out, true
	}
	return n, false
}

// COWRefOfDeallocateStmt creates a deep clone of the input.
func (c cow) COWRefOfDeallocateStmt(n *DeallocateStmt) (*DeallocateStmt, bool) {
	if n == nil {
		return nil, false
	}
	Comments, changedComments := c.COWRefOfParsedComments(n.Comments)
	Name, changedName := c.COWIdentifierCI(n.Name)
	if changedComments || changedName {
		out := *n
		out.Comments = Comments
		out.Name = Name
		return &out, true
	}
	return n, false
}

// COWRefOfDefault creates a deep clone of the input.
func (c cow) COWRefOfDefault(n *Default) (*Default, bool) {
	if n == nil {
		return nil, false
	}
	return n, false
}

// COWRefOfDefiner creates a deep clone of the input.
func (c cow) COWRefOfDefiner(n *Definer) (*Definer, bool) {
	if n == nil {
		return nil, false
	}
	return n, false
}

// COWRefOfDelete creates a deep clone of the input.
func (c cow) COWRefOfDelete(n *Delete) (*Delete, bool) {
	if n == nil {
		return nil, false
	}
	With, changedWith := c.COWRefOfWith(n.With)
	Comments, changedComments := c.COWRefOfParsedComments(n.Comments)
	Targets, changedTargets := c.COWTableNames(n.Targets)
	TableExprs, changedTableExprs := c.COWTableExprs(n.TableExprs)
	Partitions, changedPartitions := c.COWPartitions(n.Partitions)
	Where, changedWhere := c.COWRefOfWhere(n.Where)
	OrderBy, changedOrderBy := c.COWOrderBy(n.OrderBy)
	Limit, changedLimit := c.COWRefOfLimit(n.Limit)
	if changedWith || changedComments || changedTargets || changedTableExprs || changedPartitions || changedWhere || changedOrderBy || changedLimit {
		out := *n
		out.With = With
		out.Comments = Comments
		out.Targets = Targets
		out.TableExprs = TableExprs
		out.Partitions = Partitions
		out.Where = Where
		out.OrderBy = OrderBy
		out.Limit = Limit
		return &out, true
	}
	return n, false
}

// COWRefOfDerivedTable creates a deep clone of the input.
func (c cow) COWRefOfDerivedTable(n *DerivedTable) (*DerivedTable, bool) {
	if n == nil {
		return nil, false
	}
	Select, changedSelect := c.COWSelectStatement(n.Select)
	if changedSelect {
		out := *n
		out.Select = Select
		return &out, true
	}
	return n, false
}

// COWRefOfDropColumn creates a deep clone of the input.
func (c cow) COWRefOfDropColumn(n *DropColumn) (*DropColumn, bool) {
	if n == nil {
		return nil, false
	}
	Name, changedName := c.COWRefOfColName(n.Name)
	if changedName {
		out := *n
		out.Name = Name
		return &out, true
	}
	return n, false
}

// COWRefOfDropDatabase creates a deep clone of the input.
func (c cow) COWRefOfDropDatabase(n *DropDatabase) (*DropDatabase, bool) {
	if n == nil {
		return nil, false
	}
	Comments, changedComments := c.COWRefOfParsedComments(n.Comments)
	DBName, changedDBName := c.COWIdentifierCS(n.DBName)
	if changedComments || changedDBName {
		out := *n
		out.Comments = Comments
		out.DBName = DBName
		return &out, true
	}
	return n, false
}

// COWRefOfDropKey creates a deep clone of the input.
func (c cow) COWRefOfDropKey(n *DropKey) (*DropKey, bool) {
	if n == nil {
		return nil, false
	}
	Name, changedName := c.COWIdentifierCI(n.Name)
	if changedName {
		out := *n
		out.Name = Name
		return &out, true
	}
	return n, false
}

// COWRefOfDropTable creates a deep clone of the input.
func (c cow) COWRefOfDropTable(n *DropTable) (*DropTable, bool) {
	if n == nil {
		return nil, false
	}
	FromTables, changedFromTables := c.COWTableNames(n.FromTables)
	Comments, changedComments := c.COWRefOfParsedComments(n.Comments)
	if changedFromTables || changedComments {
		out := *n
		out.FromTables = FromTables
		out.Comments = Comments
		return &out, true
	}
	return n, false
}

// COWRefOfDropView creates a deep clone of the input.
func (c cow) COWRefOfDropView(n *DropView) (*DropView, bool) {
	if n == nil {
		return nil, false
	}
	FromTables, changedFromTables := c.COWTableNames(n.FromTables)
	Comments, changedComments := c.COWRefOfParsedComments(n.Comments)
	if changedFromTables || changedComments {
		out := *n
		out.FromTables = FromTables
		out.Comments = Comments
		return &out, true
	}
	return n, false
}

// COWRefOfExecuteStmt creates a deep clone of the input.
func (c cow) COWRefOfExecuteStmt(n *ExecuteStmt) (*ExecuteStmt, bool) {
	if n == nil {
		return nil, false
	}
	Name, changedName := c.COWIdentifierCI(n.Name)
	Comments, changedComments := c.COWRefOfParsedComments(n.Comments)
	Arguments, changedArguments := c.COWSliceOfRefOfVariable(n.Arguments)
	if changedName || changedComments || changedArguments {
		out := *n
		out.Name = Name
		out.Comments = Comments
		out.Arguments = Arguments
		return &out, true
	}
	return n, false
}

// COWRefOfExistsExpr creates a deep clone of the input.
func (c cow) COWRefOfExistsExpr(n *ExistsExpr) (*ExistsExpr, bool) {
	if n == nil {
		return nil, false
	}
	Subquery, changedSubquery := c.COWRefOfSubquery(n.Subquery)
	if changedSubquery {
		out := *n
		out.Subquery = Subquery
		return &out, true
	}
	return n, false
}

// COWRefOfExplainStmt creates a deep clone of the input.
func (c cow) COWRefOfExplainStmt(n *ExplainStmt) (*ExplainStmt, bool) {
	if n == nil {
		return nil, false
	}
	Statement, changedStatement := c.COWStatement(n.Statement)
	Comments, changedComments := c.COWRefOfParsedComments(n.Comments)
	if changedStatement || changedComments {
		out := *n
		out.Statement = Statement
		out.Comments = Comments
		return &out, true
	}
	return n, false
}

// COWRefOfExplainTab creates a deep clone of the input.
func (c cow) COWRefOfExplainTab(n *ExplainTab) (*ExplainTab, bool) {
	if n == nil {
		return nil, false
	}
	Table, changedTable := c.COWTableName(n.Table)
	if changedTable {
		out := *n
		out.Table = Table
		return &out, true
	}
	return n, false
}

// COWExprs creates a deep clone of the input.
func COWExprs(n Exprs) Exprs {
	if n == nil {
		return nil
	}
	res := make(Exprs, len(n))
	for i, x := range n {
		res[i] = c.COWExpr(x)
	}
	return res
}

// COWRefOfExtractFuncExpr creates a deep clone of the input.
func (c cow) COWRefOfExtractFuncExpr(n *ExtractFuncExpr) (*ExtractFuncExpr, bool) {
	if n == nil {
		return nil, false
	}
	Expr, changedExpr := c.COWExpr(n.Expr)
	if changedExpr {
		out := *n
		out.Expr = Expr
		return &out, true
	}
	return n, false
}

// COWRefOfExtractValueExpr creates a deep clone of the input.
func (c cow) COWRefOfExtractValueExpr(n *ExtractValueExpr) (*ExtractValueExpr, bool) {
	if n == nil {
		return nil, false
	}
	Fragment, changedFragment := c.COWExpr(n.Fragment)
	XPathExpr, changedXPathExpr := c.COWExpr(n.XPathExpr)
	if changedFragment || changedXPathExpr {
		out := *n
		out.Fragment = Fragment
		out.XPathExpr = XPathExpr
		return &out, true
	}
	return n, false
}

// COWRefOfExtractedSubquery creates a deep clone of the input.
func (c cow) COWRefOfExtractedSubquery(n *ExtractedSubquery) (*ExtractedSubquery, bool) {
	if n == nil {
		return nil, false
	}
	Original, changedOriginal := c.COWExpr(n.Original)
	Subquery, changedSubquery := c.COWRefOfSubquery(n.Subquery)
	OtherSide, changedOtherSide := c.COWExpr(n.OtherSide)
	alternative, changedalternative := c.COWExpr(n.alternative)
	if changedOriginal || changedSubquery || changedOtherSide || changedalternative {
		out := *n
		out.Original = Original
		out.Subquery = Subquery
		out.OtherSide = OtherSide
		out.alternative = alternative
		return &out, true
	}
	return n, false
}

// COWRefOfFirstOrLastValueExpr creates a deep clone of the input.
func (c cow) COWRefOfFirstOrLastValueExpr(n *FirstOrLastValueExpr) (*FirstOrLastValueExpr, bool) {
	if n == nil {
		return nil, false
	}
	Expr, changedExpr := c.COWExpr(n.Expr)
	NullTreatmentClause, changedNullTreatmentClause := c.COWRefOfNullTreatmentClause(n.NullTreatmentClause)
	OverClause, changedOverClause := c.COWRefOfOverClause(n.OverClause)
	if changedExpr || changedNullTreatmentClause || changedOverClause {
		out := *n
		out.Expr = Expr
		out.NullTreatmentClause = NullTreatmentClause
		out.OverClause = OverClause
		return &out, true
	}
	return n, false
}

// COWRefOfFlush creates a deep clone of the input.
func (c cow) COWRefOfFlush(n *Flush) (*Flush, bool) {
	if n == nil {
		return nil, false
	}
	FlushOptions, changedFlushOptions := c.COWSliceOfString(n.FlushOptions)
	TableNames, changedTableNames := c.COWTableNames(n.TableNames)
	if changedFlushOptions || changedTableNames {
		out := *n
		out.FlushOptions = FlushOptions
		out.TableNames = TableNames
		return &out, true
	}
	return n, false
}

// COWRefOfForce creates a deep clone of the input.
func (c cow) COWRefOfForce(n *Force) (*Force, bool) {
	if n == nil {
		return nil, false
	}
	return n, false
}

// COWRefOfForeignKeyDefinition creates a deep clone of the input.
func (c cow) COWRefOfForeignKeyDefinition(n *ForeignKeyDefinition) (*ForeignKeyDefinition, bool) {
	if n == nil {
		return nil, false
	}
	Source, changedSource := c.COWColumns(n.Source)
	IndexName, changedIndexName := c.COWIdentifierCI(n.IndexName)
	ReferenceDefinition, changedReferenceDefinition := c.COWRefOfReferenceDefinition(n.ReferenceDefinition)
	if changedSource || changedIndexName || changedReferenceDefinition {
		out := *n
		out.Source = Source
		out.IndexName = IndexName
		out.ReferenceDefinition = ReferenceDefinition
		return &out, true
	}
	return n, false
}

// COWRefOfFrameClause creates a deep clone of the input.
func (c cow) COWRefOfFrameClause(n *FrameClause) (*FrameClause, bool) {
	if n == nil {
		return nil, false
	}
	Start, changedStart := c.COWRefOfFramePoint(n.Start)
	End, changedEnd := c.COWRefOfFramePoint(n.End)
	if changedStart || changedEnd {
		out := *n
		out.Start = Start
		out.End = End
		return &out, true
	}
	return n, false
}

// COWRefOfFramePoint creates a deep clone of the input.
func (c cow) COWRefOfFramePoint(n *FramePoint) (*FramePoint, bool) {
	if n == nil {
		return nil, false
	}
	Expr, changedExpr := c.COWExpr(n.Expr)
	if changedExpr {
		out := *n
		out.Expr = Expr
		return &out, true
	}
	return n, false
}

// COWRefOfFromFirstLastClause creates a deep clone of the input.
func (c cow) COWRefOfFromFirstLastClause(n *FromFirstLastClause) (*FromFirstLastClause, bool) {
	if n == nil {
		return nil, false
	}
	return n, false
}

// COWRefOfFuncExpr creates a deep clone of the input.
func (c cow) COWRefOfFuncExpr(n *FuncExpr) (*FuncExpr, bool) {
	if n == nil {
		return nil, false
	}
	Qualifier, changedQualifier := c.COWIdentifierCS(n.Qualifier)
	Name, changedName := c.COWIdentifierCI(n.Name)
	Exprs, changedExprs := c.COWSelectExprs(n.Exprs)
	if changedQualifier || changedName || changedExprs {
		out := *n
		out.Qualifier = Qualifier
		out.Name = Name
		out.Exprs = Exprs
		return &out, true
	}
	return n, false
}

// COWRefOfGTIDFuncExpr creates a deep clone of the input.
func (c cow) COWRefOfGTIDFuncExpr(n *GTIDFuncExpr) (*GTIDFuncExpr, bool) {
	if n == nil {
		return nil, false
	}
	Set1, changedSet1 := c.COWExpr(n.Set1)
	Set2, changedSet2 := c.COWExpr(n.Set2)
	Timeout, changedTimeout := c.COWExpr(n.Timeout)
	Channel, changedChannel := c.COWExpr(n.Channel)
	if changedSet1 || changedSet2 || changedTimeout || changedChannel {
		out := *n
		out.Set1 = Set1
		out.Set2 = Set2
		out.Timeout = Timeout
		out.Channel = Channel
		return &out, true
	}
	return n, false
}

// COWGroupBy creates a deep clone of the input.
func COWGroupBy(n GroupBy) GroupBy {
	if n == nil {
		return nil
	}
	res := make(GroupBy, len(n))
	for i, x := range n {
		res[i] = c.COWExpr(x)
	}
	return res
}

// COWRefOfGroupConcatExpr creates a deep clone of the input.
func (c cow) COWRefOfGroupConcatExpr(n *GroupConcatExpr) (*GroupConcatExpr, bool) {
	if n == nil {
		return nil, false
	}
	Exprs, changedExprs := c.COWExprs(n.Exprs)
	OrderBy, changedOrderBy := c.COWOrderBy(n.OrderBy)
	Limit, changedLimit := c.COWRefOfLimit(n.Limit)
	if changedExprs || changedOrderBy || changedLimit {
		out := *n
		out.Exprs = Exprs
		out.OrderBy = OrderBy
		out.Limit = Limit
		return &out, true
	}
	return n, false
}

// COWIdentifierCI creates a deep clone of the input.
func COWIdentifierCI(n IdentifierCI) IdentifierCI {
	return *c.COWRefOfIdentifierCI(&n)
}

// COWIdentifierCS creates a deep clone of the input.
func COWIdentifierCS(n IdentifierCS) IdentifierCS {
	return *c.COWRefOfIdentifierCS(&n)
}

// COWRefOfIndexDefinition creates a deep clone of the input.
func (c cow) COWRefOfIndexDefinition(n *IndexDefinition) (*IndexDefinition, bool) {
	if n == nil {
		return nil, false
	}
	Info, changedInfo := c.COWRefOfIndexInfo(n.Info)
	Columns, changedColumns := c.COWSliceOfRefOfIndexColumn(n.Columns)
	Options, changedOptions := c.COWSliceOfRefOfIndexOption(n.Options)
	if changedInfo || changedColumns || changedOptions {
		out := *n
		out.Info = Info
		out.Columns = Columns
		out.Options = Options
		return &out, true
	}
	return n, false
}

// COWRefOfIndexHint creates a deep clone of the input.
func (c cow) COWRefOfIndexHint(n *IndexHint) (*IndexHint, bool) {
	if n == nil {
		return nil, false
	}
	Indexes, changedIndexes := c.COWSliceOfIdentifierCI(n.Indexes)
	if changedIndexes {
		out := *n
		out.Indexes = Indexes
		return &out, true
	}
	return n, false
}

// COWIndexHints creates a deep clone of the input.
func COWIndexHints(n IndexHints) IndexHints {
	if n == nil {
		return nil
	}
	res := make(IndexHints, len(n))
	for i, x := range n {
		res[i] = c.COWRefOfIndexHint(x)
	}
	return res
}

// COWRefOfIndexInfo creates a deep clone of the input.
func (c cow) COWRefOfIndexInfo(n *IndexInfo) (*IndexInfo, bool) {
	if n == nil {
		return nil, false
	}
	Name, changedName := c.COWIdentifierCI(n.Name)
	ConstraintName, changedConstraintName := c.COWIdentifierCI(n.ConstraintName)
	if changedName || changedConstraintName {
		out := *n
		out.Name = Name
		out.ConstraintName = ConstraintName
		return &out, true
	}
	return n, false
}

// COWRefOfInsert creates a deep clone of the input.
func (c cow) COWRefOfInsert(n *Insert) (*Insert, bool) {
	if n == nil {
		return nil, false
	}
	Comments, changedComments := c.COWRefOfParsedComments(n.Comments)
	Table, changedTable := c.COWTableName(n.Table)
	Partitions, changedPartitions := c.COWPartitions(n.Partitions)
	Columns, changedColumns := c.COWColumns(n.Columns)
	Rows, changedRows := c.COWInsertRows(n.Rows)
	OnDup, changedOnDup := c.COWOnDup(n.OnDup)
	if changedComments || changedTable || changedPartitions || changedColumns || changedRows || changedOnDup {
		out := *n
		out.Comments = Comments
		out.Table = Table
		out.Partitions = Partitions
		out.Columns = Columns
		out.Rows = Rows
		out.OnDup = OnDup
		return &out, true
	}
	return n, false
}

// COWRefOfInsertExpr creates a deep clone of the input.
func (c cow) COWRefOfInsertExpr(n *InsertExpr) (*InsertExpr, bool) {
	if n == nil {
		return nil, false
	}
	Str, changedStr := c.COWExpr(n.Str)
	Pos, changedPos := c.COWExpr(n.Pos)
	Len, changedLen := c.COWExpr(n.Len)
	NewStr, changedNewStr := c.COWExpr(n.NewStr)
	if changedStr || changedPos || changedLen || changedNewStr {
		out := *n
		out.Str = Str
		out.Pos = Pos
		out.Len = Len
		out.NewStr = NewStr
		return &out, true
	}
	return n, false
}

// COWRefOfIntervalExpr creates a deep clone of the input.
func (c cow) COWRefOfIntervalExpr(n *IntervalExpr) (*IntervalExpr, bool) {
	if n == nil {
		return nil, false
	}
	Expr, changedExpr := c.COWExpr(n.Expr)
	if changedExpr {
		out := *n
		out.Expr = Expr
		return &out, true
	}
	return n, false
}

// COWRefOfIntervalFuncExpr creates a deep clone of the input.
func (c cow) COWRefOfIntervalFuncExpr(n *IntervalFuncExpr) (*IntervalFuncExpr, bool) {
	if n == nil {
		return nil, false
	}
	Expr, changedExpr := c.COWExpr(n.Expr)
	Exprs, changedExprs := c.COWExprs(n.Exprs)
	if changedExpr || changedExprs {
		out := *n
		out.Expr = Expr
		out.Exprs = Exprs
		return &out, true
	}
	return n, false
}

// COWRefOfIntroducerExpr creates a deep clone of the input.
func (c cow) COWRefOfIntroducerExpr(n *IntroducerExpr) (*IntroducerExpr, bool) {
	if n == nil {
		return nil, false
	}
	Expr, changedExpr := c.COWExpr(n.Expr)
	if changedExpr {
		out := *n
		out.Expr = Expr
		return &out, true
	}
	return n, false
}

// COWRefOfIsExpr creates a deep clone of the input.
func (c cow) COWRefOfIsExpr(n *IsExpr) (*IsExpr, bool) {
	if n == nil {
		return nil, false
	}
	Left, changedLeft := c.COWExpr(n.Left)
	if changedLeft {
		out := *n
		out.Left = Left
		return &out, true
	}
	return n, false
}

// COWRefOfJSONArrayExpr creates a deep clone of the input.
func (c cow) COWRefOfJSONArrayExpr(n *JSONArrayExpr) (*JSONArrayExpr, bool) {
	if n == nil {
		return nil, false
	}
	Params, changedParams := c.COWExprs(n.Params)
	if changedParams {
		out := *n
		out.Params = Params
		return &out, true
	}
	return n, false
}

// COWRefOfJSONAttributesExpr creates a deep clone of the input.
func (c cow) COWRefOfJSONAttributesExpr(n *JSONAttributesExpr) (*JSONAttributesExpr, bool) {
	if n == nil {
		return nil, false
	}
	JSONDoc, changedJSONDoc := c.COWExpr(n.JSONDoc)
	Path, changedPath := c.COWExpr(n.Path)
	if changedJSONDoc || changedPath {
		out := *n
		out.JSONDoc = JSONDoc
		out.Path = Path
		return &out, true
	}
	return n, false
}

// COWRefOfJSONContainsExpr creates a deep clone of the input.
func (c cow) COWRefOfJSONContainsExpr(n *JSONContainsExpr) (*JSONContainsExpr, bool) {
	if n == nil {
		return nil, false
	}
	Target, changedTarget := c.COWExpr(n.Target)
	Candidate, changedCandidate := c.COWExpr(n.Candidate)
	PathList, changedPathList := c.COWSliceOfExpr(n.PathList)
	if changedTarget || changedCandidate || changedPathList {
		out := *n
		out.Target = Target
		out.Candidate = Candidate
		out.PathList = PathList
		return &out, true
	}
	return n, false
}

// COWRefOfJSONContainsPathExpr creates a deep clone of the input.
func (c cow) COWRefOfJSONContainsPathExpr(n *JSONContainsPathExpr) (*JSONContainsPathExpr, bool) {
	if n == nil {
		return nil, false
	}
	JSONDoc, changedJSONDoc := c.COWExpr(n.JSONDoc)
	OneOrAll, changedOneOrAll := c.COWExpr(n.OneOrAll)
	PathList, changedPathList := c.COWSliceOfExpr(n.PathList)
	if changedJSONDoc || changedOneOrAll || changedPathList {
		out := *n
		out.JSONDoc = JSONDoc
		out.OneOrAll = OneOrAll
		out.PathList = PathList
		return &out, true
	}
	return n, false
}

// COWRefOfJSONExtractExpr creates a deep clone of the input.
func (c cow) COWRefOfJSONExtractExpr(n *JSONExtractExpr) (*JSONExtractExpr, bool) {
	if n == nil {
		return nil, false
	}
	JSONDoc, changedJSONDoc := c.COWExpr(n.JSONDoc)
	PathList, changedPathList := c.COWSliceOfExpr(n.PathList)
	if changedJSONDoc || changedPathList {
		out := *n
		out.JSONDoc = JSONDoc
		out.PathList = PathList
		return &out, true
	}
	return n, false
}

// COWRefOfJSONKeysExpr creates a deep clone of the input.
func (c cow) COWRefOfJSONKeysExpr(n *JSONKeysExpr) (*JSONKeysExpr, bool) {
	if n == nil {
		return nil, false
	}
	JSONDoc, changedJSONDoc := c.COWExpr(n.JSONDoc)
	Path, changedPath := c.COWExpr(n.Path)
	if changedJSONDoc || changedPath {
		out := *n
		out.JSONDoc = JSONDoc
		out.Path = Path
		return &out, true
	}
	return n, false
}

// COWRefOfJSONObjectExpr creates a deep clone of the input.
func (c cow) COWRefOfJSONObjectExpr(n *JSONObjectExpr) (*JSONObjectExpr, bool) {
	if n == nil {
		return nil, false
	}
	Params, changedParams := c.COWSliceOfRefOfJSONObjectParam(n.Params)
	if changedParams {
		out := *n
		out.Params = Params
		return &out, true
	}
	return n, false
}

// COWJSONObjectParam creates a deep clone of the input.
func COWJSONObjectParam(n JSONObjectParam) JSONObjectParam {
	return *c.COWRefOfJSONObjectParam(&n)
}

// COWRefOfJSONOverlapsExpr creates a deep clone of the input.
func (c cow) COWRefOfJSONOverlapsExpr(n *JSONOverlapsExpr) (*JSONOverlapsExpr, bool) {
	if n == nil {
		return nil, false
	}
	JSONDoc1, changedJSONDoc1 := c.COWExpr(n.JSONDoc1)
	JSONDoc2, changedJSONDoc2 := c.COWExpr(n.JSONDoc2)
	if changedJSONDoc1 || changedJSONDoc2 {
		out := *n
		out.JSONDoc1 = JSONDoc1
		out.JSONDoc2 = JSONDoc2
		return &out, true
	}
	return n, false
}

// COWRefOfJSONPrettyExpr creates a deep clone of the input.
func (c cow) COWRefOfJSONPrettyExpr(n *JSONPrettyExpr) (*JSONPrettyExpr, bool) {
	if n == nil {
		return nil, false
	}
	JSONVal, changedJSONVal := c.COWExpr(n.JSONVal)
	if changedJSONVal {
		out := *n
		out.JSONVal = JSONVal
		return &out, true
	}
	return n, false
}

// COWRefOfJSONQuoteExpr creates a deep clone of the input.
func (c cow) COWRefOfJSONQuoteExpr(n *JSONQuoteExpr) (*JSONQuoteExpr, bool) {
	if n == nil {
		return nil, false
	}
	StringArg, changedStringArg := c.COWExpr(n.StringArg)
	if changedStringArg {
		out := *n
		out.StringArg = StringArg
		return &out, true
	}
	return n, false
}

// COWRefOfJSONRemoveExpr creates a deep clone of the input.
func (c cow) COWRefOfJSONRemoveExpr(n *JSONRemoveExpr) (*JSONRemoveExpr, bool) {
	if n == nil {
		return nil, false
	}
	JSONDoc, changedJSONDoc := c.COWExpr(n.JSONDoc)
	PathList, changedPathList := c.COWExprs(n.PathList)
	if changedJSONDoc || changedPathList {
		out := *n
		out.JSONDoc = JSONDoc
		out.PathList = PathList
		return &out, true
	}
	return n, false
}

// COWRefOfJSONSchemaValidFuncExpr creates a deep clone of the input.
func (c cow) COWRefOfJSONSchemaValidFuncExpr(n *JSONSchemaValidFuncExpr) (*JSONSchemaValidFuncExpr, bool) {
	if n == nil {
		return nil, false
	}
	Schema, changedSchema := c.COWExpr(n.Schema)
	Document, changedDocument := c.COWExpr(n.Document)
	if changedSchema || changedDocument {
		out := *n
		out.Schema = Schema
		out.Document = Document
		return &out, true
	}
	return n, false
}

// COWRefOfJSONSchemaValidationReportFuncExpr creates a deep clone of the input.
func (c cow) COWRefOfJSONSchemaValidationReportFuncExpr(n *JSONSchemaValidationReportFuncExpr) (*JSONSchemaValidationReportFuncExpr, bool) {
	if n == nil {
		return nil, false
	}
	Schema, changedSchema := c.COWExpr(n.Schema)
	Document, changedDocument := c.COWExpr(n.Document)
	if changedSchema || changedDocument {
		out := *n
		out.Schema = Schema
		out.Document = Document
		return &out, true
	}
	return n, false
}

// COWRefOfJSONSearchExpr creates a deep clone of the input.
func (c cow) COWRefOfJSONSearchExpr(n *JSONSearchExpr) (*JSONSearchExpr, bool) {
	if n == nil {
		return nil, false
	}
	JSONDoc, changedJSONDoc := c.COWExpr(n.JSONDoc)
	OneOrAll, changedOneOrAll := c.COWExpr(n.OneOrAll)
	SearchStr, changedSearchStr := c.COWExpr(n.SearchStr)
	EscapeChar, changedEscapeChar := c.COWExpr(n.EscapeChar)
	PathList, changedPathList := c.COWSliceOfExpr(n.PathList)
	if changedJSONDoc || changedOneOrAll || changedSearchStr || changedEscapeChar || changedPathList {
		out := *n
		out.JSONDoc = JSONDoc
		out.OneOrAll = OneOrAll
		out.SearchStr = SearchStr
		out.EscapeChar = EscapeChar
		out.PathList = PathList
		return &out, true
	}
	return n, false
}

// COWRefOfJSONStorageFreeExpr creates a deep clone of the input.
func (c cow) COWRefOfJSONStorageFreeExpr(n *JSONStorageFreeExpr) (*JSONStorageFreeExpr, bool) {
	if n == nil {
		return nil, false
	}
	JSONVal, changedJSONVal := c.COWExpr(n.JSONVal)
	if changedJSONVal {
		out := *n
		out.JSONVal = JSONVal
		return &out, true
	}
	return n, false
}

// COWRefOfJSONStorageSizeExpr creates a deep clone of the input.
func (c cow) COWRefOfJSONStorageSizeExpr(n *JSONStorageSizeExpr) (*JSONStorageSizeExpr, bool) {
	if n == nil {
		return nil, false
	}
	JSONVal, changedJSONVal := c.COWExpr(n.JSONVal)
	if changedJSONVal {
		out := *n
		out.JSONVal = JSONVal
		return &out, true
	}
	return n, false
}

// COWRefOfJSONTableExpr creates a deep clone of the input.
func (c cow) COWRefOfJSONTableExpr(n *JSONTableExpr) (*JSONTableExpr, bool) {
	if n == nil {
		return nil, false
	}
	Expr, changedExpr := c.COWExpr(n.Expr)
	Alias, changedAlias := c.COWIdentifierCS(n.Alias)
	Filter, changedFilter := c.COWExpr(n.Filter)
	Columns, changedColumns := c.COWSliceOfRefOfJtColumnDefinition(n.Columns)
	if changedExpr || changedAlias || changedFilter || changedColumns {
		out := *n
		out.Expr = Expr
		out.Alias = Alias
		out.Filter = Filter
		out.Columns = Columns
		return &out, true
	}
	return n, false
}

// COWRefOfJSONUnquoteExpr creates a deep clone of the input.
func (c cow) COWRefOfJSONUnquoteExpr(n *JSONUnquoteExpr) (*JSONUnquoteExpr, bool) {
	if n == nil {
		return nil, false
	}
	JSONValue, changedJSONValue := c.COWExpr(n.JSONValue)
	if changedJSONValue {
		out := *n
		out.JSONValue = JSONValue
		return &out, true
	}
	return n, false
}

// COWRefOfJSONValueExpr creates a deep clone of the input.
func (c cow) COWRefOfJSONValueExpr(n *JSONValueExpr) (*JSONValueExpr, bool) {
	if n == nil {
		return nil, false
	}
	JSONDoc, changedJSONDoc := c.COWExpr(n.JSONDoc)
	Path, changedPath := c.COWExpr(n.Path)
	ReturningType, changedReturningType := c.COWRefOfConvertType(n.ReturningType)
	EmptyOnResponse, changedEmptyOnResponse := c.COWRefOfJtOnResponse(n.EmptyOnResponse)
	ErrorOnResponse, changedErrorOnResponse := c.COWRefOfJtOnResponse(n.ErrorOnResponse)
	if changedJSONDoc || changedPath || changedReturningType || changedEmptyOnResponse || changedErrorOnResponse {
		out := *n
		out.JSONDoc = JSONDoc
		out.Path = Path
		out.ReturningType = ReturningType
		out.EmptyOnResponse = EmptyOnResponse
		out.ErrorOnResponse = ErrorOnResponse
		return &out, true
	}
	return n, false
}

// COWRefOfJSONValueMergeExpr creates a deep clone of the input.
func (c cow) COWRefOfJSONValueMergeExpr(n *JSONValueMergeExpr) (*JSONValueMergeExpr, bool) {
	if n == nil {
		return nil, false
	}
	JSONDoc, changedJSONDoc := c.COWExpr(n.JSONDoc)
	JSONDocList, changedJSONDocList := c.COWExprs(n.JSONDocList)
	if changedJSONDoc || changedJSONDocList {
		out := *n
		out.JSONDoc = JSONDoc
		out.JSONDocList = JSONDocList
		return &out, true
	}
	return n, false
}

// COWRefOfJSONValueModifierExpr creates a deep clone of the input.
func (c cow) COWRefOfJSONValueModifierExpr(n *JSONValueModifierExpr) (*JSONValueModifierExpr, bool) {
	if n == nil {
		return nil, false
	}
	JSONDoc, changedJSONDoc := c.COWExpr(n.JSONDoc)
	Params, changedParams := c.COWSliceOfRefOfJSONObjectParam(n.Params)
	if changedJSONDoc || changedParams {
		out := *n
		out.JSONDoc = JSONDoc
		out.Params = Params
		return &out, true
	}
	return n, false
}

// COWRefOfJoinCondition creates a deep clone of the input.
func (c cow) COWRefOfJoinCondition(n *JoinCondition) (*JoinCondition, bool) {
	if n == nil {
		return nil, false
	}
	On, changedOn := c.COWExpr(n.On)
	Using, changedUsing := c.COWColumns(n.Using)
	if changedOn || changedUsing {
		out := *n
		out.On = On
		out.Using = Using
		return &out, true
	}
	return n, false
}

// COWRefOfJoinTableExpr creates a deep clone of the input.
func (c cow) COWRefOfJoinTableExpr(n *JoinTableExpr) (*JoinTableExpr, bool) {
	if n == nil {
		return nil, false
	}
	LeftExpr, changedLeftExpr := c.COWTableExpr(n.LeftExpr)
	RightExpr, changedRightExpr := c.COWTableExpr(n.RightExpr)
	Condition, changedCondition := c.COWRefOfJoinCondition(n.Condition)
	if changedLeftExpr || changedRightExpr || changedCondition {
		out := *n
		out.LeftExpr = LeftExpr
		out.RightExpr = RightExpr
		out.Condition = Condition
		return &out, true
	}
	return n, false
}

// COWRefOfJtColumnDefinition creates a deep clone of the input.
func (c cow) COWRefOfJtColumnDefinition(n *JtColumnDefinition) (*JtColumnDefinition, bool) {
	if n == nil {
		return nil, false
	}
	JtOrdinal, changedJtOrdinal := c.COWRefOfJtOrdinalColDef(n.JtOrdinal)
	JtPath, changedJtPath := c.COWRefOfJtPathColDef(n.JtPath)
	JtNestedPath, changedJtNestedPath := c.COWRefOfJtNestedPathColDef(n.JtNestedPath)
	if changedJtOrdinal || changedJtPath || changedJtNestedPath {
		out := *n
		out.JtOrdinal = JtOrdinal
		out.JtPath = JtPath
		out.JtNestedPath = JtNestedPath
		return &out, true
	}
	return n, false
}

// COWRefOfJtOnResponse creates a deep clone of the input.
func (c cow) COWRefOfJtOnResponse(n *JtOnResponse) (*JtOnResponse, bool) {
	if n == nil {
		return nil, false
	}
	Expr, changedExpr := c.COWExpr(n.Expr)
	if changedExpr {
		out := *n
		out.Expr = Expr
		return &out, true
	}
	return n, false
}

// COWRefOfKeyState creates a deep clone of the input.
func (c cow) COWRefOfKeyState(n *KeyState) (*KeyState, bool) {
	if n == nil {
		return nil, false
	}
	return n, false
}

// COWRefOfLagLeadExpr creates a deep clone of the input.
func (c cow) COWRefOfLagLeadExpr(n *LagLeadExpr) (*LagLeadExpr, bool) {
	if n == nil {
		return nil, false
	}
	Expr, changedExpr := c.COWExpr(n.Expr)
	N, changedN := c.COWExpr(n.N)
	Default, changedDefault := c.COWExpr(n.Default)
	OverClause, changedOverClause := c.COWRefOfOverClause(n.OverClause)
	NullTreatmentClause, changedNullTreatmentClause := c.COWRefOfNullTreatmentClause(n.NullTreatmentClause)
	if changedExpr || changedN || changedDefault || changedOverClause || changedNullTreatmentClause {
		out := *n
		out.Expr = Expr
		out.N = N
		out.Default = Default
		out.OverClause = OverClause
		out.NullTreatmentClause = NullTreatmentClause
		return &out, true
	}
	return n, false
}

// COWRefOfLimit creates a deep clone of the input.
func (c cow) COWRefOfLimit(n *Limit) (*Limit, bool) {
	if n == nil {
		return nil, false
	}
	Offset, changedOffset := c.COWExpr(n.Offset)
	Rowcount, changedRowcount := c.COWExpr(n.Rowcount)
	if changedOffset || changedRowcount {
		out := *n
		out.Offset = Offset
		out.Rowcount = Rowcount
		return &out, true
	}
	return n, false
}

// COWRefOfLiteral creates a deep clone of the input.
func (c cow) COWRefOfLiteral(n *Literal) (*Literal, bool) {
	if n == nil {
		return nil, false
	}
	return n, false
}

// COWRefOfLoad creates a deep clone of the input.
func (c cow) COWRefOfLoad(n *Load) (*Load, bool) {
	if n == nil {
		return nil, false
	}
	return n, false
}

// COWRefOfLocateExpr creates a deep clone of the input.
func (c cow) COWRefOfLocateExpr(n *LocateExpr) (*LocateExpr, bool) {
	if n == nil {
		return nil, false
	}
	SubStr, changedSubStr := c.COWExpr(n.SubStr)
	Str, changedStr := c.COWExpr(n.Str)
	Pos, changedPos := c.COWExpr(n.Pos)
	if changedSubStr || changedStr || changedPos {
		out := *n
		out.SubStr = SubStr
		out.Str = Str
		out.Pos = Pos
		return &out, true
	}
	return n, false
}

// COWRefOfLockOption creates a deep clone of the input.
func (c cow) COWRefOfLockOption(n *LockOption) (*LockOption, bool) {
	if n == nil {
		return nil, false
	}
	return n, false
}

// COWRefOfLockTables creates a deep clone of the input.
func (c cow) COWRefOfLockTables(n *LockTables) (*LockTables, bool) {
	if n == nil {
		return nil, false
	}
	Tables, changedTables := c.COWTableAndLockTypes(n.Tables)
	if changedTables {
		out := *n
		out.Tables = Tables
		return &out, true
	}
	return n, false
}

// COWRefOfLockingFunc creates a deep clone of the input.
func (c cow) COWRefOfLockingFunc(n *LockingFunc) (*LockingFunc, bool) {
	if n == nil {
		return nil, false
	}
	Name, changedName := c.COWExpr(n.Name)
	Timeout, changedTimeout := c.COWExpr(n.Timeout)
	if changedName || changedTimeout {
		out := *n
		out.Name = Name
		out.Timeout = Timeout
		return &out, true
	}
	return n, false
}

// COWRefOfMatchExpr creates a deep clone of the input.
func (c cow) COWRefOfMatchExpr(n *MatchExpr) (*MatchExpr, bool) {
	if n == nil {
		return nil, false
	}
	Columns, changedColumns := c.COWSliceOfRefOfColName(n.Columns)
	Expr, changedExpr := c.COWExpr(n.Expr)
	if changedColumns || changedExpr {
		out := *n
		out.Columns = Columns
		out.Expr = Expr
		return &out, true
	}
	return n, false
}

// COWRefOfMax creates a deep clone of the input.
func (c cow) COWRefOfMax(n *Max) (*Max, bool) {
	if n == nil {
		return nil, false
	}
	Arg, changedArg := c.COWExpr(n.Arg)
	if changedArg {
		out := *n
		out.Arg = Arg
		return &out, true
	}
	return n, false
}

// COWRefOfMemberOfExpr creates a deep clone of the input.
func (c cow) COWRefOfMemberOfExpr(n *MemberOfExpr) (*MemberOfExpr, bool) {
	if n == nil {
		return nil, false
	}
	Value, changedValue := c.COWExpr(n.Value)
	JSONArr, changedJSONArr := c.COWExpr(n.JSONArr)
	if changedValue || changedJSONArr {
		out := *n
		out.Value = Value
		out.JSONArr = JSONArr
		return &out, true
	}
	return n, false
}

// COWRefOfMin creates a deep clone of the input.
func (c cow) COWRefOfMin(n *Min) (*Min, bool) {
	if n == nil {
		return nil, false
	}
	Arg, changedArg := c.COWExpr(n.Arg)
	if changedArg {
		out := *n
		out.Arg = Arg
		return &out, true
	}
	return n, false
}

// COWRefOfModifyColumn creates a deep clone of the input.
func (c cow) COWRefOfModifyColumn(n *ModifyColumn) (*ModifyColumn, bool) {
	if n == nil {
		return nil, false
	}
	NewColDefinition, changedNewColDefinition := c.COWRefOfColumnDefinition(n.NewColDefinition)
	After, changedAfter := c.COWRefOfColName(n.After)
	if changedNewColDefinition || changedAfter {
		out := *n
		out.NewColDefinition = NewColDefinition
		out.After = After
		return &out, true
	}
	return n, false
}

// COWRefOfNTHValueExpr creates a deep clone of the input.
func (c cow) COWRefOfNTHValueExpr(n *NTHValueExpr) (*NTHValueExpr, bool) {
	if n == nil {
		return nil, false
	}
	Expr, changedExpr := c.COWExpr(n.Expr)
	N, changedN := c.COWExpr(n.N)
	OverClause, changedOverClause := c.COWRefOfOverClause(n.OverClause)
	FromFirstLastClause, changedFromFirstLastClause := c.COWRefOfFromFirstLastClause(n.FromFirstLastClause)
	NullTreatmentClause, changedNullTreatmentClause := c.COWRefOfNullTreatmentClause(n.NullTreatmentClause)
	if changedExpr || changedN || changedOverClause || changedFromFirstLastClause || changedNullTreatmentClause {
		out := *n
		out.Expr = Expr
		out.N = N
		out.OverClause = OverClause
		out.FromFirstLastClause = FromFirstLastClause
		out.NullTreatmentClause = NullTreatmentClause
		return &out, true
	}
	return n, false
}

// COWRefOfNamedWindow creates a deep clone of the input.
func (c cow) COWRefOfNamedWindow(n *NamedWindow) (*NamedWindow, bool) {
	if n == nil {
		return nil, false
	}
	Windows, changedWindows := c.COWWindowDefinitions(n.Windows)
	if changedWindows {
		out := *n
		out.Windows = Windows
		return &out, true
	}
	return n, false
}

// COWNamedWindows creates a deep clone of the input.
func COWNamedWindows(n NamedWindows) NamedWindows {
	if n == nil {
		return nil
	}
	res := make(NamedWindows, len(n))
	for i, x := range n {
		res[i] = c.COWRefOfNamedWindow(x)
	}
	return res
}

// COWRefOfNextval creates a deep clone of the input.
func (c cow) COWRefOfNextval(n *Nextval) (*Nextval, bool) {
	if n == nil {
		return nil, false
	}
	Expr, changedExpr := c.COWExpr(n.Expr)
	if changedExpr {
		out := *n
		out.Expr = Expr
		return &out, true
	}
	return n, false
}

// COWRefOfNotExpr creates a deep clone of the input.
func (c cow) COWRefOfNotExpr(n *NotExpr) (*NotExpr, bool) {
	if n == nil {
		return nil, false
	}
	Expr, changedExpr := c.COWExpr(n.Expr)
	if changedExpr {
		out := *n
		out.Expr = Expr
		return &out, true
	}
	return n, false
}

// COWRefOfNtileExpr creates a deep clone of the input.
func (c cow) COWRefOfNtileExpr(n *NtileExpr) (*NtileExpr, bool) {
	if n == nil {
		return nil, false
	}
	N, changedN := c.COWExpr(n.N)
	OverClause, changedOverClause := c.COWRefOfOverClause(n.OverClause)
	if changedN || changedOverClause {
		out := *n
		out.N = N
		out.OverClause = OverClause
		return &out, true
	}
	return n, false
}

// COWRefOfNullTreatmentClause creates a deep clone of the input.
func (c cow) COWRefOfNullTreatmentClause(n *NullTreatmentClause) (*NullTreatmentClause, bool) {
	if n == nil {
		return nil, false
	}
	return n, false
}

// COWRefOfNullVal creates a deep clone of the input.
func (c cow) COWRefOfNullVal(n *NullVal) (*NullVal, bool) {
	if n == nil {
		return nil, false
	}
	return n, false
}

// COWRefOfOffset creates a deep clone of the input.
func (c cow) COWRefOfOffset(n *Offset) (*Offset, bool) {
	if n == nil {
		return nil, false
	}
	return n, false
}

// COWOnDup creates a deep clone of the input.
func COWOnDup(n OnDup) OnDup {
	if n == nil {
		return nil
	}
	res := make(OnDup, len(n))
	for i, x := range n {
		res[i] = c.COWRefOfUpdateExpr(x)
	}
	return res
}

// COWRefOfOptLike creates a deep clone of the input.
func (c cow) COWRefOfOptLike(n *OptLike) (*OptLike, bool) {
	if n == nil {
		return nil, false
	}
	LikeTable, changedLikeTable := c.COWTableName(n.LikeTable)
	if changedLikeTable {
		out := *n
		out.LikeTable = LikeTable
		return &out, true
	}
	return n, false
}

// COWRefOfOrExpr creates a deep clone of the input.
func (c cow) COWRefOfOrExpr(n *OrExpr) (*OrExpr, bool) {
	if n == nil {
		return nil, false
	}
	Left, changedLeft := c.COWExpr(n.Left)
	Right, changedRight := c.COWExpr(n.Right)
	if changedLeft || changedRight {
		out := *n
		out.Left = Left
		out.Right = Right
		return &out, true
	}
	return n, false
}

// COWRefOfOrder creates a deep clone of the input.
func (c cow) COWRefOfOrder(n *Order) (*Order, bool) {
	if n == nil {
		return nil, false
	}
	Expr, changedExpr := c.COWExpr(n.Expr)
	if changedExpr {
		out := *n
		out.Expr = Expr
		return &out, true
	}
	return n, false
}

// COWOrderBy creates a deep clone of the input.
func COWOrderBy(n OrderBy) OrderBy {
	if n == nil {
		return nil
	}
	res := make(OrderBy, len(n))
	for i, x := range n {
		res[i] = c.COWRefOfOrder(x)
	}
	return res
}

// COWRefOfOrderByOption creates a deep clone of the input.
func (c cow) COWRefOfOrderByOption(n *OrderByOption) (*OrderByOption, bool) {
	if n == nil {
		return nil, false
	}
	Cols, changedCols := c.COWColumns(n.Cols)
	if changedCols {
		out := *n
		out.Cols = Cols
		return &out, true
	}
	return n, false
}

// COWRefOfOtherAdmin creates a deep clone of the input.
func (c cow) COWRefOfOtherAdmin(n *OtherAdmin) (*OtherAdmin, bool) {
	if n == nil {
		return nil, false
	}
	return n, false
}

// COWRefOfOtherRead creates a deep clone of the input.
func (c cow) COWRefOfOtherRead(n *OtherRead) (*OtherRead, bool) {
	if n == nil {
		return nil, false
	}
	return n, false
}

// COWRefOfOverClause creates a deep clone of the input.
func (c cow) COWRefOfOverClause(n *OverClause) (*OverClause, bool) {
	if n == nil {
		return nil, false
	}
	WindowName, changedWindowName := c.COWIdentifierCI(n.WindowName)
	WindowSpec, changedWindowSpec := c.COWRefOfWindowSpecification(n.WindowSpec)
	if changedWindowName || changedWindowSpec {
		out := *n
		out.WindowName = WindowName
		out.WindowSpec = WindowSpec
		return &out, true
	}
	return n, false
}

// COWRefOfParenTableExpr creates a deep clone of the input.
func (c cow) COWRefOfParenTableExpr(n *ParenTableExpr) (*ParenTableExpr, bool) {
	if n == nil {
		return nil, false
	}
	Exprs, changedExprs := c.COWTableExprs(n.Exprs)
	if changedExprs {
		out := *n
		out.Exprs = Exprs
		return &out, true
	}
	return n, false
}

// COWRefOfParsedComments creates a deep clone of the input.
func (c cow) COWRefOfParsedComments(n *ParsedComments) (*ParsedComments, bool) {
	if n == nil {
		return nil, false
	}
	comments, changedcomments := c.COWComments(n.comments)
	if changedcomments {
		out := *n
		out.comments = comments
		return &out, true
	}
	return n, false
}

// COWRefOfPartitionDefinition creates a deep clone of the input.
func (c cow) COWRefOfPartitionDefinition(n *PartitionDefinition) (*PartitionDefinition, bool) {
	if n == nil {
		return nil, false
	}
	Name, changedName := c.COWIdentifierCI(n.Name)
	Options, changedOptions := c.COWRefOfPartitionDefinitionOptions(n.Options)
	if changedName || changedOptions {
		out := *n
		out.Name = Name
		out.Options = Options
		return &out, true
	}
	return n, false
}

// COWRefOfPartitionDefinitionOptions creates a deep clone of the input.
func (c cow) COWRefOfPartitionDefinitionOptions(n *PartitionDefinitionOptions) (*PartitionDefinitionOptions, bool) {
	if n == nil {
		return nil, false
	}
	ValueRange, changedValueRange := c.COWRefOfPartitionValueRange(n.ValueRange)
	Comment, changedComment := c.COWRefOfLiteral(n.Comment)
	Engine, changedEngine := c.COWRefOfPartitionEngine(n.Engine)
	DataDirectory, changedDataDirectory := c.COWRefOfLiteral(n.DataDirectory)
	IndexDirectory, changedIndexDirectory := c.COWRefOfLiteral(n.IndexDirectory)
	MaxRows, changedMaxRows := c.COWRefOfInt(n.MaxRows)
	MinRows, changedMinRows := c.COWRefOfInt(n.MinRows)
	SubPartitionDefinitions, changedSubPartitionDefinitions := c.COWSubPartitionDefinitions(n.SubPartitionDefinitions)
	if changedValueRange || changedComment || changedEngine || changedDataDirectory || changedIndexDirectory || changedMaxRows || changedMinRows || changedSubPartitionDefinitions {
		out := *n
		out.ValueRange = ValueRange
		out.Comment = Comment
		out.Engine = Engine
		out.DataDirectory = DataDirectory
		out.IndexDirectory = IndexDirectory
		out.MaxRows = MaxRows
		out.MinRows = MinRows
		out.SubPartitionDefinitions = SubPartitionDefinitions
		return &out, true
	}
	return n, false
}

// COWRefOfPartitionEngine creates a deep clone of the input.
func (c cow) COWRefOfPartitionEngine(n *PartitionEngine) (*PartitionEngine, bool) {
	if n == nil {
		return nil, false
	}
	return n, false
}

// COWRefOfPartitionOption creates a deep clone of the input.
func (c cow) COWRefOfPartitionOption(n *PartitionOption) (*PartitionOption, bool) {
	if n == nil {
		return nil, false
	}
	ColList, changedColList := c.COWColumns(n.ColList)
	Expr, changedExpr := c.COWExpr(n.Expr)
	SubPartition, changedSubPartition := c.COWRefOfSubPartition(n.SubPartition)
	Definitions, changedDefinitions := c.COWSliceOfRefOfPartitionDefinition(n.Definitions)
	if changedColList || changedExpr || changedSubPartition || changedDefinitions {
		out := *n
		out.ColList = ColList
		out.Expr = Expr
		out.SubPartition = SubPartition
		out.Definitions = Definitions
		return &out, true
	}
	return n, false
}

// COWRefOfPartitionSpec creates a deep clone of the input.
func (c cow) COWRefOfPartitionSpec(n *PartitionSpec) (*PartitionSpec, bool) {
	if n == nil {
		return nil, false
	}
	Names, changedNames := c.COWPartitions(n.Names)
	Number, changedNumber := c.COWRefOfLiteral(n.Number)
	TableName, changedTableName := c.COWTableName(n.TableName)
	Definitions, changedDefinitions := c.COWSliceOfRefOfPartitionDefinition(n.Definitions)
	if changedNames || changedNumber || changedTableName || changedDefinitions {
		out := *n
		out.Names = Names
		out.Number = Number
		out.TableName = TableName
		out.Definitions = Definitions
		return &out, true
	}
	return n, false
}

// COWRefOfPartitionValueRange creates a deep clone of the input.
func (c cow) COWRefOfPartitionValueRange(n *PartitionValueRange) (*PartitionValueRange, bool) {
	if n == nil {
		return nil, false
	}
	Range, changedRange := c.COWValTuple(n.Range)
	if changedRange {
		out := *n
		out.Range = Range
		return &out, true
	}
	return n, false
}

// COWPartitions creates a deep clone of the input.
func COWPartitions(n Partitions) Partitions {
	if n == nil {
		return nil
	}
	res := make(Partitions, len(n))
	for i, x := range n {
		res[i] = c.COWIdentifierCI(x)
	}
	return res
}

// COWRefOfPerformanceSchemaFuncExpr creates a deep clone of the input.
func (c cow) COWRefOfPerformanceSchemaFuncExpr(n *PerformanceSchemaFuncExpr) (*PerformanceSchemaFuncExpr, bool) {
	if n == nil {
		return nil, false
	}
	Argument, changedArgument := c.COWExpr(n.Argument)
	if changedArgument {
		out := *n
		out.Argument = Argument
		return &out, true
	}
	return n, false
}

// COWRefOfPrepareStmt creates a deep clone of the input.
func (c cow) COWRefOfPrepareStmt(n *PrepareStmt) (*PrepareStmt, bool) {
	if n == nil {
		return nil, false
	}
	Name, changedName := c.COWIdentifierCI(n.Name)
	Statement, changedStatement := c.COWExpr(n.Statement)
	Comments, changedComments := c.COWRefOfParsedComments(n.Comments)
	if changedName || changedStatement || changedComments {
		out := *n
		out.Name = Name
		out.Statement = Statement
		out.Comments = Comments
		return &out, true
	}
	return n, false
}

// COWRefOfReferenceDefinition creates a deep clone of the input.
func (c cow) COWRefOfReferenceDefinition(n *ReferenceDefinition) (*ReferenceDefinition, bool) {
	if n == nil {
		return nil, false
	}
	ReferencedTable, changedReferencedTable := c.COWTableName(n.ReferencedTable)
	ReferencedColumns, changedReferencedColumns := c.COWColumns(n.ReferencedColumns)
	if changedReferencedTable || changedReferencedColumns {
		out := *n
		out.ReferencedTable = ReferencedTable
		out.ReferencedColumns = ReferencedColumns
		return &out, true
	}
	return n, false
}

// COWRefOfRegexpInstrExpr creates a deep clone of the input.
func (c cow) COWRefOfRegexpInstrExpr(n *RegexpInstrExpr) (*RegexpInstrExpr, bool) {
	if n == nil {
		return nil, false
	}
	Expr, changedExpr := c.COWExpr(n.Expr)
	Pattern, changedPattern := c.COWExpr(n.Pattern)
	Position, changedPosition := c.COWExpr(n.Position)
	Occurrence, changedOccurrence := c.COWExpr(n.Occurrence)
	ReturnOption, changedReturnOption := c.COWExpr(n.ReturnOption)
	MatchType, changedMatchType := c.COWExpr(n.MatchType)
	if changedExpr || changedPattern || changedPosition || changedOccurrence || changedReturnOption || changedMatchType {
		out := *n
		out.Expr = Expr
		out.Pattern = Pattern
		out.Position = Position
		out.Occurrence = Occurrence
		out.ReturnOption = ReturnOption
		out.MatchType = MatchType
		return &out, true
	}
	return n, false
}

// COWRefOfRegexpLikeExpr creates a deep clone of the input.
func (c cow) COWRefOfRegexpLikeExpr(n *RegexpLikeExpr) (*RegexpLikeExpr, bool) {
	if n == nil {
		return nil, false
	}
	Expr, changedExpr := c.COWExpr(n.Expr)
	Pattern, changedPattern := c.COWExpr(n.Pattern)
	MatchType, changedMatchType := c.COWExpr(n.MatchType)
	if changedExpr || changedPattern || changedMatchType {
		out := *n
		out.Expr = Expr
		out.Pattern = Pattern
		out.MatchType = MatchType
		return &out, true
	}
	return n, false
}

// COWRefOfRegexpReplaceExpr creates a deep clone of the input.
func (c cow) COWRefOfRegexpReplaceExpr(n *RegexpReplaceExpr) (*RegexpReplaceExpr, bool) {
	if n == nil {
		return nil, false
	}
	Expr, changedExpr := c.COWExpr(n.Expr)
	Pattern, changedPattern := c.COWExpr(n.Pattern)
	Repl, changedRepl := c.COWExpr(n.Repl)
	Occurrence, changedOccurrence := c.COWExpr(n.Occurrence)
	Position, changedPosition := c.COWExpr(n.Position)
	MatchType, changedMatchType := c.COWExpr(n.MatchType)
	if changedExpr || changedPattern || changedRepl || changedOccurrence || changedPosition || changedMatchType {
		out := *n
		out.Expr = Expr
		out.Pattern = Pattern
		out.Repl = Repl
		out.Occurrence = Occurrence
		out.Position = Position
		out.MatchType = MatchType
		return &out, true
	}
	return n, false
}

// COWRefOfRegexpSubstrExpr creates a deep clone of the input.
func (c cow) COWRefOfRegexpSubstrExpr(n *RegexpSubstrExpr) (*RegexpSubstrExpr, bool) {
	if n == nil {
		return nil, false
	}
	Expr, changedExpr := c.COWExpr(n.Expr)
	Pattern, changedPattern := c.COWExpr(n.Pattern)
	Occurrence, changedOccurrence := c.COWExpr(n.Occurrence)
	Position, changedPosition := c.COWExpr(n.Position)
	MatchType, changedMatchType := c.COWExpr(n.MatchType)
	if changedExpr || changedPattern || changedOccurrence || changedPosition || changedMatchType {
		out := *n
		out.Expr = Expr
		out.Pattern = Pattern
		out.Occurrence = Occurrence
		out.Position = Position
		out.MatchType = MatchType
		return &out, true
	}
	return n, false
}

// COWRefOfRelease creates a deep clone of the input.
func (c cow) COWRefOfRelease(n *Release) (*Release, bool) {
	if n == nil {
		return nil, false
	}
	Name, changedName := c.COWIdentifierCI(n.Name)
	if changedName {
		out := *n
		out.Name = Name
		return &out, true
	}
	return n, false
}

// COWRefOfRenameColumn creates a deep clone of the input.
func (c cow) COWRefOfRenameColumn(n *RenameColumn) (*RenameColumn, bool) {
	if n == nil {
		return nil, false
	}
	OldName, changedOldName := c.COWRefOfColName(n.OldName)
	NewName, changedNewName := c.COWRefOfColName(n.NewName)
	if changedOldName || changedNewName {
		out := *n
		out.OldName = OldName
		out.NewName = NewName
		return &out, true
	}
	return n, false
}

// COWRefOfRenameIndex creates a deep clone of the input.
func (c cow) COWRefOfRenameIndex(n *RenameIndex) (*RenameIndex, bool) {
	if n == nil {
		return nil, false
	}
	OldName, changedOldName := c.COWIdentifierCI(n.OldName)
	NewName, changedNewName := c.COWIdentifierCI(n.NewName)
	if changedOldName || changedNewName {
		out := *n
		out.OldName = OldName
		out.NewName = NewName
		return &out, true
	}
	return n, false
}

// COWRefOfRenameTable creates a deep clone of the input.
func (c cow) COWRefOfRenameTable(n *RenameTable) (*RenameTable, bool) {
	if n == nil {
		return nil, false
	}
	TablePairs, changedTablePairs := c.COWSliceOfRefOfRenameTablePair(n.TablePairs)
	if changedTablePairs {
		out := *n
		out.TablePairs = TablePairs
		return &out, true
	}
	return n, false
}

// COWRefOfRenameTableName creates a deep clone of the input.
func (c cow) COWRefOfRenameTableName(n *RenameTableName) (*RenameTableName, bool) {
	if n == nil {
		return nil, false
	}
	Table, changedTable := c.COWTableName(n.Table)
	if changedTable {
		out := *n
		out.Table = Table
		return &out, true
	}
	return n, false
}

// COWRefOfRevertMigration creates a deep clone of the input.
func (c cow) COWRefOfRevertMigration(n *RevertMigration) (*RevertMigration, bool) {
	if n == nil {
		return nil, false
	}
	Comments, changedComments := c.COWRefOfParsedComments(n.Comments)
	if changedComments {
		out := *n
		out.Comments = Comments
		return &out, true
	}
	return n, false
}

// COWRefOfRollback creates a deep clone of the input.
func (c cow) COWRefOfRollback(n *Rollback) (*Rollback, bool) {
	if n == nil {
		return nil, false
	}
	return n, false
}

// COWRootNode creates a deep clone of the input.
func COWRootNode(n RootNode) RootNode {
	return *c.COWRefOfRootNode(&n)
}

// COWRefOfSRollback creates a deep clone of the input.
func (c cow) COWRefOfSRollback(n *SRollback) (*SRollback, bool) {
	if n == nil {
		return nil, false
	}
	Name, changedName := c.COWIdentifierCI(n.Name)
	if changedName {
		out := *n
		out.Name = Name
		return &out, true
	}
	return n, false
}

// COWRefOfSavepoint creates a deep clone of the input.
func (c cow) COWRefOfSavepoint(n *Savepoint) (*Savepoint, bool) {
	if n == nil {
		return nil, false
	}
	Name, changedName := c.COWIdentifierCI(n.Name)
	if changedName {
		out := *n
		out.Name = Name
		return &out, true
	}
	return n, false
}

// COWRefOfSelect creates a deep clone of the input.
func (c cow) COWRefOfSelect(n *Select) (*Select, bool) {
	if n == nil {
		return nil, false
	}
	Cache, changedCache := c.COWRefOfBool(n.Cache)
	From, changedFrom := c.COWSliceOfTableExpr(n.From)
	Comments, changedComments := c.COWRefOfParsedComments(n.Comments)
	SelectExprs, changedSelectExprs := c.COWSelectExprs(n.SelectExprs)
	Where, changedWhere := c.COWRefOfWhere(n.Where)
	With, changedWith := c.COWRefOfWith(n.With)
	GroupBy, changedGroupBy := c.COWGroupBy(n.GroupBy)
	Having, changedHaving := c.COWRefOfWhere(n.Having)
	Windows, changedWindows := c.COWNamedWindows(n.Windows)
	OrderBy, changedOrderBy := c.COWOrderBy(n.OrderBy)
	Limit, changedLimit := c.COWRefOfLimit(n.Limit)
	Into, changedInto := c.COWRefOfSelectInto(n.Into)
	if changedCache || changedFrom || changedComments || changedSelectExprs || changedWhere || changedWith || changedGroupBy || changedHaving || changedWindows || changedOrderBy || changedLimit || changedInto {
		out := *n
		out.Cache = Cache
		out.From = From
		out.Comments = Comments
		out.SelectExprs = SelectExprs
		out.Where = Where
		out.With = With
		out.GroupBy = GroupBy
		out.Having = Having
		out.Windows = Windows
		out.OrderBy = OrderBy
		out.Limit = Limit
		out.Into = Into
		return &out, true
	}
	return n, false
}

// COWSelectExprs creates a deep clone of the input.
func COWSelectExprs(n SelectExprs) SelectExprs {
	if n == nil {
		return nil
	}
	res := make(SelectExprs, len(n))
	for i, x := range n {
		res[i] = c.COWSelectExpr(x)
	}
	return res
}

// COWRefOfSelectInto creates a deep clone of the input.
func (c cow) COWRefOfSelectInto(n *SelectInto) (*SelectInto, bool) {
	if n == nil {
		return nil, false
	}
	Charset, changedCharset := c.COWColumnCharset(n.Charset)
	if changedCharset {
		out := *n
		out.Charset = Charset
		return &out, true
	}
	return n, false
}

// COWRefOfSet creates a deep clone of the input.
func (c cow) COWRefOfSet(n *Set) (*Set, bool) {
	if n == nil {
		return nil, false
	}
	Comments, changedComments := c.COWRefOfParsedComments(n.Comments)
	Exprs, changedExprs := c.COWSetExprs(n.Exprs)
	if changedComments || changedExprs {
		out := *n
		out.Comments = Comments
		out.Exprs = Exprs
		return &out, true
	}
	return n, false
}

// COWRefOfSetExpr creates a deep clone of the input.
func (c cow) COWRefOfSetExpr(n *SetExpr) (*SetExpr, bool) {
	if n == nil {
		return nil, false
	}
	Var, changedVar := c.COWRefOfVariable(n.Var)
	Expr, changedExpr := c.COWExpr(n.Expr)
	if changedVar || changedExpr {
		out := *n
		out.Var = Var
		out.Expr = Expr
		return &out, true
	}
	return n, false
}

// COWSetExprs creates a deep clone of the input.
func COWSetExprs(n SetExprs) SetExprs {
	if n == nil {
		return nil
	}
	res := make(SetExprs, len(n))
	for i, x := range n {
		res[i] = c.COWRefOfSetExpr(x)
	}
	return res
}

// COWRefOfShow creates a deep clone of the input.
func (c cow) COWRefOfShow(n *Show) (*Show, bool) {
	if n == nil {
		return nil, false
	}
	Internal, changedInternal := c.COWShowInternal(n.Internal)
	if changedInternal {
		out := *n
		out.Internal = Internal
		return &out, true
	}
	return n, false
}

// COWRefOfShowBasic creates a deep clone of the input.
func (c cow) COWRefOfShowBasic(n *ShowBasic) (*ShowBasic, bool) {
	if n == nil {
		return nil, false
	}
	Tbl, changedTbl := c.COWTableName(n.Tbl)
	DbName, changedDbName := c.COWIdentifierCS(n.DbName)
	Filter, changedFilter := c.COWRefOfShowFilter(n.Filter)
	if changedTbl || changedDbName || changedFilter {
		out := *n
		out.Tbl = Tbl
		out.DbName = DbName
		out.Filter = Filter
		return &out, true
	}
	return n, false
}

// COWRefOfShowCreate creates a deep clone of the input.
func (c cow) COWRefOfShowCreate(n *ShowCreate) (*ShowCreate, bool) {
	if n == nil {
		return nil, false
	}
	Op, changedOp := c.COWTableName(n.Op)
	if changedOp {
		out := *n
		out.Op = Op
		return &out, true
	}
	return n, false
}

// COWRefOfShowFilter creates a deep clone of the input.
func (c cow) COWRefOfShowFilter(n *ShowFilter) (*ShowFilter, bool) {
	if n == nil {
		return nil, false
	}
	Filter, changedFilter := c.COWExpr(n.Filter)
	if changedFilter {
		out := *n
		out.Filter = Filter
		return &out, true
	}
	return n, false
}

// COWRefOfShowMigrationLogs creates a deep clone of the input.
func (c cow) COWRefOfShowMigrationLogs(n *ShowMigrationLogs) (*ShowMigrationLogs, bool) {
	if n == nil {
		return nil, false
	}
	Comments, changedComments := c.COWRefOfParsedComments(n.Comments)
	if changedComments {
		out := *n
		out.Comments = Comments
		return &out, true
	}
	return n, false
}

// COWRefOfShowOther creates a deep clone of the input.
func (c cow) COWRefOfShowOther(n *ShowOther) (*ShowOther, bool) {
	if n == nil {
		return nil, false
	}
	return n, false
}

// COWRefOfShowThrottledApps creates a deep clone of the input.
func (c cow) COWRefOfShowThrottledApps(n *ShowThrottledApps) (*ShowThrottledApps, bool) {
	if n == nil {
		return nil, false
	}
	Comments, changedComments := c.COWComments(n.Comments)
	if changedComments {
		out := *n
		out.Comments = Comments
		return &out, true
	}
	return n, false
}

// COWRefOfShowThrottlerStatus creates a deep clone of the input.
func (c cow) COWRefOfShowThrottlerStatus(n *ShowThrottlerStatus) (*ShowThrottlerStatus, bool) {
	if n == nil {
		return nil, false
	}
	Comments, changedComments := c.COWComments(n.Comments)
	if changedComments {
		out := *n
		out.Comments = Comments
		return &out, true
	}
	return n, false
}

// COWRefOfStarExpr creates a deep clone of the input.
func (c cow) COWRefOfStarExpr(n *StarExpr) (*StarExpr, bool) {
	if n == nil {
		return nil, false
	}
	TableName, changedTableName := c.COWTableName(n.TableName)
	if changedTableName {
		out := *n
		out.TableName = TableName
		return &out, true
	}
	return n, false
}

// COWRefOfStd creates a deep clone of the input.
func (c cow) COWRefOfStd(n *Std) (*Std, bool) {
	if n == nil {
		return nil, false
	}
	Arg, changedArg := c.COWExpr(n.Arg)
	if changedArg {
		out := *n
		out.Arg = Arg
		return &out, true
	}
	return n, false
}

// COWRefOfStdDev creates a deep clone of the input.
func (c cow) COWRefOfStdDev(n *StdDev) (*StdDev, bool) {
	if n == nil {
		return nil, false
	}
	Arg, changedArg := c.COWExpr(n.Arg)
	if changedArg {
		out := *n
		out.Arg = Arg
		return &out, true
	}
	return n, false
}

// COWRefOfStdPop creates a deep clone of the input.
func (c cow) COWRefOfStdPop(n *StdPop) (*StdPop, bool) {
	if n == nil {
		return nil, false
	}
	Arg, changedArg := c.COWExpr(n.Arg)
	if changedArg {
		out := *n
		out.Arg = Arg
		return &out, true
	}
	return n, false
}

// COWRefOfStdSamp creates a deep clone of the input.
func (c cow) COWRefOfStdSamp(n *StdSamp) (*StdSamp, bool) {
	if n == nil {
		return nil, false
	}
	Arg, changedArg := c.COWExpr(n.Arg)
	if changedArg {
		out := *n
		out.Arg = Arg
		return &out, true
	}
	return n, false
}

// COWRefOfStream creates a deep clone of the input.
func (c cow) COWRefOfStream(n *Stream) (*Stream, bool) {
	if n == nil {
		return nil, false
	}
	Comments, changedComments := c.COWRefOfParsedComments(n.Comments)
	SelectExpr, changedSelectExpr := c.COWSelectExpr(n.SelectExpr)
	Table, changedTable := c.COWTableName(n.Table)
	if changedComments || changedSelectExpr || changedTable {
		out := *n
		out.Comments = Comments
		out.SelectExpr = SelectExpr
		out.Table = Table
		return &out, true
	}
	return n, false
}

// COWRefOfSubPartition creates a deep clone of the input.
func (c cow) COWRefOfSubPartition(n *SubPartition) (*SubPartition, bool) {
	if n == nil {
		return nil, false
	}
	ColList, changedColList := c.COWColumns(n.ColList)
	Expr, changedExpr := c.COWExpr(n.Expr)
	if changedColList || changedExpr {
		out := *n
		out.ColList = ColList
		out.Expr = Expr
		return &out, true
	}
	return n, false
}

// COWRefOfSubPartitionDefinition creates a deep clone of the input.
func (c cow) COWRefOfSubPartitionDefinition(n *SubPartitionDefinition) (*SubPartitionDefinition, bool) {
	if n == nil {
		return nil, false
	}
	Name, changedName := c.COWIdentifierCI(n.Name)
	Options, changedOptions := c.COWRefOfSubPartitionDefinitionOptions(n.Options)
	if changedName || changedOptions {
		out := *n
		out.Name = Name
		out.Options = Options
		return &out, true
	}
	return n, false
}

// COWRefOfSubPartitionDefinitionOptions creates a deep clone of the input.
func (c cow) COWRefOfSubPartitionDefinitionOptions(n *SubPartitionDefinitionOptions) (*SubPartitionDefinitionOptions, bool) {
	if n == nil {
		return nil, false
	}
	Comment, changedComment := c.COWRefOfLiteral(n.Comment)
	Engine, changedEngine := c.COWRefOfPartitionEngine(n.Engine)
	DataDirectory, changedDataDirectory := c.COWRefOfLiteral(n.DataDirectory)
	IndexDirectory, changedIndexDirectory := c.COWRefOfLiteral(n.IndexDirectory)
	MaxRows, changedMaxRows := c.COWRefOfInt(n.MaxRows)
	MinRows, changedMinRows := c.COWRefOfInt(n.MinRows)
	if changedComment || changedEngine || changedDataDirectory || changedIndexDirectory || changedMaxRows || changedMinRows {
		out := *n
		out.Comment = Comment
		out.Engine = Engine
		out.DataDirectory = DataDirectory
		out.IndexDirectory = IndexDirectory
		out.MaxRows = MaxRows
		out.MinRows = MinRows
		return &out, true
	}
	return n, false
}

// COWSubPartitionDefinitions creates a deep clone of the input.
func COWSubPartitionDefinitions(n SubPartitionDefinitions) SubPartitionDefinitions {
	if n == nil {
		return nil
	}
	res := make(SubPartitionDefinitions, len(n))
	for i, x := range n {
		res[i] = c.COWRefOfSubPartitionDefinition(x)
	}
	return res
}

// COWRefOfSubquery creates a deep clone of the input.
func (c cow) COWRefOfSubquery(n *Subquery) (*Subquery, bool) {
	if n == nil {
		return nil, false
	}
	Select, changedSelect := c.COWSelectStatement(n.Select)
	if changedSelect {
		out := *n
		out.Select = Select
		return &out, true
	}
	return n, false
}

// COWRefOfSubstrExpr creates a deep clone of the input.
func (c cow) COWRefOfSubstrExpr(n *SubstrExpr) (*SubstrExpr, bool) {
	if n == nil {
		return nil, false
	}
	Name, changedName := c.COWExpr(n.Name)
	From, changedFrom := c.COWExpr(n.From)
	To, changedTo := c.COWExpr(n.To)
	if changedName || changedFrom || changedTo {
		out := *n
		out.Name = Name
		out.From = From
		out.To = To
		return &out, true
	}
	return n, false
}

// COWRefOfSum creates a deep clone of the input.
func (c cow) COWRefOfSum(n *Sum) (*Sum, bool) {
	if n == nil {
		return nil, false
	}
	Arg, changedArg := c.COWExpr(n.Arg)
	if changedArg {
		out := *n
		out.Arg = Arg
		return &out, true
	}
	return n, false
}

// COWTableExprs creates a deep clone of the input.
func COWTableExprs(n TableExprs) TableExprs {
	if n == nil {
		return nil
	}
	res := make(TableExprs, len(n))
	for i, x := range n {
		res[i] = c.COWTableExpr(x)
	}
	return res
}

// COWTableName creates a deep clone of the input.
func COWTableName(n TableName) TableName {
	return *c.COWRefOfTableName(&n)
}

// COWTableNames creates a deep clone of the input.
func COWTableNames(n TableNames) TableNames {
	if n == nil {
		return nil
	}
	res := make(TableNames, len(n))
	for i, x := range n {
		res[i] = c.COWTableName(x)
	}
	return res
}

// COWTableOptions creates a deep clone of the input.
func COWTableOptions(n TableOptions) TableOptions {
	if n == nil {
		return nil
	}
	res := make(TableOptions, len(n))
	for i, x := range n {
		res[i] = c.COWRefOfTableOption(x)
	}
	return res
}

// COWRefOfTableSpec creates a deep clone of the input.
func (c cow) COWRefOfTableSpec(n *TableSpec) (*TableSpec, bool) {
	if n == nil {
		return nil, false
	}
	Columns, changedColumns := c.COWSliceOfRefOfColumnDefinition(n.Columns)
	Indexes, changedIndexes := c.COWSliceOfRefOfIndexDefinition(n.Indexes)
	Constraints, changedConstraints := c.COWSliceOfRefOfConstraintDefinition(n.Constraints)
	Options, changedOptions := c.COWTableOptions(n.Options)
	PartitionOption, changedPartitionOption := c.COWRefOfPartitionOption(n.PartitionOption)
	if changedColumns || changedIndexes || changedConstraints || changedOptions || changedPartitionOption {
		out := *n
		out.Columns = Columns
		out.Indexes = Indexes
		out.Constraints = Constraints
		out.Options = Options
		out.PartitionOption = PartitionOption
		return &out, true
	}
	return n, false
}

// COWRefOfTablespaceOperation creates a deep clone of the input.
func (c cow) COWRefOfTablespaceOperation(n *TablespaceOperation) (*TablespaceOperation, bool) {
	if n == nil {
		return nil, false
	}
	return n, false
}

// COWRefOfTimestampFuncExpr creates a deep clone of the input.
func (c cow) COWRefOfTimestampFuncExpr(n *TimestampFuncExpr) (*TimestampFuncExpr, bool) {
	if n == nil {
		return nil, false
	}
	Expr1, changedExpr1 := c.COWExpr(n.Expr1)
	Expr2, changedExpr2 := c.COWExpr(n.Expr2)
	if changedExpr1 || changedExpr2 {
		out := *n
		out.Expr1 = Expr1
		out.Expr2 = Expr2
		return &out, true
	}
	return n, false
}

// COWRefOfTrimFuncExpr creates a deep clone of the input.
func (c cow) COWRefOfTrimFuncExpr(n *TrimFuncExpr) (*TrimFuncExpr, bool) {
	if n == nil {
		return nil, false
	}
	TrimArg, changedTrimArg := c.COWExpr(n.TrimArg)
	StringArg, changedStringArg := c.COWExpr(n.StringArg)
	if changedTrimArg || changedStringArg {
		out := *n
		out.TrimArg = TrimArg
		out.StringArg = StringArg
		return &out, true
	}
	return n, false
}

// COWRefOfTruncateTable creates a deep clone of the input.
func (c cow) COWRefOfTruncateTable(n *TruncateTable) (*TruncateTable, bool) {
	if n == nil {
		return nil, false
	}
	Table, changedTable := c.COWTableName(n.Table)
	if changedTable {
		out := *n
		out.Table = Table
		return &out, true
	}
	return n, false
}

// COWRefOfUnaryExpr creates a deep clone of the input.
func (c cow) COWRefOfUnaryExpr(n *UnaryExpr) (*UnaryExpr, bool) {
	if n == nil {
		return nil, false
	}
	Expr, changedExpr := c.COWExpr(n.Expr)
	if changedExpr {
		out := *n
		out.Expr = Expr
		return &out, true
	}
	return n, false
}

// COWRefOfUnion creates a deep clone of the input.
func (c cow) COWRefOfUnion(n *Union) (*Union, bool) {
	if n == nil {
		return nil, false
	}
	Left, changedLeft := c.COWSelectStatement(n.Left)
	Right, changedRight := c.COWSelectStatement(n.Right)
	OrderBy, changedOrderBy := c.COWOrderBy(n.OrderBy)
	With, changedWith := c.COWRefOfWith(n.With)
	Limit, changedLimit := c.COWRefOfLimit(n.Limit)
	Into, changedInto := c.COWRefOfSelectInto(n.Into)
	if changedLeft || changedRight || changedOrderBy || changedWith || changedLimit || changedInto {
		out := *n
		out.Left = Left
		out.Right = Right
		out.OrderBy = OrderBy
		out.With = With
		out.Limit = Limit
		out.Into = Into
		return &out, true
	}
	return n, false
}

// COWRefOfUnlockTables creates a deep clone of the input.
func (c cow) COWRefOfUnlockTables(n *UnlockTables) (*UnlockTables, bool) {
	if n == nil {
		return nil, false
	}
	return n, false
}

// COWRefOfUpdate creates a deep clone of the input.
func (c cow) COWRefOfUpdate(n *Update) (*Update, bool) {
	if n == nil {
		return nil, false
	}
	With, changedWith := c.COWRefOfWith(n.With)
	Comments, changedComments := c.COWRefOfParsedComments(n.Comments)
	TableExprs, changedTableExprs := c.COWTableExprs(n.TableExprs)
	Exprs, changedExprs := c.COWUpdateExprs(n.Exprs)
	Where, changedWhere := c.COWRefOfWhere(n.Where)
	OrderBy, changedOrderBy := c.COWOrderBy(n.OrderBy)
	Limit, changedLimit := c.COWRefOfLimit(n.Limit)
	if changedWith || changedComments || changedTableExprs || changedExprs || changedWhere || changedOrderBy || changedLimit {
		out := *n
		out.With = With
		out.Comments = Comments
		out.TableExprs = TableExprs
		out.Exprs = Exprs
		out.Where = Where
		out.OrderBy = OrderBy
		out.Limit = Limit
		return &out, true
	}
	return n, false
}

// COWRefOfUpdateExpr creates a deep clone of the input.
func (c cow) COWRefOfUpdateExpr(n *UpdateExpr) (*UpdateExpr, bool) {
	if n == nil {
		return nil, false
	}
	Name, changedName := c.COWRefOfColName(n.Name)
	Expr, changedExpr := c.COWExpr(n.Expr)
	if changedName || changedExpr {
		out := *n
		out.Name = Name
		out.Expr = Expr
		return &out, true
	}
	return n, false
}

// COWUpdateExprs creates a deep clone of the input.
func COWUpdateExprs(n UpdateExprs) UpdateExprs {
	if n == nil {
		return nil
	}
	res := make(UpdateExprs, len(n))
	for i, x := range n {
		res[i] = c.COWRefOfUpdateExpr(x)
	}
	return res
}

// COWRefOfUpdateXMLExpr creates a deep clone of the input.
func (c cow) COWRefOfUpdateXMLExpr(n *UpdateXMLExpr) (*UpdateXMLExpr, bool) {
	if n == nil {
		return nil, false
	}
	Target, changedTarget := c.COWExpr(n.Target)
	XPathExpr, changedXPathExpr := c.COWExpr(n.XPathExpr)
	NewXML, changedNewXML := c.COWExpr(n.NewXML)
	if changedTarget || changedXPathExpr || changedNewXML {
		out := *n
		out.Target = Target
		out.XPathExpr = XPathExpr
		out.NewXML = NewXML
		return &out, true
	}
	return n, false
}

// COWRefOfUse creates a deep clone of the input.
func (c cow) COWRefOfUse(n *Use) (*Use, bool) {
	if n == nil {
		return nil, false
	}
	DBName, changedDBName := c.COWIdentifierCS(n.DBName)
	if changedDBName {
		out := *n
		out.DBName = DBName
		return &out, true
	}
	return n, false
}

// COWRefOfVExplainStmt creates a deep clone of the input.
func (c cow) COWRefOfVExplainStmt(n *VExplainStmt) (*VExplainStmt, bool) {
	if n == nil {
		return nil, false
	}
	Statement, changedStatement := c.COWStatement(n.Statement)
	Comments, changedComments := c.COWRefOfParsedComments(n.Comments)
	if changedStatement || changedComments {
		out := *n
		out.Statement = Statement
		out.Comments = Comments
		return &out, true
	}
	return n, false
}

// COWRefOfVStream creates a deep clone of the input.
func (c cow) COWRefOfVStream(n *VStream) (*VStream, bool) {
	if n == nil {
		return nil, false
	}
	Comments, changedComments := c.COWRefOfParsedComments(n.Comments)
	SelectExpr, changedSelectExpr := c.COWSelectExpr(n.SelectExpr)
	Table, changedTable := c.COWTableName(n.Table)
	Where, changedWhere := c.COWRefOfWhere(n.Where)
	Limit, changedLimit := c.COWRefOfLimit(n.Limit)
	if changedComments || changedSelectExpr || changedTable || changedWhere || changedLimit {
		out := *n
		out.Comments = Comments
		out.SelectExpr = SelectExpr
		out.Table = Table
		out.Where = Where
		out.Limit = Limit
		return &out, true
	}
	return n, false
}

// COWValTuple creates a deep clone of the input.
func COWValTuple(n ValTuple) ValTuple {
	if n == nil {
		return nil
	}
	res := make(ValTuple, len(n))
	for i, x := range n {
		res[i] = c.COWExpr(x)
	}
	return res
}

// COWRefOfValidation creates a deep clone of the input.
func (c cow) COWRefOfValidation(n *Validation) (*Validation, bool) {
	if n == nil {
		return nil, false
	}
	return n, false
}

// COWValues creates a deep clone of the input.
func COWValues(n Values) Values {
	if n == nil {
		return nil
	}
	res := make(Values, len(n))
	for i, x := range n {
		res[i] = c.COWValTuple(x)
	}
	return res
}

// COWRefOfValuesFuncExpr creates a deep clone of the input.
func (c cow) COWRefOfValuesFuncExpr(n *ValuesFuncExpr) (*ValuesFuncExpr, bool) {
	if n == nil {
		return nil, false
	}
	Name, changedName := c.COWRefOfColName(n.Name)
	if changedName {
		out := *n
		out.Name = Name
		return &out, true
	}
	return n, false
}

// COWRefOfVarPop creates a deep clone of the input.
func (c cow) COWRefOfVarPop(n *VarPop) (*VarPop, bool) {
	if n == nil {
		return nil, false
	}
	Arg, changedArg := c.COWExpr(n.Arg)
	if changedArg {
		out := *n
		out.Arg = Arg
		return &out, true
	}
	return n, false
}

// COWRefOfVarSamp creates a deep clone of the input.
func (c cow) COWRefOfVarSamp(n *VarSamp) (*VarSamp, bool) {
	if n == nil {
		return nil, false
	}
	Arg, changedArg := c.COWExpr(n.Arg)
	if changedArg {
		out := *n
		out.Arg = Arg
		return &out, true
	}
	return n, false
}

// COWRefOfVariable creates a deep clone of the input.
func (c cow) COWRefOfVariable(n *Variable) (*Variable, bool) {
	if n == nil {
		return nil, false
	}
	Name, changedName := c.COWIdentifierCI(n.Name)
	if changedName {
		out := *n
		out.Name = Name
		return &out, true
	}
	return n, false
}

// COWRefOfVariance creates a deep clone of the input.
func (c cow) COWRefOfVariance(n *Variance) (*Variance, bool) {
	if n == nil {
		return nil, false
	}
	Arg, changedArg := c.COWExpr(n.Arg)
	if changedArg {
		out := *n
		out.Arg = Arg
		return &out, true
	}
	return n, false
}

// COWVindexParam creates a deep clone of the input.
func COWVindexParam(n VindexParam) VindexParam {
	return *c.COWRefOfVindexParam(&n)
}

// COWRefOfVindexSpec creates a deep clone of the input.
func (c cow) COWRefOfVindexSpec(n *VindexSpec) (*VindexSpec, bool) {
	if n == nil {
		return nil, false
	}
	Name, changedName := c.COWIdentifierCI(n.Name)
	Type, changedType := c.COWIdentifierCI(n.Type)
	Params, changedParams := c.COWSliceOfVindexParam(n.Params)
	if changedName || changedType || changedParams {
		out := *n
		out.Name = Name
		out.Type = Type
		out.Params = Params
		return &out, true
	}
	return n, false
}

// COWRefOfWeightStringFuncExpr creates a deep clone of the input.
func (c cow) COWRefOfWeightStringFuncExpr(n *WeightStringFuncExpr) (*WeightStringFuncExpr, bool) {
	if n == nil {
		return nil, false
	}
	Expr, changedExpr := c.COWExpr(n.Expr)
	As, changedAs := c.COWRefOfConvertType(n.As)
	if changedExpr || changedAs {
		out := *n
		out.Expr = Expr
		out.As = As
		return &out, true
	}
	return n, false
}

// COWRefOfWhen creates a deep clone of the input.
func (c cow) COWRefOfWhen(n *When) (*When, bool) {
	if n == nil {
		return nil, false
	}
	Cond, changedCond := c.COWExpr(n.Cond)
	Val, changedVal := c.COWExpr(n.Val)
	if changedCond || changedVal {
		out := *n
		out.Cond = Cond
		out.Val = Val
		return &out, true
	}
	return n, false
}

// COWRefOfWhere creates a deep clone of the input.
func (c cow) COWRefOfWhere(n *Where) (*Where, bool) {
	if n == nil {
		return nil, false
	}
	Expr, changedExpr := c.COWExpr(n.Expr)
	if changedExpr {
		out := *n
		out.Expr = Expr
		return &out, true
	}
	return n, false
}

// COWRefOfWindowDefinition creates a deep clone of the input.
func (c cow) COWRefOfWindowDefinition(n *WindowDefinition) (*WindowDefinition, bool) {
	if n == nil {
		return nil, false
	}
	Name, changedName := c.COWIdentifierCI(n.Name)
	WindowSpec, changedWindowSpec := c.COWRefOfWindowSpecification(n.WindowSpec)
	if changedName || changedWindowSpec {
		out := *n
		out.Name = Name
		out.WindowSpec = WindowSpec
		return &out, true
	}
	return n, false
}

// COWWindowDefinitions creates a deep clone of the input.
func COWWindowDefinitions(n WindowDefinitions) WindowDefinitions {
	if n == nil {
		return nil
	}
	res := make(WindowDefinitions, len(n))
	for i, x := range n {
		res[i] = c.COWRefOfWindowDefinition(x)
	}
	return res
}

// COWRefOfWindowSpecification creates a deep clone of the input.
func (c cow) COWRefOfWindowSpecification(n *WindowSpecification) (*WindowSpecification, bool) {
	if n == nil {
		return nil, false
	}
	Name, changedName := c.COWIdentifierCI(n.Name)
	PartitionClause, changedPartitionClause := c.COWExprs(n.PartitionClause)
	OrderClause, changedOrderClause := c.COWOrderBy(n.OrderClause)
	FrameClause, changedFrameClause := c.COWRefOfFrameClause(n.FrameClause)
	if changedName || changedPartitionClause || changedOrderClause || changedFrameClause {
		out := *n
		out.Name = Name
		out.PartitionClause = PartitionClause
		out.OrderClause = OrderClause
		out.FrameClause = FrameClause
		return &out, true
	}
	return n, false
}

// COWRefOfWith creates a deep clone of the input.
func (c cow) COWRefOfWith(n *With) (*With, bool) {
	if n == nil {
		return nil, false
	}
	ctes, changedctes := c.COWSliceOfRefOfCommonTableExpr(n.ctes)
	if changedctes {
		out := *n
		out.ctes = ctes
		return &out, true
	}
	return n, false
}

// COWRefOfXorExpr creates a deep clone of the input.
func (c cow) COWRefOfXorExpr(n *XorExpr) (*XorExpr, bool) {
	if n == nil {
		return nil, false
	}
	Left, changedLeft := c.COWExpr(n.Left)
	Right, changedRight := c.COWExpr(n.Right)
	if changedLeft || changedRight {
		out := *n
		out.Left = Left
		out.Right = Right
		return &out, true
	}
	return n, false
}

// COWAggrFunc creates a deep clone of the input.
func (c cow) COWAggrFunc(in AggrFunc) (AggrFunc, bool) {
	if in == nil {
		return nil, false
	}
	if c.old == in {
		return c.new, true
	}
	switch in := in.(type) {
	case *Avg:
		return c.COWRefOfAvg(in)
	case *BitAnd:
		return c.COWRefOfBitAnd(in)
	case *BitOr:
		return c.COWRefOfBitOr(in)
	case *BitXor:
		return c.COWRefOfBitXor(in)
	case *Count:
		return c.COWRefOfCount(in)
	case *CountStar:
		return c.COWRefOfCountStar(in)
	case *GroupConcatExpr:
		return c.COWRefOfGroupConcatExpr(in)
	case *Max:
		return c.COWRefOfMax(in)
	case *Min:
		return c.COWRefOfMin(in)
	case *Std:
		return c.COWRefOfStd(in)
	case *StdDev:
		return c.COWRefOfStdDev(in)
	case *StdPop:
		return c.COWRefOfStdPop(in)
	case *StdSamp:
		return c.COWRefOfStdSamp(in)
	case *Sum:
		return c.COWRefOfSum(in)
	case *VarPop:
		return c.COWRefOfVarPop(in)
	case *VarSamp:
		return c.COWRefOfVarSamp(in)
	case *Variance:
		return c.COWRefOfVariance(in)
	default:
		// this should never happen
		return nil
	}
}

// COWAlterOption creates a deep clone of the input.
func (c cow) COWAlterOption(in AlterOption) (AlterOption, bool) {
	if in == nil {
		return nil, false
	}
	if c.old == in {
		return c.new, true
	}
	switch in := in.(type) {
	case *AddColumns:
		return c.COWRefOfAddColumns(in)
	case *AddConstraintDefinition:
		return c.COWRefOfAddConstraintDefinition(in)
	case *AddIndexDefinition:
		return c.COWRefOfAddIndexDefinition(in)
	case AlgorithmValue:
		return in
	case *AlterCharset:
		return c.COWRefOfAlterCharset(in)
	case *AlterCheck:
		return c.COWRefOfAlterCheck(in)
	case *AlterColumn:
		return c.COWRefOfAlterColumn(in)
	case *AlterIndex:
		return c.COWRefOfAlterIndex(in)
	case *ChangeColumn:
		return c.COWRefOfChangeColumn(in)
	case *DropColumn:
		return c.COWRefOfDropColumn(in)
	case *DropKey:
		return c.COWRefOfDropKey(in)
	case *Force:
		return c.COWRefOfForce(in)
	case *KeyState:
		return c.COWRefOfKeyState(in)
	case *LockOption:
		return c.COWRefOfLockOption(in)
	case *ModifyColumn:
		return c.COWRefOfModifyColumn(in)
	case *OrderByOption:
		return c.COWRefOfOrderByOption(in)
	case *RenameColumn:
		return c.COWRefOfRenameColumn(in)
	case *RenameIndex:
		return c.COWRefOfRenameIndex(in)
	case *RenameTableName:
		return c.COWRefOfRenameTableName(in)
	case TableOptions:
		return c.COWTableOptions(in)
	case *TablespaceOperation:
		return c.COWRefOfTablespaceOperation(in)
	case *Validation:
		return c.COWRefOfValidation(in)
	default:
		// this should never happen
		return nil
	}
}

// COWCallable creates a deep clone of the input.
func (c cow) COWCallable(in Callable) (Callable, bool) {
	if in == nil {
		return nil, false
	}
	if c.old == in {
		return c.new, true
	}
	switch in := in.(type) {
	case *ArgumentLessWindowExpr:
		return c.COWRefOfArgumentLessWindowExpr(in)
	case *Avg:
		return c.COWRefOfAvg(in)
	case *CharExpr:
		return c.COWRefOfCharExpr(in)
	case *ConvertExpr:
		return c.COWRefOfConvertExpr(in)
	case *ConvertUsingExpr:
		return c.COWRefOfConvertUsingExpr(in)
	case *Count:
		return c.COWRefOfCount(in)
	case *CountStar:
		return c.COWRefOfCountStar(in)
	case *CurTimeFuncExpr:
		return c.COWRefOfCurTimeFuncExpr(in)
	case *ExtractFuncExpr:
		return c.COWRefOfExtractFuncExpr(in)
	case *ExtractValueExpr:
		return c.COWRefOfExtractValueExpr(in)
	case *FirstOrLastValueExpr:
		return c.COWRefOfFirstOrLastValueExpr(in)
	case *FuncExpr:
		return c.COWRefOfFuncExpr(in)
	case *GTIDFuncExpr:
		return c.COWRefOfGTIDFuncExpr(in)
	case *GroupConcatExpr:
		return c.COWRefOfGroupConcatExpr(in)
	case *InsertExpr:
		return c.COWRefOfInsertExpr(in)
	case *IntervalFuncExpr:
		return c.COWRefOfIntervalFuncExpr(in)
	case *JSONArrayExpr:
		return c.COWRefOfJSONArrayExpr(in)
	case *JSONAttributesExpr:
		return c.COWRefOfJSONAttributesExpr(in)
	case *JSONContainsExpr:
		return c.COWRefOfJSONContainsExpr(in)
	case *JSONContainsPathExpr:
		return c.COWRefOfJSONContainsPathExpr(in)
	case *JSONExtractExpr:
		return c.COWRefOfJSONExtractExpr(in)
	case *JSONKeysExpr:
		return c.COWRefOfJSONKeysExpr(in)
	case *JSONObjectExpr:
		return c.COWRefOfJSONObjectExpr(in)
	case *JSONOverlapsExpr:
		return c.COWRefOfJSONOverlapsExpr(in)
	case *JSONPrettyExpr:
		return c.COWRefOfJSONPrettyExpr(in)
	case *JSONQuoteExpr:
		return c.COWRefOfJSONQuoteExpr(in)
	case *JSONRemoveExpr:
		return c.COWRefOfJSONRemoveExpr(in)
	case *JSONSchemaValidFuncExpr:
		return c.COWRefOfJSONSchemaValidFuncExpr(in)
	case *JSONSchemaValidationReportFuncExpr:
		return c.COWRefOfJSONSchemaValidationReportFuncExpr(in)
	case *JSONSearchExpr:
		return c.COWRefOfJSONSearchExpr(in)
	case *JSONStorageFreeExpr:
		return c.COWRefOfJSONStorageFreeExpr(in)
	case *JSONStorageSizeExpr:
		return c.COWRefOfJSONStorageSizeExpr(in)
	case *JSONUnquoteExpr:
		return c.COWRefOfJSONUnquoteExpr(in)
	case *JSONValueExpr:
		return c.COWRefOfJSONValueExpr(in)
	case *JSONValueMergeExpr:
		return c.COWRefOfJSONValueMergeExpr(in)
	case *JSONValueModifierExpr:
		return c.COWRefOfJSONValueModifierExpr(in)
	case *LagLeadExpr:
		return c.COWRefOfLagLeadExpr(in)
	case *LocateExpr:
		return c.COWRefOfLocateExpr(in)
	case *MatchExpr:
		return c.COWRefOfMatchExpr(in)
	case *Max:
		return c.COWRefOfMax(in)
	case *MemberOfExpr:
		return c.COWRefOfMemberOfExpr(in)
	case *Min:
		return c.COWRefOfMin(in)
	case *NTHValueExpr:
		return c.COWRefOfNTHValueExpr(in)
	case *NamedWindow:
		return c.COWRefOfNamedWindow(in)
	case *NtileExpr:
		return c.COWRefOfNtileExpr(in)
	case *PerformanceSchemaFuncExpr:
		return c.COWRefOfPerformanceSchemaFuncExpr(in)
	case *RegexpInstrExpr:
		return c.COWRefOfRegexpInstrExpr(in)
	case *RegexpLikeExpr:
		return c.COWRefOfRegexpLikeExpr(in)
	case *RegexpReplaceExpr:
		return c.COWRefOfRegexpReplaceExpr(in)
	case *RegexpSubstrExpr:
		return c.COWRefOfRegexpSubstrExpr(in)
	case *SubstrExpr:
		return c.COWRefOfSubstrExpr(in)
	case *Sum:
		return c.COWRefOfSum(in)
	case *TimestampFuncExpr:
		return c.COWRefOfTimestampFuncExpr(in)
	case *TrimFuncExpr:
		return c.COWRefOfTrimFuncExpr(in)
	case *UpdateXMLExpr:
		return c.COWRefOfUpdateXMLExpr(in)
	case *ValuesFuncExpr:
		return c.COWRefOfValuesFuncExpr(in)
	case *WeightStringFuncExpr:
		return c.COWRefOfWeightStringFuncExpr(in)
	default:
		// this should never happen
		return nil
	}
}

// COWColTuple creates a deep clone of the input.
func (c cow) COWColTuple(in ColTuple) (ColTuple, bool) {
	if in == nil {
		return nil, false
	}
	if c.old == in {
		return c.new, true
	}
	switch in := in.(type) {
	case ListArg:
		return in
	case *Subquery:
		return c.COWRefOfSubquery(in)
	case ValTuple:
		return c.COWValTuple(in)
	default:
		// this should never happen
		return nil
	}
}

// COWConstraintInfo creates a deep clone of the input.
func (c cow) COWConstraintInfo(in ConstraintInfo) (ConstraintInfo, bool) {
	if in == nil {
		return nil, false
	}
	if c.old == in {
		return c.new, true
	}
	switch in := in.(type) {
	case *CheckConstraintDefinition:
		return c.COWRefOfCheckConstraintDefinition(in)
	case *ForeignKeyDefinition:
		return c.COWRefOfForeignKeyDefinition(in)
	default:
		// this should never happen
		return nil
	}
}

// COWDBDDLStatement creates a deep clone of the input.
func (c cow) COWDBDDLStatement(in DBDDLStatement) (DBDDLStatement, bool) {
	if in == nil {
		return nil, false
	}
	if c.old == in {
		return c.new, true
	}
	switch in := in.(type) {
	case *AlterDatabase:
		return c.COWRefOfAlterDatabase(in)
	case *CreateDatabase:
		return c.COWRefOfCreateDatabase(in)
	case *DropDatabase:
		return c.COWRefOfDropDatabase(in)
	default:
		// this should never happen
		return nil
	}
}

// COWDDLStatement creates a deep clone of the input.
func (c cow) COWDDLStatement(in DDLStatement) (DDLStatement, bool) {
	if in == nil {
		return nil, false
	}
	if c.old == in {
		return c.new, true
	}
	switch in := in.(type) {
	case *AlterTable:
		return c.COWRefOfAlterTable(in)
	case *AlterView:
		return c.COWRefOfAlterView(in)
	case *CreateTable:
		return c.COWRefOfCreateTable(in)
	case *CreateView:
		return c.COWRefOfCreateView(in)
	case *DropTable:
		return c.COWRefOfDropTable(in)
	case *DropView:
		return c.COWRefOfDropView(in)
	case *RenameTable:
		return c.COWRefOfRenameTable(in)
	case *TruncateTable:
		return c.COWRefOfTruncateTable(in)
	default:
		// this should never happen
		return nil
	}
}

// COWExplain creates a deep clone of the input.
func (c cow) COWExplain(in Explain) (Explain, bool) {
	if in == nil {
		return nil, false
	}
	if c.old == in {
		return c.new, true
	}
	switch in := in.(type) {
	case *ExplainStmt:
		return c.COWRefOfExplainStmt(in)
	case *ExplainTab:
		return c.COWRefOfExplainTab(in)
	default:
		// this should never happen
		return nil
	}
}

// COWExpr creates a deep clone of the input.
func (c cow) COWExpr(in Expr) (Expr, bool) {
	if in == nil {
		return nil, false
	}
	if c.old == in {
		return c.new, true
	}
	switch in := in.(type) {
	case *AndExpr:
		return c.COWRefOfAndExpr(in)
	case Argument:
		return in
	case *ArgumentLessWindowExpr:
		return c.COWRefOfArgumentLessWindowExpr(in)
	case *Avg:
		return c.COWRefOfAvg(in)
	case *BetweenExpr:
		return c.COWRefOfBetweenExpr(in)
	case *BinaryExpr:
		return c.COWRefOfBinaryExpr(in)
	case *BitAnd:
		return c.COWRefOfBitAnd(in)
	case *BitOr:
		return c.COWRefOfBitOr(in)
	case *BitXor:
		return c.COWRefOfBitXor(in)
	case BoolVal:
		return in
	case *CaseExpr:
		return c.COWRefOfCaseExpr(in)
	case *CastExpr:
		return c.COWRefOfCastExpr(in)
	case *CharExpr:
		return c.COWRefOfCharExpr(in)
	case *ColName:
		return c.COWRefOfColName(in)
	case *CollateExpr:
		return c.COWRefOfCollateExpr(in)
	case *ComparisonExpr:
		return c.COWRefOfComparisonExpr(in)
	case *ConvertExpr:
		return c.COWRefOfConvertExpr(in)
	case *ConvertUsingExpr:
		return c.COWRefOfConvertUsingExpr(in)
	case *Count:
		return c.COWRefOfCount(in)
	case *CountStar:
		return c.COWRefOfCountStar(in)
	case *CurTimeFuncExpr:
		return c.COWRefOfCurTimeFuncExpr(in)
	case *Default:
		return c.COWRefOfDefault(in)
	case *ExistsExpr:
		return c.COWRefOfExistsExpr(in)
	case *ExtractFuncExpr:
		return c.COWRefOfExtractFuncExpr(in)
	case *ExtractValueExpr:
		return c.COWRefOfExtractValueExpr(in)
	case *ExtractedSubquery:
		return c.COWRefOfExtractedSubquery(in)
	case *FirstOrLastValueExpr:
		return c.COWRefOfFirstOrLastValueExpr(in)
	case *FuncExpr:
		return c.COWRefOfFuncExpr(in)
	case *GTIDFuncExpr:
		return c.COWRefOfGTIDFuncExpr(in)
	case *GroupConcatExpr:
		return c.COWRefOfGroupConcatExpr(in)
	case *InsertExpr:
		return c.COWRefOfInsertExpr(in)
	case *IntervalExpr:
		return c.COWRefOfIntervalExpr(in)
	case *IntervalFuncExpr:
		return c.COWRefOfIntervalFuncExpr(in)
	case *IntroducerExpr:
		return c.COWRefOfIntroducerExpr(in)
	case *IsExpr:
		return c.COWRefOfIsExpr(in)
	case *JSONArrayExpr:
		return c.COWRefOfJSONArrayExpr(in)
	case *JSONAttributesExpr:
		return c.COWRefOfJSONAttributesExpr(in)
	case *JSONContainsExpr:
		return c.COWRefOfJSONContainsExpr(in)
	case *JSONContainsPathExpr:
		return c.COWRefOfJSONContainsPathExpr(in)
	case *JSONExtractExpr:
		return c.COWRefOfJSONExtractExpr(in)
	case *JSONKeysExpr:
		return c.COWRefOfJSONKeysExpr(in)
	case *JSONObjectExpr:
		return c.COWRefOfJSONObjectExpr(in)
	case *JSONOverlapsExpr:
		return c.COWRefOfJSONOverlapsExpr(in)
	case *JSONPrettyExpr:
		return c.COWRefOfJSONPrettyExpr(in)
	case *JSONQuoteExpr:
		return c.COWRefOfJSONQuoteExpr(in)
	case *JSONRemoveExpr:
		return c.COWRefOfJSONRemoveExpr(in)
	case *JSONSchemaValidFuncExpr:
		return c.COWRefOfJSONSchemaValidFuncExpr(in)
	case *JSONSchemaValidationReportFuncExpr:
		return c.COWRefOfJSONSchemaValidationReportFuncExpr(in)
	case *JSONSearchExpr:
		return c.COWRefOfJSONSearchExpr(in)
	case *JSONStorageFreeExpr:
		return c.COWRefOfJSONStorageFreeExpr(in)
	case *JSONStorageSizeExpr:
		return c.COWRefOfJSONStorageSizeExpr(in)
	case *JSONUnquoteExpr:
		return c.COWRefOfJSONUnquoteExpr(in)
	case *JSONValueExpr:
		return c.COWRefOfJSONValueExpr(in)
	case *JSONValueMergeExpr:
		return c.COWRefOfJSONValueMergeExpr(in)
	case *JSONValueModifierExpr:
		return c.COWRefOfJSONValueModifierExpr(in)
	case *LagLeadExpr:
		return c.COWRefOfLagLeadExpr(in)
	case ListArg:
		return in
	case *Literal:
		return c.COWRefOfLiteral(in)
	case *LocateExpr:
		return c.COWRefOfLocateExpr(in)
	case *LockingFunc:
		return c.COWRefOfLockingFunc(in)
	case *MatchExpr:
		return c.COWRefOfMatchExpr(in)
	case *Max:
		return c.COWRefOfMax(in)
	case *MemberOfExpr:
		return c.COWRefOfMemberOfExpr(in)
	case *Min:
		return c.COWRefOfMin(in)
	case *NTHValueExpr:
		return c.COWRefOfNTHValueExpr(in)
	case *NamedWindow:
		return c.COWRefOfNamedWindow(in)
	case *NotExpr:
		return c.COWRefOfNotExpr(in)
	case *NtileExpr:
		return c.COWRefOfNtileExpr(in)
	case *NullVal:
		return c.COWRefOfNullVal(in)
	case *Offset:
		return c.COWRefOfOffset(in)
	case *OrExpr:
		return c.COWRefOfOrExpr(in)
	case *PerformanceSchemaFuncExpr:
		return c.COWRefOfPerformanceSchemaFuncExpr(in)
	case *RegexpInstrExpr:
		return c.COWRefOfRegexpInstrExpr(in)
	case *RegexpLikeExpr:
		return c.COWRefOfRegexpLikeExpr(in)
	case *RegexpReplaceExpr:
		return c.COWRefOfRegexpReplaceExpr(in)
	case *RegexpSubstrExpr:
		return c.COWRefOfRegexpSubstrExpr(in)
	case *Std:
		return c.COWRefOfStd(in)
	case *StdDev:
		return c.COWRefOfStdDev(in)
	case *StdPop:
		return c.COWRefOfStdPop(in)
	case *StdSamp:
		return c.COWRefOfStdSamp(in)
	case *Subquery:
		return c.COWRefOfSubquery(in)
	case *SubstrExpr:
		return c.COWRefOfSubstrExpr(in)
	case *Sum:
		return c.COWRefOfSum(in)
	case *TimestampFuncExpr:
		return c.COWRefOfTimestampFuncExpr(in)
	case *TrimFuncExpr:
		return c.COWRefOfTrimFuncExpr(in)
	case *UnaryExpr:
		return c.COWRefOfUnaryExpr(in)
	case *UpdateXMLExpr:
		return c.COWRefOfUpdateXMLExpr(in)
	case ValTuple:
		return c.COWValTuple(in)
	case *ValuesFuncExpr:
		return c.COWRefOfValuesFuncExpr(in)
	case *VarPop:
		return c.COWRefOfVarPop(in)
	case *VarSamp:
		return c.COWRefOfVarSamp(in)
	case *Variable:
		return c.COWRefOfVariable(in)
	case *Variance:
		return c.COWRefOfVariance(in)
	case *WeightStringFuncExpr:
		return c.COWRefOfWeightStringFuncExpr(in)
	case *XorExpr:
		return c.COWRefOfXorExpr(in)
	default:
		// this should never happen
		return nil
	}
}

// COWInsertRows creates a deep clone of the input.
func (c cow) COWInsertRows(in InsertRows) (InsertRows, bool) {
	if in == nil {
		return nil, false
	}
	if c.old == in {
		return c.new, true
	}
	switch in := in.(type) {
	case *Select:
		return c.COWRefOfSelect(in)
	case *Union:
		return c.COWRefOfUnion(in)
	case Values:
		return c.COWValues(in)
	default:
		// this should never happen
		return nil
	}
}

// COWSelectExpr creates a deep clone of the input.
func (c cow) COWSelectExpr(in SelectExpr) (SelectExpr, bool) {
	if in == nil {
		return nil, false
	}
	if c.old == in {
		return c.new, true
	}
	switch in := in.(type) {
	case *AliasedExpr:
		return c.COWRefOfAliasedExpr(in)
	case *Nextval:
		return c.COWRefOfNextval(in)
	case *StarExpr:
		return c.COWRefOfStarExpr(in)
	default:
		// this should never happen
		return nil
	}
}

// COWSelectStatement creates a deep clone of the input.
func (c cow) COWSelectStatement(in SelectStatement) (SelectStatement, bool) {
	if in == nil {
		return nil, false
	}
	if c.old == in {
		return c.new, true
	}
	switch in := in.(type) {
	case *Select:
		return c.COWRefOfSelect(in)
	case *Union:
		return c.COWRefOfUnion(in)
	default:
		// this should never happen
		return nil
	}
}

// COWShowInternal creates a deep clone of the input.
func (c cow) COWShowInternal(in ShowInternal) (ShowInternal, bool) {
	if in == nil {
		return nil, false
	}
	if c.old == in {
		return c.new, true
	}
	switch in := in.(type) {
	case *ShowBasic:
		return c.COWRefOfShowBasic(in)
	case *ShowCreate:
		return c.COWRefOfShowCreate(in)
	case *ShowOther:
		return c.COWRefOfShowOther(in)
	default:
		// this should never happen
		return nil
	}
}

// COWSimpleTableExpr creates a deep clone of the input.
func (c cow) COWSimpleTableExpr(in SimpleTableExpr) (SimpleTableExpr, bool) {
	if in == nil {
		return nil, false
	}
	if c.old == in {
		return c.new, true
	}
	switch in := in.(type) {
	case *DerivedTable:
		return c.COWRefOfDerivedTable(in)
	case TableName:
		return c.COWTableName(in)
	default:
		// this should never happen
		return nil
	}
}

// COWStatement creates a deep clone of the input.
func (c cow) COWStatement(in Statement) (Statement, bool) {
	if in == nil {
		return nil, false
	}
	if c.old == in {
		return c.new, true
	}
	switch in := in.(type) {
	case *AlterDatabase:
		return c.COWRefOfAlterDatabase(in)
	case *AlterMigration:
		return c.COWRefOfAlterMigration(in)
	case *AlterTable:
		return c.COWRefOfAlterTable(in)
	case *AlterView:
		return c.COWRefOfAlterView(in)
	case *AlterVschema:
		return c.COWRefOfAlterVschema(in)
	case *Begin:
		return c.COWRefOfBegin(in)
	case *CallProc:
		return c.COWRefOfCallProc(in)
	case *CommentOnly:
		return c.COWRefOfCommentOnly(in)
	case *Commit:
		return c.COWRefOfCommit(in)
	case *CreateDatabase:
		return c.COWRefOfCreateDatabase(in)
	case *CreateTable:
		return c.COWRefOfCreateTable(in)
	case *CreateView:
		return c.COWRefOfCreateView(in)
	case *DeallocateStmt:
		return c.COWRefOfDeallocateStmt(in)
	case *Delete:
		return c.COWRefOfDelete(in)
	case *DropDatabase:
		return c.COWRefOfDropDatabase(in)
	case *DropTable:
		return c.COWRefOfDropTable(in)
	case *DropView:
		return c.COWRefOfDropView(in)
	case *ExecuteStmt:
		return c.COWRefOfExecuteStmt(in)
	case *ExplainStmt:
		return c.COWRefOfExplainStmt(in)
	case *ExplainTab:
		return c.COWRefOfExplainTab(in)
	case *Flush:
		return c.COWRefOfFlush(in)
	case *Insert:
		return c.COWRefOfInsert(in)
	case *Load:
		return c.COWRefOfLoad(in)
	case *LockTables:
		return c.COWRefOfLockTables(in)
	case *OtherAdmin:
		return c.COWRefOfOtherAdmin(in)
	case *OtherRead:
		return c.COWRefOfOtherRead(in)
	case *PrepareStmt:
		return c.COWRefOfPrepareStmt(in)
	case *Release:
		return c.COWRefOfRelease(in)
	case *RenameTable:
		return c.COWRefOfRenameTable(in)
	case *RevertMigration:
		return c.COWRefOfRevertMigration(in)
	case *Rollback:
		return c.COWRefOfRollback(in)
	case *SRollback:
		return c.COWRefOfSRollback(in)
	case *Savepoint:
		return c.COWRefOfSavepoint(in)
	case *Select:
		return c.COWRefOfSelect(in)
	case *Set:
		return c.COWRefOfSet(in)
	case *Show:
		return c.COWRefOfShow(in)
	case *ShowMigrationLogs:
		return c.COWRefOfShowMigrationLogs(in)
	case *ShowThrottledApps:
		return c.COWRefOfShowThrottledApps(in)
	case *ShowThrottlerStatus:
		return c.COWRefOfShowThrottlerStatus(in)
	case *Stream:
		return c.COWRefOfStream(in)
	case *TruncateTable:
		return c.COWRefOfTruncateTable(in)
	case *Union:
		return c.COWRefOfUnion(in)
	case *UnlockTables:
		return c.COWRefOfUnlockTables(in)
	case *Update:
		return c.COWRefOfUpdate(in)
	case *Use:
		return c.COWRefOfUse(in)
	case *VExplainStmt:
		return c.COWRefOfVExplainStmt(in)
	case *VStream:
		return c.COWRefOfVStream(in)
	default:
		// this should never happen
		return nil
	}
}

// COWTableExpr creates a deep clone of the input.
func (c cow) COWTableExpr(in TableExpr) (TableExpr, bool) {
	if in == nil {
		return nil, false
	}
	if c.old == in {
		return c.new, true
	}
	switch in := in.(type) {
	case *AliasedTableExpr:
		return c.COWRefOfAliasedTableExpr(in)
	case *JSONTableExpr:
		return c.COWRefOfJSONTableExpr(in)
	case *JoinTableExpr:
		return c.COWRefOfJoinTableExpr(in)
	case *ParenTableExpr:
		return c.COWRefOfParenTableExpr(in)
	default:
		// this should never happen
		return nil
	}
}

// COWSliceOfRefOfColumnDefinition creates a deep clone of the input.
func COWSliceOfRefOfColumnDefinition(n []*ColumnDefinition) []*ColumnDefinition {
	if n == nil {
		return nil
	}
	res := make([]*ColumnDefinition, len(n))
	for i, x := range n {
		res[i] = c.COWRefOfColumnDefinition(x)
	}
	return res
}

// COWRefOfBool creates a deep clone of the input.
func (c cow) COWRefOfBool(n *bool) (*bool, bool) {
	return n, false
}

// COWSliceOfDatabaseOption creates a deep clone of the input.
func COWSliceOfDatabaseOption(n []DatabaseOption) []DatabaseOption {
	if n == nil {
		return nil
	}
	res := make([]DatabaseOption, len(n))
	for i, x := range n {
		res[i] = c.COWDatabaseOption(x)
	}
	return res
}

// COWSliceOfAlterOption creates a deep clone of the input.
func COWSliceOfAlterOption(n []AlterOption) []AlterOption {
	if n == nil {
		return nil
	}
	res := make([]AlterOption, len(n))
	for i, x := range n {
		res[i] = c.COWAlterOption(x)
	}
	return res
}

// COWSliceOfIdentifierCI creates a deep clone of the input.
func COWSliceOfIdentifierCI(n []IdentifierCI) []IdentifierCI {
	if n == nil {
		return nil
	}
	res := make([]IdentifierCI, len(n))
	for i, x := range n {
		res[i] = c.COWIdentifierCI(x)
	}
	return res
}

// COWSliceOfTxAccessMode creates a deep clone of the input.
func COWSliceOfTxAccessMode(n []TxAccessMode) []TxAccessMode {
	if n == nil {
		return nil
	}
	res := make([]TxAccessMode, len(n))
	copy(res, n)
	return res
}

// COWSliceOfRefOfWhen creates a deep clone of the input.
func COWSliceOfRefOfWhen(n []*When) []*When {
	if n == nil {
		return nil
	}
	res := make([]*When, len(n))
	for i, x := range n {
		res[i] = c.COWRefOfWhen(x)
	}
	return res
}

// COWColumnType creates a deep clone of the input.
func COWColumnType(n ColumnType) ColumnType {
	return *c.COWRefOfColumnType(&n)
}

// COWRefOfColumnTypeOptions creates a deep clone of the input.
func (c cow) COWRefOfColumnTypeOptions(n *ColumnTypeOptions) (*ColumnTypeOptions, bool) {
	if n == nil {
		return nil, false
	}
	Null, changedNull := c.COWRefOfBool(n.Null)
	Default, changedDefault := c.COWExpr(n.Default)
	OnUpdate, changedOnUpdate := c.COWExpr(n.OnUpdate)
	As, changedAs := c.COWExpr(n.As)
	Comment, changedComment := c.COWRefOfLiteral(n.Comment)
	Reference, changedReference := c.COWRefOfReferenceDefinition(n.Reference)
	Invisible, changedInvisible := c.COWRefOfBool(n.Invisible)
	EngineAttribute, changedEngineAttribute := c.COWRefOfLiteral(n.EngineAttribute)
	SecondaryEngineAttribute, changedSecondaryEngineAttribute := c.COWRefOfLiteral(n.SecondaryEngineAttribute)
	SRID, changedSRID := c.COWRefOfLiteral(n.SRID)
	if changedNull || changedDefault || changedOnUpdate || changedAs || changedComment || changedReference || changedInvisible || changedEngineAttribute || changedSecondaryEngineAttribute || changedSRID {
		out := *n
		out.Null = Null
		out.Default = Default
		out.OnUpdate = OnUpdate
		out.As = As
		out.Comment = Comment
		out.Reference = Reference
		out.Invisible = Invisible
		out.EngineAttribute = EngineAttribute
		out.SecondaryEngineAttribute = SecondaryEngineAttribute
		out.SRID = SRID
		return &out, true
	}
	return n, false
}

// COWColumnCharset creates a deep clone of the input.
func COWColumnCharset(n ColumnCharset) ColumnCharset {
	return *c.COWRefOfColumnCharset(&n)
}

// COWSliceOfString creates a deep clone of the input.
func COWSliceOfString(n []string) []string {
	if n == nil {
		return nil
	}
	res := make([]string, len(n))
	copy(res, n)
	return res
}

// COWSliceOfRefOfVariable creates a deep clone of the input.
func COWSliceOfRefOfVariable(n []*Variable) []*Variable {
	if n == nil {
		return nil
	}
	res := make([]*Variable, len(n))
	for i, x := range n {
		res[i] = c.COWRefOfVariable(x)
	}
	return res
}

// COWRefOfIdentifierCI creates a deep clone of the input.
func (c cow) COWRefOfIdentifierCI(n *IdentifierCI) (*IdentifierCI, bool) {
	if n == nil {
		return nil, false
	}
	return n, false
}

// COWRefOfIdentifierCS creates a deep clone of the input.
func (c cow) COWRefOfIdentifierCS(n *IdentifierCS) (*IdentifierCS, bool) {
	if n == nil {
		return nil, false
	}
	return n, false
}

// COWSliceOfRefOfIndexColumn creates a deep clone of the input.
func COWSliceOfRefOfIndexColumn(n []*IndexColumn) []*IndexColumn {
	if n == nil {
		return nil
	}
	res := make([]*IndexColumn, len(n))
	for i, x := range n {
		res[i] = c.COWRefOfIndexColumn(x)
	}
	return res
}

// COWSliceOfRefOfIndexOption creates a deep clone of the input.
func COWSliceOfRefOfIndexOption(n []*IndexOption) []*IndexOption {
	if n == nil {
		return nil
	}
	res := make([]*IndexOption, len(n))
	for i, x := range n {
		res[i] = c.COWRefOfIndexOption(x)
	}
	return res
}

// COWSliceOfExpr creates a deep clone of the input.
func COWSliceOfExpr(n []Expr) []Expr {
	if n == nil {
		return nil
	}
	res := make([]Expr, len(n))
	for i, x := range n {
		res[i] = c.COWExpr(x)
	}
	return res
}

// COWSliceOfRefOfJSONObjectParam creates a deep clone of the input.
func COWSliceOfRefOfJSONObjectParam(n []*JSONObjectParam) []*JSONObjectParam {
	if n == nil {
		return nil
	}
	res := make([]*JSONObjectParam, len(n))
	for i, x := range n {
		res[i] = c.COWRefOfJSONObjectParam(x)
	}
	return res
}

// COWRefOfJSONObjectParam creates a deep clone of the input.
func (c cow) COWRefOfJSONObjectParam(n *JSONObjectParam) (*JSONObjectParam, bool) {
	if n == nil {
		return nil, false
	}
	Key, changedKey := c.COWExpr(n.Key)
	Value, changedValue := c.COWExpr(n.Value)
	if changedKey || changedValue {
		out := *n
		out.Key = Key
		out.Value = Value
		return &out, true
	}
	return n, false
}

// COWSliceOfRefOfJtColumnDefinition creates a deep clone of the input.
func COWSliceOfRefOfJtColumnDefinition(n []*JtColumnDefinition) []*JtColumnDefinition {
	if n == nil {
		return nil
	}
	res := make([]*JtColumnDefinition, len(n))
	for i, x := range n {
		res[i] = c.COWRefOfJtColumnDefinition(x)
	}
	return res
}

// COWRefOfJtOrdinalColDef creates a deep clone of the input.
func (c cow) COWRefOfJtOrdinalColDef(n *JtOrdinalColDef) (*JtOrdinalColDef, bool) {
	if n == nil {
		return nil, false
	}
	Name, changedName := c.COWIdentifierCI(n.Name)
	if changedName {
		out := *n
		out.Name = Name
		return &out, true
	}
	return n, false
}

// COWRefOfJtPathColDef creates a deep clone of the input.
func (c cow) COWRefOfJtPathColDef(n *JtPathColDef) (*JtPathColDef, bool) {
	if n == nil {
		return nil, false
	}
	Name, changedName := c.COWIdentifierCI(n.Name)
	Type, changedType := c.COWColumnType(n.Type)
	Path, changedPath := c.COWExpr(n.Path)
	EmptyOnResponse, changedEmptyOnResponse := c.COWRefOfJtOnResponse(n.EmptyOnResponse)
	ErrorOnResponse, changedErrorOnResponse := c.COWRefOfJtOnResponse(n.ErrorOnResponse)
	if changedName || changedType || changedPath || changedEmptyOnResponse || changedErrorOnResponse {
		out := *n
		out.Name = Name
		out.Type = Type
		out.Path = Path
		out.EmptyOnResponse = EmptyOnResponse
		out.ErrorOnResponse = ErrorOnResponse
		return &out, true
	}
	return n, false
}

// COWRefOfJtNestedPathColDef creates a deep clone of the input.
func (c cow) COWRefOfJtNestedPathColDef(n *JtNestedPathColDef) (*JtNestedPathColDef, bool) {
	if n == nil {
		return nil, false
	}
	Path, changedPath := c.COWExpr(n.Path)
	Columns, changedColumns := c.COWSliceOfRefOfJtColumnDefinition(n.Columns)
	if changedPath || changedColumns {
		out := *n
		out.Path = Path
		out.Columns = Columns
		return &out, true
	}
	return n, false
}

// COWTableAndLockTypes creates a deep clone of the input.
func COWTableAndLockTypes(n TableAndLockTypes) TableAndLockTypes {
	if n == nil {
		return nil
	}
	res := make(TableAndLockTypes, len(n))
	for i, x := range n {
		res[i] = c.COWRefOfTableAndLockType(x)
	}
	return res
}

// COWSliceOfRefOfColName creates a deep clone of the input.
func COWSliceOfRefOfColName(n []*ColName) []*ColName {
	if n == nil {
		return nil
	}
	res := make([]*ColName, len(n))
	for i, x := range n {
		res[i] = c.COWRefOfColName(x)
	}
	return res
}

// COWComments creates a deep clone of the input.
func COWComments(n Comments) Comments {
	if n == nil {
		return nil
	}
	res := make(Comments, len(n))
	for i, x := range n {
		res[i] = x
	}
	return res
}

// COWRefOfInt creates a deep clone of the input.
func (c cow) COWRefOfInt(n *int) (*int, bool) {
	return n, false
}

// COWSliceOfRefOfPartitionDefinition creates a deep clone of the input.
func COWSliceOfRefOfPartitionDefinition(n []*PartitionDefinition) []*PartitionDefinition {
	if n == nil {
		return nil
	}
	res := make([]*PartitionDefinition, len(n))
	for i, x := range n {
		res[i] = c.COWRefOfPartitionDefinition(x)
	}
	return res
}

// COWSliceOfRefOfRenameTablePair creates a deep clone of the input.
func COWSliceOfRefOfRenameTablePair(n []*RenameTablePair) []*RenameTablePair {
	if n == nil {
		return nil
	}
	res := make([]*RenameTablePair, len(n))
	for i, x := range n {
		res[i] = c.COWRefOfRenameTablePair(x)
	}
	return res
}

// COWRefOfRootNode creates a deep clone of the input.
func (c cow) COWRefOfRootNode(n *RootNode) (*RootNode, bool) {
	if n == nil {
		return nil, false
	}
	SQLNode, changedSQLNode := c.COWSQLNode(n.SQLNode)
	if changedSQLNode {
		out := *n
		out.SQLNode = SQLNode
		return &out, true
	}
	return n, false
}

// COWSliceOfTableExpr creates a deep clone of the input.
func COWSliceOfTableExpr(n []TableExpr) []TableExpr {
	if n == nil {
		return nil
	}
	res := make([]TableExpr, len(n))
	for i, x := range n {
		res[i] = c.COWTableExpr(x)
	}
	return res
}

// COWRefOfTableName creates a deep clone of the input.
func (c cow) COWRefOfTableName(n *TableName) (*TableName, bool) {
	if n == nil {
		return nil, false
	}
	Name, changedName := c.COWIdentifierCS(n.Name)
	Qualifier, changedQualifier := c.COWIdentifierCS(n.Qualifier)
	if changedName || changedQualifier {
		out := *n
		out.Name = Name
		out.Qualifier = Qualifier
		return &out, true
	}
	return n, false
}

// COWRefOfTableOption creates a deep clone of the input.
func (c cow) COWRefOfTableOption(n *TableOption) (*TableOption, bool) {
	if n == nil {
		return nil, false
	}
	Value, changedValue := c.COWRefOfLiteral(n.Value)
	Tables, changedTables := c.COWTableNames(n.Tables)
	if changedValue || changedTables {
		out := *n
		out.Value = Value
		out.Tables = Tables
		return &out, true
	}
	return n, false
}

// COWSliceOfRefOfIndexDefinition creates a deep clone of the input.
func COWSliceOfRefOfIndexDefinition(n []*IndexDefinition) []*IndexDefinition {
	if n == nil {
		return nil
	}
	res := make([]*IndexDefinition, len(n))
	for i, x := range n {
		res[i] = c.COWRefOfIndexDefinition(x)
	}
	return res
}

// COWSliceOfRefOfConstraintDefinition creates a deep clone of the input.
func COWSliceOfRefOfConstraintDefinition(n []*ConstraintDefinition) []*ConstraintDefinition {
	if n == nil {
		return nil
	}
	res := make([]*ConstraintDefinition, len(n))
	for i, x := range n {
		res[i] = c.COWRefOfConstraintDefinition(x)
	}
	return res
}

// COWRefOfVindexParam creates a deep clone of the input.
func (c cow) COWRefOfVindexParam(n *VindexParam) (*VindexParam, bool) {
	if n == nil {
		return nil, false
	}
	Key, changedKey := c.COWIdentifierCI(n.Key)
	if changedKey {
		out := *n
		out.Key = Key
		return &out, true
	}
	return n, false
}

// COWSliceOfVindexParam creates a deep clone of the input.
func COWSliceOfVindexParam(n []VindexParam) []VindexParam {
	if n == nil {
		return nil
	}
	res := make([]VindexParam, len(n))
	for i, x := range n {
		res[i] = c.COWVindexParam(x)
	}
	return res
}

// COWSliceOfRefOfCommonTableExpr creates a deep clone of the input.
func COWSliceOfRefOfCommonTableExpr(n []*CommonTableExpr) []*CommonTableExpr {
	if n == nil {
		return nil
	}
	res := make([]*CommonTableExpr, len(n))
	for i, x := range n {
		res[i] = c.COWRefOfCommonTableExpr(x)
	}
	return res
}

// COWDatabaseOption creates a deep clone of the input.
func COWDatabaseOption(n DatabaseOption) DatabaseOption {
	return *c.COWRefOfDatabaseOption(&n)
}

// COWRefOfColumnCharset creates a deep clone of the input.
func (c cow) COWRefOfColumnCharset(n *ColumnCharset) (*ColumnCharset, bool) {
	if n == nil {
		return nil, false
	}
	return n, false
}

// COWRefOfIndexColumn creates a deep clone of the input.
func (c cow) COWRefOfIndexColumn(n *IndexColumn) (*IndexColumn, bool) {
	if n == nil {
		return nil, false
	}
	Column, changedColumn := c.COWIdentifierCI(n.Column)
	Length, changedLength := c.COWRefOfLiteral(n.Length)
	Expression, changedExpression := c.COWExpr(n.Expression)
	if changedColumn || changedLength || changedExpression {
		out := *n
		out.Column = Column
		out.Length = Length
		out.Expression = Expression
		return &out, true
	}
	return n, false
}

// COWRefOfIndexOption creates a deep clone of the input.
func (c cow) COWRefOfIndexOption(n *IndexOption) (*IndexOption, bool) {
	if n == nil {
		return nil, false
	}
	Value, changedValue := c.COWRefOfLiteral(n.Value)
	if changedValue {
		out := *n
		out.Value = Value
		return &out, true
	}
	return n, false
}

// COWRefOfTableAndLockType creates a deep clone of the input.
func (c cow) COWRefOfTableAndLockType(n *TableAndLockType) (*TableAndLockType, bool) {
	if n == nil {
		return nil, false
	}
	Table, changedTable := c.COWTableExpr(n.Table)
	if changedTable {
		out := *n
		out.Table = Table
		return &out, true
	}
	return n, false
}

// COWRefOfRenameTablePair creates a deep clone of the input.
func (c cow) COWRefOfRenameTablePair(n *RenameTablePair) (*RenameTablePair, bool) {
	if n == nil {
		return nil, false
	}
	FromTable, changedFromTable := c.COWTableName(n.FromTable)
	ToTable, changedToTable := c.COWTableName(n.ToTable)
	if changedFromTable || changedToTable {
		out := *n
		out.FromTable = FromTable
		out.ToTable = ToTable
		return &out, true
	}
	return n, false
}

// COWRefOfDatabaseOption creates a deep clone of the input.
func (c cow) COWRefOfDatabaseOption(n *DatabaseOption) (*DatabaseOption, bool) {
	if n == nil {
		return nil, false
	}
	return n, false
}
