/*
Copyright 2023 The Vitess Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
// Code generated by ASTHelperGen. DO NOT EDIT.

package sqlparser

// COWSQLNode creates a deep clone of the input.
func (c cow) COWSQLNode(in SQLNode) (SQLNode, bool) {
	if in == nil {
		return nil, false
	}
	if c.old == in {
		return c.new, true
	}
	switch in := in.(type) {
	case *AddColumns:
		return c.COWRefOfAddColumns(in)
	case *AddConstraintDefinition:
		return c.COWRefOfAddConstraintDefinition(in)
	case *AddIndexDefinition:
		return c.COWRefOfAddIndexDefinition(in)
	case AlgorithmValue:
		return in
	case *AliasedExpr:
		return c.COWRefOfAliasedExpr(in)
	case *AliasedTableExpr:
		return c.COWRefOfAliasedTableExpr(in)
	case *AlterCharset:
		return c.COWRefOfAlterCharset(in)
	case *AlterCheck:
		return c.COWRefOfAlterCheck(in)
	case *AlterColumn:
		return c.COWRefOfAlterColumn(in)
	case *AlterDatabase:
		return c.COWRefOfAlterDatabase(in)
	case *AlterIndex:
		return c.COWRefOfAlterIndex(in)
	case *AlterMigration:
		return c.COWRefOfAlterMigration(in)
	case *AlterTable:
		return c.COWRefOfAlterTable(in)
	case *AlterView:
		return c.COWRefOfAlterView(in)
	case *AlterVschema:
		return c.COWRefOfAlterVschema(in)
	case *AndExpr:
		return c.COWRefOfAndExpr(in)
	case Argument:
		return in
	case *ArgumentLessWindowExpr:
		return c.COWRefOfArgumentLessWindowExpr(in)
	case *AutoIncSpec:
		return c.COWRefOfAutoIncSpec(in)
	case *Avg:
		return c.COWRefOfAvg(in)
	case *Begin:
		return c.COWRefOfBegin(in)
	case *BetweenExpr:
		return c.COWRefOfBetweenExpr(in)
	case *BinaryExpr:
		return c.COWRefOfBinaryExpr(in)
	case *BitAnd:
		return c.COWRefOfBitAnd(in)
	case *BitOr:
		return c.COWRefOfBitOr(in)
	case *BitXor:
		return c.COWRefOfBitXor(in)
	case BoolVal:
		return in
	case *CallProc:
		return c.COWRefOfCallProc(in)
	case *CaseExpr:
		return c.COWRefOfCaseExpr(in)
	case *CastExpr:
		return c.COWRefOfCastExpr(in)
	case *ChangeColumn:
		return c.COWRefOfChangeColumn(in)
	case *CharExpr:
		return c.COWRefOfCharExpr(in)
	case *CheckConstraintDefinition:
		return c.COWRefOfCheckConstraintDefinition(in)
	case *ColName:
		return c.COWRefOfColName(in)
	case *CollateExpr:
		return c.COWRefOfCollateExpr(in)
	case *ColumnDefinition:
		return c.COWRefOfColumnDefinition(in)
	case *ColumnType:
		return c.COWRefOfColumnType(in)
	case Columns:
		return c.COWColumns(in)
	case *CommentOnly:
		return c.COWRefOfCommentOnly(in)
	case *Commit:
		return c.COWRefOfCommit(in)
	case *CommonTableExpr:
		return c.COWRefOfCommonTableExpr(in)
	case *ComparisonExpr:
		return c.COWRefOfComparisonExpr(in)
	case *ConstraintDefinition:
		return c.COWRefOfConstraintDefinition(in)
	case *ConvertExpr:
		return c.COWRefOfConvertExpr(in)
	case *ConvertType:
		return c.COWRefOfConvertType(in)
	case *ConvertUsingExpr:
		return c.COWRefOfConvertUsingExpr(in)
	case *Count:
		return c.COWRefOfCount(in)
	case *CountStar:
		return c.COWRefOfCountStar(in)
	case *CreateDatabase:
		return c.COWRefOfCreateDatabase(in)
	case *CreateTable:
		return c.COWRefOfCreateTable(in)
	case *CreateView:
		return c.COWRefOfCreateView(in)
	case *CurTimeFuncExpr:
		return c.COWRefOfCurTimeFuncExpr(in)
	case *DeallocateStmt:
		return c.COWRefOfDeallocateStmt(in)
	case *Default:
		return c.COWRefOfDefault(in)
	case *Definer:
		return c.COWRefOfDefiner(in)
	case *Delete:
		return c.COWRefOfDelete(in)
	case *DerivedTable:
		return c.COWRefOfDerivedTable(in)
	case *DropColumn:
		return c.COWRefOfDropColumn(in)
	case *DropDatabase:
		return c.COWRefOfDropDatabase(in)
	case *DropKey:
		return c.COWRefOfDropKey(in)
	case *DropTable:
		return c.COWRefOfDropTable(in)
	case *DropView:
		return c.COWRefOfDropView(in)
	case *ExecuteStmt:
		return c.COWRefOfExecuteStmt(in)
	case *ExistsExpr:
		return c.COWRefOfExistsExpr(in)
	case *ExplainStmt:
		return c.COWRefOfExplainStmt(in)
	case *ExplainTab:
		return c.COWRefOfExplainTab(in)
	case Exprs:
		return c.COWExprs(in)
	case *ExtractFuncExpr:
		return c.COWRefOfExtractFuncExpr(in)
	case *ExtractValueExpr:
		return c.COWRefOfExtractValueExpr(in)
	case *ExtractedSubquery:
		return c.COWRefOfExtractedSubquery(in)
	case *FirstOrLastValueExpr:
		return c.COWRefOfFirstOrLastValueExpr(in)
	case *Flush:
		return c.COWRefOfFlush(in)
	case *Force:
		return c.COWRefOfForce(in)
	case *ForeignKeyDefinition:
		return c.COWRefOfForeignKeyDefinition(in)
	case *FrameClause:
		return c.COWRefOfFrameClause(in)
	case *FramePoint:
		return c.COWRefOfFramePoint(in)
	case *FromFirstLastClause:
		return c.COWRefOfFromFirstLastClause(in)
	case *FuncExpr:
		return c.COWRefOfFuncExpr(in)
	case *GTIDFuncExpr:
		return c.COWRefOfGTIDFuncExpr(in)
	case GroupBy:
		return c.COWGroupBy(in)
	case *GroupConcatExpr:
		return c.COWRefOfGroupConcatExpr(in)
	case IdentifierCI:
		return c.COWIdentifierCI(in)
	case IdentifierCS:
		return c.COWIdentifierCS(in)
	case *IndexDefinition:
		return c.COWRefOfIndexDefinition(in)
	case *IndexHint:
		return c.COWRefOfIndexHint(in)
	case IndexHints:
		return c.COWIndexHints(in)
	case *IndexInfo:
		return c.COWRefOfIndexInfo(in)
	case *Insert:
		return c.COWRefOfInsert(in)
	case *InsertExpr:
		return c.COWRefOfInsertExpr(in)
	case *IntervalExpr:
		return c.COWRefOfIntervalExpr(in)
	case *IntervalFuncExpr:
		return c.COWRefOfIntervalFuncExpr(in)
	case *IntroducerExpr:
		return c.COWRefOfIntroducerExpr(in)
	case *IsExpr:
		return c.COWRefOfIsExpr(in)
	case *JSONArrayExpr:
		return c.COWRefOfJSONArrayExpr(in)
	case *JSONAttributesExpr:
		return c.COWRefOfJSONAttributesExpr(in)
	case *JSONContainsExpr:
		return c.COWRefOfJSONContainsExpr(in)
	case *JSONContainsPathExpr:
		return c.COWRefOfJSONContainsPathExpr(in)
	case *JSONExtractExpr:
		return c.COWRefOfJSONExtractExpr(in)
	case *JSONKeysExpr:
		return c.COWRefOfJSONKeysExpr(in)
	case *JSONObjectExpr:
		return c.COWRefOfJSONObjectExpr(in)
	case JSONObjectParam:
		return c.COWJSONObjectParam(in)
	case *JSONOverlapsExpr:
		return c.COWRefOfJSONOverlapsExpr(in)
	case *JSONPrettyExpr:
		return c.COWRefOfJSONPrettyExpr(in)
	case *JSONQuoteExpr:
		return c.COWRefOfJSONQuoteExpr(in)
	case *JSONRemoveExpr:
		return c.COWRefOfJSONRemoveExpr(in)
	case *JSONSchemaValidFuncExpr:
		return c.COWRefOfJSONSchemaValidFuncExpr(in)
	case *JSONSchemaValidationReportFuncExpr:
		return c.COWRefOfJSONSchemaValidationReportFuncExpr(in)
	case *JSONSearchExpr:
		return c.COWRefOfJSONSearchExpr(in)
	case *JSONStorageFreeExpr:
		return c.COWRefOfJSONStorageFreeExpr(in)
	case *JSONStorageSizeExpr:
		return c.COWRefOfJSONStorageSizeExpr(in)
	case *JSONTableExpr:
		return c.COWRefOfJSONTableExpr(in)
	case *JSONUnquoteExpr:
		return c.COWRefOfJSONUnquoteExpr(in)
	case *JSONValueExpr:
		return c.COWRefOfJSONValueExpr(in)
	case *JSONValueMergeExpr:
		return c.COWRefOfJSONValueMergeExpr(in)
	case *JSONValueModifierExpr:
		return c.COWRefOfJSONValueModifierExpr(in)
	case *JoinCondition:
		return c.COWRefOfJoinCondition(in)
	case *JoinTableExpr:
		return c.COWRefOfJoinTableExpr(in)
	case *JtColumnDefinition:
		return c.COWRefOfJtColumnDefinition(in)
	case *JtOnResponse:
		return c.COWRefOfJtOnResponse(in)
	case *KeyState:
		return c.COWRefOfKeyState(in)
	case *LagLeadExpr:
		return c.COWRefOfLagLeadExpr(in)
	case *Limit:
		return c.COWRefOfLimit(in)
	case ListArg:
		return in
	case *Literal:
		return c.COWRefOfLiteral(in)
	case *Load:
		return c.COWRefOfLoad(in)
	case *LocateExpr:
		return c.COWRefOfLocateExpr(in)
	case *LockOption:
		return c.COWRefOfLockOption(in)
	case *LockTables:
		return c.COWRefOfLockTables(in)
	case *LockingFunc:
		return c.COWRefOfLockingFunc(in)
	case MatchAction:
		return in
	case *MatchExpr:
		return c.COWRefOfMatchExpr(in)
	case *Max:
		return c.COWRefOfMax(in)
	case *MemberOfExpr:
		return c.COWRefOfMemberOfExpr(in)
	case *Min:
		return c.COWRefOfMin(in)
	case *ModifyColumn:
		return c.COWRefOfModifyColumn(in)
	case *NTHValueExpr:
		return c.COWRefOfNTHValueExpr(in)
	case *NamedWindow:
		return c.COWRefOfNamedWindow(in)
	case NamedWindows:
		return c.COWNamedWindows(in)
	case *Nextval:
		return c.COWRefOfNextval(in)
	case *NotExpr:
		return c.COWRefOfNotExpr(in)
	case *NtileExpr:
		return c.COWRefOfNtileExpr(in)
	case *NullTreatmentClause:
		return c.COWRefOfNullTreatmentClause(in)
	case *NullVal:
		return c.COWRefOfNullVal(in)
	case *Offset:
		return c.COWRefOfOffset(in)
	case OnDup:
		return c.COWOnDup(in)
	case *OptLike:
		return c.COWRefOfOptLike(in)
	case *OrExpr:
		return c.COWRefOfOrExpr(in)
	case *Order:
		return c.COWRefOfOrder(in)
	case OrderBy:
		return c.COWOrderBy(in)
	case *OrderByOption:
		return c.COWRefOfOrderByOption(in)
	case *OtherAdmin:
		return c.COWRefOfOtherAdmin(in)
	case *OtherRead:
		return c.COWRefOfOtherRead(in)
	case *OverClause:
		return c.COWRefOfOverClause(in)
	case *ParenTableExpr:
		return c.COWRefOfParenTableExpr(in)
	case *ParsedComments:
		return c.COWRefOfParsedComments(in)
	case *PartitionDefinition:
		return c.COWRefOfPartitionDefinition(in)
	case *PartitionDefinitionOptions:
		return c.COWRefOfPartitionDefinitionOptions(in)
	case *PartitionEngine:
		return c.COWRefOfPartitionEngine(in)
	case *PartitionOption:
		return c.COWRefOfPartitionOption(in)
	case *PartitionSpec:
		return c.COWRefOfPartitionSpec(in)
	case *PartitionValueRange:
		return c.COWRefOfPartitionValueRange(in)
	case Partitions:
		return c.COWPartitions(in)
	case *PerformanceSchemaFuncExpr:
		return c.COWRefOfPerformanceSchemaFuncExpr(in)
	case *PrepareStmt:
		return c.COWRefOfPrepareStmt(in)
	case ReferenceAction:
		return in
	case *ReferenceDefinition:
		return c.COWRefOfReferenceDefinition(in)
	case *RegexpInstrExpr:
		return c.COWRefOfRegexpInstrExpr(in)
	case *RegexpLikeExpr:
		return c.COWRefOfRegexpLikeExpr(in)
	case *RegexpReplaceExpr:
		return c.COWRefOfRegexpReplaceExpr(in)
	case *RegexpSubstrExpr:
		return c.COWRefOfRegexpSubstrExpr(in)
	case *Release:
		return c.COWRefOfRelease(in)
	case *RenameColumn:
		return c.COWRefOfRenameColumn(in)
	case *RenameIndex:
		return c.COWRefOfRenameIndex(in)
	case *RenameTable:
		return c.COWRefOfRenameTable(in)
	case *RenameTableName:
		return c.COWRefOfRenameTableName(in)
	case *RevertMigration:
		return c.COWRefOfRevertMigration(in)
	case *Rollback:
		return c.COWRefOfRollback(in)
	case RootNode:
		return c.COWRootNode(in)
	case *SRollback:
		return c.COWRefOfSRollback(in)
	case *Savepoint:
		return c.COWRefOfSavepoint(in)
	case *Select:
		return c.COWRefOfSelect(in)
	case SelectExprs:
		return c.COWSelectExprs(in)
	case *SelectInto:
		return c.COWRefOfSelectInto(in)
	case *Set:
		return c.COWRefOfSet(in)
	case *SetExpr:
		return c.COWRefOfSetExpr(in)
	case SetExprs:
		return c.COWSetExprs(in)
	case *Show:
		return c.COWRefOfShow(in)
	case *ShowBasic:
		return c.COWRefOfShowBasic(in)
	case *ShowCreate:
		return c.COWRefOfShowCreate(in)
	case *ShowFilter:
		return c.COWRefOfShowFilter(in)
	case *ShowMigrationLogs:
		return c.COWRefOfShowMigrationLogs(in)
	case *ShowOther:
		return c.COWRefOfShowOther(in)
	case *ShowThrottledApps:
		return c.COWRefOfShowThrottledApps(in)
	case *ShowThrottlerStatus:
		return c.COWRefOfShowThrottlerStatus(in)
	case *StarExpr:
		return c.COWRefOfStarExpr(in)
	case *Std:
		return c.COWRefOfStd(in)
	case *StdDev:
		return c.COWRefOfStdDev(in)
	case *StdPop:
		return c.COWRefOfStdPop(in)
	case *StdSamp:
		return c.COWRefOfStdSamp(in)
	case *Stream:
		return c.COWRefOfStream(in)
	case *SubPartition:
		return c.COWRefOfSubPartition(in)
	case *SubPartitionDefinition:
		return c.COWRefOfSubPartitionDefinition(in)
	case *SubPartitionDefinitionOptions:
		return c.COWRefOfSubPartitionDefinitionOptions(in)
	case SubPartitionDefinitions:
		return c.COWSubPartitionDefinitions(in)
	case *Subquery:
		return c.COWRefOfSubquery(in)
	case *SubstrExpr:
		return c.COWRefOfSubstrExpr(in)
	case *Sum:
		return c.COWRefOfSum(in)
	case TableExprs:
		return c.COWTableExprs(in)
	case TableName:
		return c.COWTableName(in)
	case TableNames:
		return c.COWTableNames(in)
	case TableOptions:
		return c.COWTableOptions(in)
	case *TableSpec:
		return c.COWRefOfTableSpec(in)
	case *TablespaceOperation:
		return c.COWRefOfTablespaceOperation(in)
	case *TimestampFuncExpr:
		return c.COWRefOfTimestampFuncExpr(in)
	case *TrimFuncExpr:
		return c.COWRefOfTrimFuncExpr(in)
	case *TruncateTable:
		return c.COWRefOfTruncateTable(in)
	case *UnaryExpr:
		return c.COWRefOfUnaryExpr(in)
	case *Union:
		return c.COWRefOfUnion(in)
	case *UnlockTables:
		return c.COWRefOfUnlockTables(in)
	case *Update:
		return c.COWRefOfUpdate(in)
	case *UpdateExpr:
		return c.COWRefOfUpdateExpr(in)
	case UpdateExprs:
		return c.COWUpdateExprs(in)
	case *UpdateXMLExpr:
		return c.COWRefOfUpdateXMLExpr(in)
	case *Use:
		return c.COWRefOfUse(in)
	case *VExplainStmt:
		return c.COWRefOfVExplainStmt(in)
	case *VStream:
		return c.COWRefOfVStream(in)
	case ValTuple:
		return c.COWValTuple(in)
	case *Validation:
		return c.COWRefOfValidation(in)
	case Values:
		return c.COWValues(in)
	case *ValuesFuncExpr:
		return c.COWRefOfValuesFuncExpr(in)
	case *VarPop:
		return c.COWRefOfVarPop(in)
	case *VarSamp:
		return c.COWRefOfVarSamp(in)
	case *Variable:
		return c.COWRefOfVariable(in)
	case *Variance:
		return c.COWRefOfVariance(in)
	case VindexParam:
		return c.COWVindexParam(in)
	case *VindexSpec:
		return c.COWRefOfVindexSpec(in)
	case *WeightStringFuncExpr:
		return c.COWRefOfWeightStringFuncExpr(in)
	case *When:
		return c.COWRefOfWhen(in)
	case *Where:
		return c.COWRefOfWhere(in)
	case *WindowDefinition:
		return c.COWRefOfWindowDefinition(in)
	case WindowDefinitions:
		return c.COWWindowDefinitions(in)
	case *WindowSpecification:
		return c.COWRefOfWindowSpecification(in)
	case *With:
		return c.COWRefOfWith(in)
	case *XorExpr:
		return c.COWRefOfXorExpr(in)
	default:
		// this should never happen
		return nil
	}
}

// COWRefOfAddColumns creates a deep clone of the input.
func (c cow) COWRefOfAddColumns(n *AddColumns) (*AddColumns, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Columns = c.COWSliceOfRefOfColumnDefinition(n.Columns)
	out.After = c.COWRefOfColName(n.After)
	return &out
}

// COWRefOfAddConstraintDefinition creates a deep clone of the input.
func (c cow) COWRefOfAddConstraintDefinition(n *AddConstraintDefinition) (*AddConstraintDefinition, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.ConstraintDefinition = c.COWRefOfConstraintDefinition(n.ConstraintDefinition)
	return &out
}

// COWRefOfAddIndexDefinition creates a deep clone of the input.
func (c cow) COWRefOfAddIndexDefinition(n *AddIndexDefinition) (*AddIndexDefinition, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.IndexDefinition = c.COWRefOfIndexDefinition(n.IndexDefinition)
	return &out
}

// COWRefOfAliasedExpr creates a deep clone of the input.
func (c cow) COWRefOfAliasedExpr(n *AliasedExpr) (*AliasedExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = c.COWExpr(n.Expr)
	out.As = c.COWIdentifierCI(n.As)
	return &out
}

// COWRefOfAliasedTableExpr creates a deep clone of the input.
func (c cow) COWRefOfAliasedTableExpr(n *AliasedTableExpr) (*AliasedTableExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = c.COWSimpleTableExpr(n.Expr)
	out.Partitions = c.COWPartitions(n.Partitions)
	out.As = c.COWIdentifierCS(n.As)
	out.Hints = c.COWIndexHints(n.Hints)
	out.Columns = c.COWColumns(n.Columns)
	return &out
}

// COWRefOfAlterCharset creates a deep clone of the input.
func (c cow) COWRefOfAlterCharset(n *AlterCharset) (*AlterCharset, bool) {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// COWRefOfAlterCheck creates a deep clone of the input.
func (c cow) COWRefOfAlterCheck(n *AlterCheck) (*AlterCheck, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = c.COWIdentifierCI(n.Name)
	return &out
}

// COWRefOfAlterColumn creates a deep clone of the input.
func (c cow) COWRefOfAlterColumn(n *AlterColumn) (*AlterColumn, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Column = c.COWRefOfColName(n.Column)
	out.DefaultVal = c.COWExpr(n.DefaultVal)
	out.Invisible = c.COWRefOfBool(n.Invisible)
	return &out
}

// COWRefOfAlterDatabase creates a deep clone of the input.
func (c cow) COWRefOfAlterDatabase(n *AlterDatabase) (*AlterDatabase, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.DBName = c.COWIdentifierCS(n.DBName)
	out.AlterOptions = c.COWSliceOfDatabaseOption(n.AlterOptions)
	return &out
}

// COWRefOfAlterIndex creates a deep clone of the input.
func (c cow) COWRefOfAlterIndex(n *AlterIndex) (*AlterIndex, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = c.COWIdentifierCI(n.Name)
	return &out
}

// COWRefOfAlterMigration creates a deep clone of the input.
func (c cow) COWRefOfAlterMigration(n *AlterMigration) (*AlterMigration, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Ratio = c.COWRefOfLiteral(n.Ratio)
	return &out
}

// COWRefOfAlterTable creates a deep clone of the input.
func (c cow) COWRefOfAlterTable(n *AlterTable) (*AlterTable, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Table = c.COWTableName(n.Table)
	out.AlterOptions = c.COWSliceOfAlterOption(n.AlterOptions)
	out.PartitionSpec = c.COWRefOfPartitionSpec(n.PartitionSpec)
	out.PartitionOption = c.COWRefOfPartitionOption(n.PartitionOption)
	out.Comments = c.COWRefOfParsedComments(n.Comments)
	return &out
}

// COWRefOfAlterView creates a deep clone of the input.
func (c cow) COWRefOfAlterView(n *AlterView) (*AlterView, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.ViewName = c.COWTableName(n.ViewName)
	out.Definer = c.COWRefOfDefiner(n.Definer)
	out.Columns = c.COWColumns(n.Columns)
	out.Select = c.COWSelectStatement(n.Select)
	out.Comments = c.COWRefOfParsedComments(n.Comments)
	return &out
}

// COWRefOfAlterVschema creates a deep clone of the input.
func (c cow) COWRefOfAlterVschema(n *AlterVschema) (*AlterVschema, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Table = c.COWTableName(n.Table)
	out.VindexSpec = c.COWRefOfVindexSpec(n.VindexSpec)
	out.VindexCols = c.COWSliceOfIdentifierCI(n.VindexCols)
	out.AutoIncSpec = c.COWRefOfAutoIncSpec(n.AutoIncSpec)
	return &out
}

// COWRefOfAndExpr creates a deep clone of the input.
func (c cow) COWRefOfAndExpr(n *AndExpr) (*AndExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Left = c.COWExpr(n.Left)
	out.Right = c.COWExpr(n.Right)
	return &out
}

// COWRefOfArgumentLessWindowExpr creates a deep clone of the input.
func (c cow) COWRefOfArgumentLessWindowExpr(n *ArgumentLessWindowExpr) (*ArgumentLessWindowExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.OverClause = c.COWRefOfOverClause(n.OverClause)
	return &out
}

// COWRefOfAutoIncSpec creates a deep clone of the input.
func (c cow) COWRefOfAutoIncSpec(n *AutoIncSpec) (*AutoIncSpec, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Column = c.COWIdentifierCI(n.Column)
	out.Sequence = c.COWTableName(n.Sequence)
	return &out
}

// COWRefOfAvg creates a deep clone of the input.
func (c cow) COWRefOfAvg(n *Avg) (*Avg, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Arg = c.COWExpr(n.Arg)
	return &out
}

// COWRefOfBegin creates a deep clone of the input.
func (c cow) COWRefOfBegin(n *Begin) (*Begin, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.TxAccessModes = c.COWSliceOfTxAccessMode(n.TxAccessModes)
	return &out
}

// COWRefOfBetweenExpr creates a deep clone of the input.
func (c cow) COWRefOfBetweenExpr(n *BetweenExpr) (*BetweenExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Left = c.COWExpr(n.Left)
	out.From = c.COWExpr(n.From)
	out.To = c.COWExpr(n.To)
	return &out
}

// COWRefOfBinaryExpr creates a deep clone of the input.
func (c cow) COWRefOfBinaryExpr(n *BinaryExpr) (*BinaryExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Left = c.COWExpr(n.Left)
	out.Right = c.COWExpr(n.Right)
	return &out
}

// COWRefOfBitAnd creates a deep clone of the input.
func (c cow) COWRefOfBitAnd(n *BitAnd) (*BitAnd, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Arg = c.COWExpr(n.Arg)
	return &out
}

// COWRefOfBitOr creates a deep clone of the input.
func (c cow) COWRefOfBitOr(n *BitOr) (*BitOr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Arg = c.COWExpr(n.Arg)
	return &out
}

// COWRefOfBitXor creates a deep clone of the input.
func (c cow) COWRefOfBitXor(n *BitXor) (*BitXor, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Arg = c.COWExpr(n.Arg)
	return &out
}

// COWRefOfCallProc creates a deep clone of the input.
func (c cow) COWRefOfCallProc(n *CallProc) (*CallProc, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = c.COWTableName(n.Name)
	out.Params = c.COWExprs(n.Params)
	return &out
}

// COWRefOfCaseExpr creates a deep clone of the input.
func (c cow) COWRefOfCaseExpr(n *CaseExpr) (*CaseExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = c.COWExpr(n.Expr)
	out.Whens = c.COWSliceOfRefOfWhen(n.Whens)
	out.Else = c.COWExpr(n.Else)
	return &out
}

// COWRefOfCastExpr creates a deep clone of the input.
func (c cow) COWRefOfCastExpr(n *CastExpr) (*CastExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = c.COWExpr(n.Expr)
	out.Type = c.COWRefOfConvertType(n.Type)
	return &out
}

// COWRefOfChangeColumn creates a deep clone of the input.
func (c cow) COWRefOfChangeColumn(n *ChangeColumn) (*ChangeColumn, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.OldColumn = c.COWRefOfColName(n.OldColumn)
	out.NewColDefinition = c.COWRefOfColumnDefinition(n.NewColDefinition)
	out.After = c.COWRefOfColName(n.After)
	return &out
}

// COWRefOfCharExpr creates a deep clone of the input.
func (c cow) COWRefOfCharExpr(n *CharExpr) (*CharExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Exprs = c.COWExprs(n.Exprs)
	return &out
}

// COWRefOfCheckConstraintDefinition creates a deep clone of the input.
func (c cow) COWRefOfCheckConstraintDefinition(n *CheckConstraintDefinition) (*CheckConstraintDefinition, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = c.COWExpr(n.Expr)
	return &out
}

// COWRefOfColName creates a deep clone of the input.
func (c cow) COWRefOfColName(n *ColName) (*ColName, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Metadata = n.Metadata
	out.Name = c.COWIdentifierCI(n.Name)
	out.Qualifier = c.COWTableName(n.Qualifier)
	return &out
}

// COWRefOfCollateExpr creates a deep clone of the input.
func (c cow) COWRefOfCollateExpr(n *CollateExpr) (*CollateExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = c.COWExpr(n.Expr)
	return &out
}

// COWRefOfColumnDefinition creates a deep clone of the input.
func (c cow) COWRefOfColumnDefinition(n *ColumnDefinition) (*ColumnDefinition, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = c.COWIdentifierCI(n.Name)
	out.Type = c.COWColumnType(n.Type)
	return &out
}

// COWRefOfColumnType creates a deep clone of the input.
func (c cow) COWRefOfColumnType(n *ColumnType) (*ColumnType, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Options = c.COWRefOfColumnTypeOptions(n.Options)
	out.Length = c.COWRefOfLiteral(n.Length)
	out.Scale = c.COWRefOfLiteral(n.Scale)
	out.Charset = c.COWColumnCharset(n.Charset)
	out.EnumValues = c.COWSliceOfString(n.EnumValues)
	return &out
}

// COWColumns creates a deep clone of the input.
func COWColumns(n Columns) Columns {
	if n == nil {
		return nil
	}
	res := make(Columns, len(n))
	for i, x := range n {
		res[i] = c.COWIdentifierCI(x)
	}
	return res
}

// COWRefOfCommentOnly creates a deep clone of the input.
func (c cow) COWRefOfCommentOnly(n *CommentOnly) (*CommentOnly, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Comments = c.COWSliceOfString(n.Comments)
	return &out
}

// COWRefOfCommit creates a deep clone of the input.
func (c cow) COWRefOfCommit(n *Commit) (*Commit, bool) {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// COWRefOfCommonTableExpr creates a deep clone of the input.
func (c cow) COWRefOfCommonTableExpr(n *CommonTableExpr) (*CommonTableExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.ID = c.COWIdentifierCS(n.ID)
	out.Columns = c.COWColumns(n.Columns)
	out.Subquery = c.COWRefOfSubquery(n.Subquery)
	return &out
}

// COWRefOfComparisonExpr creates a deep clone of the input.
func (c cow) COWRefOfComparisonExpr(n *ComparisonExpr) (*ComparisonExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Left = c.COWExpr(n.Left)
	out.Right = c.COWExpr(n.Right)
	out.Escape = c.COWExpr(n.Escape)
	return &out
}

// COWRefOfConstraintDefinition creates a deep clone of the input.
func (c cow) COWRefOfConstraintDefinition(n *ConstraintDefinition) (*ConstraintDefinition, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = c.COWIdentifierCI(n.Name)
	out.Details = c.COWConstraintInfo(n.Details)
	return &out
}

// COWRefOfConvertExpr creates a deep clone of the input.
func (c cow) COWRefOfConvertExpr(n *ConvertExpr) (*ConvertExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = c.COWExpr(n.Expr)
	out.Type = c.COWRefOfConvertType(n.Type)
	return &out
}

// COWRefOfConvertType creates a deep clone of the input.
func (c cow) COWRefOfConvertType(n *ConvertType) (*ConvertType, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Length = c.COWRefOfLiteral(n.Length)
	out.Scale = c.COWRefOfLiteral(n.Scale)
	out.Charset = c.COWColumnCharset(n.Charset)
	return &out
}

// COWRefOfConvertUsingExpr creates a deep clone of the input.
func (c cow) COWRefOfConvertUsingExpr(n *ConvertUsingExpr) (*ConvertUsingExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = c.COWExpr(n.Expr)
	return &out
}

// COWRefOfCount creates a deep clone of the input.
func (c cow) COWRefOfCount(n *Count) (*Count, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Args = c.COWExprs(n.Args)
	return &out
}

// COWRefOfCountStar creates a deep clone of the input.
func (c cow) COWRefOfCountStar(n *CountStar) (*CountStar, bool) {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// COWRefOfCreateDatabase creates a deep clone of the input.
func (c cow) COWRefOfCreateDatabase(n *CreateDatabase) (*CreateDatabase, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Comments = c.COWRefOfParsedComments(n.Comments)
	out.DBName = c.COWIdentifierCS(n.DBName)
	out.CreateOptions = c.COWSliceOfDatabaseOption(n.CreateOptions)
	return &out
}

// COWRefOfCreateTable creates a deep clone of the input.
func (c cow) COWRefOfCreateTable(n *CreateTable) (*CreateTable, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Table = c.COWTableName(n.Table)
	out.TableSpec = c.COWRefOfTableSpec(n.TableSpec)
	out.OptLike = c.COWRefOfOptLike(n.OptLike)
	out.Comments = c.COWRefOfParsedComments(n.Comments)
	return &out
}

// COWRefOfCreateView creates a deep clone of the input.
func (c cow) COWRefOfCreateView(n *CreateView) (*CreateView, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.ViewName = c.COWTableName(n.ViewName)
	out.Definer = c.COWRefOfDefiner(n.Definer)
	out.Columns = c.COWColumns(n.Columns)
	out.Select = c.COWSelectStatement(n.Select)
	out.Comments = c.COWRefOfParsedComments(n.Comments)
	return &out
}

// COWRefOfCurTimeFuncExpr creates a deep clone of the input.
func (c cow) COWRefOfCurTimeFuncExpr(n *CurTimeFuncExpr) (*CurTimeFuncExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = c.COWIdentifierCI(n.Name)
	out.Fsp = c.COWExpr(n.Fsp)
	return &out
}

// COWRefOfDeallocateStmt creates a deep clone of the input.
func (c cow) COWRefOfDeallocateStmt(n *DeallocateStmt) (*DeallocateStmt, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Comments = c.COWRefOfParsedComments(n.Comments)
	out.Name = c.COWIdentifierCI(n.Name)
	return &out
}

// COWRefOfDefault creates a deep clone of the input.
func (c cow) COWRefOfDefault(n *Default) (*Default, bool) {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// COWRefOfDefiner creates a deep clone of the input.
func (c cow) COWRefOfDefiner(n *Definer) (*Definer, bool) {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// COWRefOfDelete creates a deep clone of the input.
func (c cow) COWRefOfDelete(n *Delete) (*Delete, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.With = c.COWRefOfWith(n.With)
	out.Comments = c.COWRefOfParsedComments(n.Comments)
	out.Targets = c.COWTableNames(n.Targets)
	out.TableExprs = c.COWTableExprs(n.TableExprs)
	out.Partitions = c.COWPartitions(n.Partitions)
	out.Where = c.COWRefOfWhere(n.Where)
	out.OrderBy = c.COWOrderBy(n.OrderBy)
	out.Limit = c.COWRefOfLimit(n.Limit)
	return &out
}

// COWRefOfDerivedTable creates a deep clone of the input.
func (c cow) COWRefOfDerivedTable(n *DerivedTable) (*DerivedTable, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Select = c.COWSelectStatement(n.Select)
	return &out
}

// COWRefOfDropColumn creates a deep clone of the input.
func (c cow) COWRefOfDropColumn(n *DropColumn) (*DropColumn, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = c.COWRefOfColName(n.Name)
	return &out
}

// COWRefOfDropDatabase creates a deep clone of the input.
func (c cow) COWRefOfDropDatabase(n *DropDatabase) (*DropDatabase, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Comments = c.COWRefOfParsedComments(n.Comments)
	out.DBName = c.COWIdentifierCS(n.DBName)
	return &out
}

// COWRefOfDropKey creates a deep clone of the input.
func (c cow) COWRefOfDropKey(n *DropKey) (*DropKey, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = c.COWIdentifierCI(n.Name)
	return &out
}

// COWRefOfDropTable creates a deep clone of the input.
func (c cow) COWRefOfDropTable(n *DropTable) (*DropTable, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.FromTables = c.COWTableNames(n.FromTables)
	out.Comments = c.COWRefOfParsedComments(n.Comments)
	return &out
}

// COWRefOfDropView creates a deep clone of the input.
func (c cow) COWRefOfDropView(n *DropView) (*DropView, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.FromTables = c.COWTableNames(n.FromTables)
	out.Comments = c.COWRefOfParsedComments(n.Comments)
	return &out
}

// COWRefOfExecuteStmt creates a deep clone of the input.
func (c cow) COWRefOfExecuteStmt(n *ExecuteStmt) (*ExecuteStmt, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = c.COWIdentifierCI(n.Name)
	out.Comments = c.COWRefOfParsedComments(n.Comments)
	out.Arguments = c.COWSliceOfRefOfVariable(n.Arguments)
	return &out
}

// COWRefOfExistsExpr creates a deep clone of the input.
func (c cow) COWRefOfExistsExpr(n *ExistsExpr) (*ExistsExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Subquery = c.COWRefOfSubquery(n.Subquery)
	return &out
}

// COWRefOfExplainStmt creates a deep clone of the input.
func (c cow) COWRefOfExplainStmt(n *ExplainStmt) (*ExplainStmt, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Statement = c.COWStatement(n.Statement)
	out.Comments = c.COWRefOfParsedComments(n.Comments)
	return &out
}

// COWRefOfExplainTab creates a deep clone of the input.
func (c cow) COWRefOfExplainTab(n *ExplainTab) (*ExplainTab, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Table = c.COWTableName(n.Table)
	return &out
}

// COWExprs creates a deep clone of the input.
func COWExprs(n Exprs) Exprs {
	if n == nil {
		return nil
	}
	res := make(Exprs, len(n))
	for i, x := range n {
		res[i] = c.COWExpr(x)
	}
	return res
}

// COWRefOfExtractFuncExpr creates a deep clone of the input.
func (c cow) COWRefOfExtractFuncExpr(n *ExtractFuncExpr) (*ExtractFuncExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = c.COWExpr(n.Expr)
	return &out
}

// COWRefOfExtractValueExpr creates a deep clone of the input.
func (c cow) COWRefOfExtractValueExpr(n *ExtractValueExpr) (*ExtractValueExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Fragment = c.COWExpr(n.Fragment)
	out.XPathExpr = c.COWExpr(n.XPathExpr)
	return &out
}

// COWRefOfExtractedSubquery creates a deep clone of the input.
func (c cow) COWRefOfExtractedSubquery(n *ExtractedSubquery) (*ExtractedSubquery, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Original = c.COWExpr(n.Original)
	out.Subquery = c.COWRefOfSubquery(n.Subquery)
	out.OtherSide = c.COWExpr(n.OtherSide)
	out.alternative = c.COWExpr(n.alternative)
	return &out
}

// COWRefOfFirstOrLastValueExpr creates a deep clone of the input.
func (c cow) COWRefOfFirstOrLastValueExpr(n *FirstOrLastValueExpr) (*FirstOrLastValueExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = c.COWExpr(n.Expr)
	out.NullTreatmentClause = c.COWRefOfNullTreatmentClause(n.NullTreatmentClause)
	out.OverClause = c.COWRefOfOverClause(n.OverClause)
	return &out
}

// COWRefOfFlush creates a deep clone of the input.
func (c cow) COWRefOfFlush(n *Flush) (*Flush, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.FlushOptions = c.COWSliceOfString(n.FlushOptions)
	out.TableNames = c.COWTableNames(n.TableNames)
	return &out
}

// COWRefOfForce creates a deep clone of the input.
func (c cow) COWRefOfForce(n *Force) (*Force, bool) {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// COWRefOfForeignKeyDefinition creates a deep clone of the input.
func (c cow) COWRefOfForeignKeyDefinition(n *ForeignKeyDefinition) (*ForeignKeyDefinition, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Source = c.COWColumns(n.Source)
	out.IndexName = c.COWIdentifierCI(n.IndexName)
	out.ReferenceDefinition = c.COWRefOfReferenceDefinition(n.ReferenceDefinition)
	return &out
}

// COWRefOfFrameClause creates a deep clone of the input.
func (c cow) COWRefOfFrameClause(n *FrameClause) (*FrameClause, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Start = c.COWRefOfFramePoint(n.Start)
	out.End = c.COWRefOfFramePoint(n.End)
	return &out
}

// COWRefOfFramePoint creates a deep clone of the input.
func (c cow) COWRefOfFramePoint(n *FramePoint) (*FramePoint, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = c.COWExpr(n.Expr)
	return &out
}

// COWRefOfFromFirstLastClause creates a deep clone of the input.
func (c cow) COWRefOfFromFirstLastClause(n *FromFirstLastClause) (*FromFirstLastClause, bool) {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// COWRefOfFuncExpr creates a deep clone of the input.
func (c cow) COWRefOfFuncExpr(n *FuncExpr) (*FuncExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Qualifier = c.COWIdentifierCS(n.Qualifier)
	out.Name = c.COWIdentifierCI(n.Name)
	out.Exprs = c.COWSelectExprs(n.Exprs)
	return &out
}

// COWRefOfGTIDFuncExpr creates a deep clone of the input.
func (c cow) COWRefOfGTIDFuncExpr(n *GTIDFuncExpr) (*GTIDFuncExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Set1 = c.COWExpr(n.Set1)
	out.Set2 = c.COWExpr(n.Set2)
	out.Timeout = c.COWExpr(n.Timeout)
	out.Channel = c.COWExpr(n.Channel)
	return &out
}

// COWGroupBy creates a deep clone of the input.
func COWGroupBy(n GroupBy) GroupBy {
	if n == nil {
		return nil
	}
	res := make(GroupBy, len(n))
	for i, x := range n {
		res[i] = c.COWExpr(x)
	}
	return res
}

// COWRefOfGroupConcatExpr creates a deep clone of the input.
func (c cow) COWRefOfGroupConcatExpr(n *GroupConcatExpr) (*GroupConcatExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Exprs = c.COWExprs(n.Exprs)
	out.OrderBy = c.COWOrderBy(n.OrderBy)
	out.Limit = c.COWRefOfLimit(n.Limit)
	return &out
}

// COWIdentifierCI creates a deep clone of the input.
func COWIdentifierCI(n IdentifierCI) IdentifierCI {
	return *c.COWRefOfIdentifierCI(&n)
}

// COWIdentifierCS creates a deep clone of the input.
func COWIdentifierCS(n IdentifierCS) IdentifierCS {
	return *c.COWRefOfIdentifierCS(&n)
}

// COWRefOfIndexDefinition creates a deep clone of the input.
func (c cow) COWRefOfIndexDefinition(n *IndexDefinition) (*IndexDefinition, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Info = c.COWRefOfIndexInfo(n.Info)
	out.Columns = c.COWSliceOfRefOfIndexColumn(n.Columns)
	out.Options = c.COWSliceOfRefOfIndexOption(n.Options)
	return &out
}

// COWRefOfIndexHint creates a deep clone of the input.
func (c cow) COWRefOfIndexHint(n *IndexHint) (*IndexHint, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Indexes = c.COWSliceOfIdentifierCI(n.Indexes)
	return &out
}

// COWIndexHints creates a deep clone of the input.
func COWIndexHints(n IndexHints) IndexHints {
	if n == nil {
		return nil
	}
	res := make(IndexHints, len(n))
	for i, x := range n {
		res[i] = c.COWRefOfIndexHint(x)
	}
	return res
}

// COWRefOfIndexInfo creates a deep clone of the input.
func (c cow) COWRefOfIndexInfo(n *IndexInfo) (*IndexInfo, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = c.COWIdentifierCI(n.Name)
	out.ConstraintName = c.COWIdentifierCI(n.ConstraintName)
	return &out
}

// COWRefOfInsert creates a deep clone of the input.
func (c cow) COWRefOfInsert(n *Insert) (*Insert, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Comments = c.COWRefOfParsedComments(n.Comments)
	out.Table = c.COWTableName(n.Table)
	out.Partitions = c.COWPartitions(n.Partitions)
	out.Columns = c.COWColumns(n.Columns)
	out.Rows = c.COWInsertRows(n.Rows)
	out.OnDup = c.COWOnDup(n.OnDup)
	return &out
}

// COWRefOfInsertExpr creates a deep clone of the input.
func (c cow) COWRefOfInsertExpr(n *InsertExpr) (*InsertExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Str = c.COWExpr(n.Str)
	out.Pos = c.COWExpr(n.Pos)
	out.Len = c.COWExpr(n.Len)
	out.NewStr = c.COWExpr(n.NewStr)
	return &out
}

// COWRefOfIntervalExpr creates a deep clone of the input.
func (c cow) COWRefOfIntervalExpr(n *IntervalExpr) (*IntervalExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = c.COWExpr(n.Expr)
	return &out
}

// COWRefOfIntervalFuncExpr creates a deep clone of the input.
func (c cow) COWRefOfIntervalFuncExpr(n *IntervalFuncExpr) (*IntervalFuncExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = c.COWExpr(n.Expr)
	out.Exprs = c.COWExprs(n.Exprs)
	return &out
}

// COWRefOfIntroducerExpr creates a deep clone of the input.
func (c cow) COWRefOfIntroducerExpr(n *IntroducerExpr) (*IntroducerExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = c.COWExpr(n.Expr)
	return &out
}

// COWRefOfIsExpr creates a deep clone of the input.
func (c cow) COWRefOfIsExpr(n *IsExpr) (*IsExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Left = c.COWExpr(n.Left)
	return &out
}

// COWRefOfJSONArrayExpr creates a deep clone of the input.
func (c cow) COWRefOfJSONArrayExpr(n *JSONArrayExpr) (*JSONArrayExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Params = c.COWExprs(n.Params)
	return &out
}

// COWRefOfJSONAttributesExpr creates a deep clone of the input.
func (c cow) COWRefOfJSONAttributesExpr(n *JSONAttributesExpr) (*JSONAttributesExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.JSONDoc = c.COWExpr(n.JSONDoc)
	out.Path = c.COWExpr(n.Path)
	return &out
}

// COWRefOfJSONContainsExpr creates a deep clone of the input.
func (c cow) COWRefOfJSONContainsExpr(n *JSONContainsExpr) (*JSONContainsExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Target = c.COWExpr(n.Target)
	out.Candidate = c.COWExpr(n.Candidate)
	out.PathList = c.COWSliceOfExpr(n.PathList)
	return &out
}

// COWRefOfJSONContainsPathExpr creates a deep clone of the input.
func (c cow) COWRefOfJSONContainsPathExpr(n *JSONContainsPathExpr) (*JSONContainsPathExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.JSONDoc = c.COWExpr(n.JSONDoc)
	out.OneOrAll = c.COWExpr(n.OneOrAll)
	out.PathList = c.COWSliceOfExpr(n.PathList)
	return &out
}

// COWRefOfJSONExtractExpr creates a deep clone of the input.
func (c cow) COWRefOfJSONExtractExpr(n *JSONExtractExpr) (*JSONExtractExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.JSONDoc = c.COWExpr(n.JSONDoc)
	out.PathList = c.COWSliceOfExpr(n.PathList)
	return &out
}

// COWRefOfJSONKeysExpr creates a deep clone of the input.
func (c cow) COWRefOfJSONKeysExpr(n *JSONKeysExpr) (*JSONKeysExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.JSONDoc = c.COWExpr(n.JSONDoc)
	out.Path = c.COWExpr(n.Path)
	return &out
}

// COWRefOfJSONObjectExpr creates a deep clone of the input.
func (c cow) COWRefOfJSONObjectExpr(n *JSONObjectExpr) (*JSONObjectExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Params = c.COWSliceOfRefOfJSONObjectParam(n.Params)
	return &out
}

// COWJSONObjectParam creates a deep clone of the input.
func COWJSONObjectParam(n JSONObjectParam) JSONObjectParam {
	return *c.COWRefOfJSONObjectParam(&n)
}

// COWRefOfJSONOverlapsExpr creates a deep clone of the input.
func (c cow) COWRefOfJSONOverlapsExpr(n *JSONOverlapsExpr) (*JSONOverlapsExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.JSONDoc1 = c.COWExpr(n.JSONDoc1)
	out.JSONDoc2 = c.COWExpr(n.JSONDoc2)
	return &out
}

// COWRefOfJSONPrettyExpr creates a deep clone of the input.
func (c cow) COWRefOfJSONPrettyExpr(n *JSONPrettyExpr) (*JSONPrettyExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.JSONVal = c.COWExpr(n.JSONVal)
	return &out
}

// COWRefOfJSONQuoteExpr creates a deep clone of the input.
func (c cow) COWRefOfJSONQuoteExpr(n *JSONQuoteExpr) (*JSONQuoteExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.StringArg = c.COWExpr(n.StringArg)
	return &out
}

// COWRefOfJSONRemoveExpr creates a deep clone of the input.
func (c cow) COWRefOfJSONRemoveExpr(n *JSONRemoveExpr) (*JSONRemoveExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.JSONDoc = c.COWExpr(n.JSONDoc)
	out.PathList = c.COWExprs(n.PathList)
	return &out
}

// COWRefOfJSONSchemaValidFuncExpr creates a deep clone of the input.
func (c cow) COWRefOfJSONSchemaValidFuncExpr(n *JSONSchemaValidFuncExpr) (*JSONSchemaValidFuncExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Schema = c.COWExpr(n.Schema)
	out.Document = c.COWExpr(n.Document)
	return &out
}

// COWRefOfJSONSchemaValidationReportFuncExpr creates a deep clone of the input.
func (c cow) COWRefOfJSONSchemaValidationReportFuncExpr(n *JSONSchemaValidationReportFuncExpr) (*JSONSchemaValidationReportFuncExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Schema = c.COWExpr(n.Schema)
	out.Document = c.COWExpr(n.Document)
	return &out
}

// COWRefOfJSONSearchExpr creates a deep clone of the input.
func (c cow) COWRefOfJSONSearchExpr(n *JSONSearchExpr) (*JSONSearchExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.JSONDoc = c.COWExpr(n.JSONDoc)
	out.OneOrAll = c.COWExpr(n.OneOrAll)
	out.SearchStr = c.COWExpr(n.SearchStr)
	out.EscapeChar = c.COWExpr(n.EscapeChar)
	out.PathList = c.COWSliceOfExpr(n.PathList)
	return &out
}

// COWRefOfJSONStorageFreeExpr creates a deep clone of the input.
func (c cow) COWRefOfJSONStorageFreeExpr(n *JSONStorageFreeExpr) (*JSONStorageFreeExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.JSONVal = c.COWExpr(n.JSONVal)
	return &out
}

// COWRefOfJSONStorageSizeExpr creates a deep clone of the input.
func (c cow) COWRefOfJSONStorageSizeExpr(n *JSONStorageSizeExpr) (*JSONStorageSizeExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.JSONVal = c.COWExpr(n.JSONVal)
	return &out
}

// COWRefOfJSONTableExpr creates a deep clone of the input.
func (c cow) COWRefOfJSONTableExpr(n *JSONTableExpr) (*JSONTableExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = c.COWExpr(n.Expr)
	out.Alias = c.COWIdentifierCS(n.Alias)
	out.Filter = c.COWExpr(n.Filter)
	out.Columns = c.COWSliceOfRefOfJtColumnDefinition(n.Columns)
	return &out
}

// COWRefOfJSONUnquoteExpr creates a deep clone of the input.
func (c cow) COWRefOfJSONUnquoteExpr(n *JSONUnquoteExpr) (*JSONUnquoteExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.JSONValue = c.COWExpr(n.JSONValue)
	return &out
}

// COWRefOfJSONValueExpr creates a deep clone of the input.
func (c cow) COWRefOfJSONValueExpr(n *JSONValueExpr) (*JSONValueExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.JSONDoc = c.COWExpr(n.JSONDoc)
	out.Path = c.COWExpr(n.Path)
	out.ReturningType = c.COWRefOfConvertType(n.ReturningType)
	out.EmptyOnResponse = c.COWRefOfJtOnResponse(n.EmptyOnResponse)
	out.ErrorOnResponse = c.COWRefOfJtOnResponse(n.ErrorOnResponse)
	return &out
}

// COWRefOfJSONValueMergeExpr creates a deep clone of the input.
func (c cow) COWRefOfJSONValueMergeExpr(n *JSONValueMergeExpr) (*JSONValueMergeExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.JSONDoc = c.COWExpr(n.JSONDoc)
	out.JSONDocList = c.COWExprs(n.JSONDocList)
	return &out
}

// COWRefOfJSONValueModifierExpr creates a deep clone of the input.
func (c cow) COWRefOfJSONValueModifierExpr(n *JSONValueModifierExpr) (*JSONValueModifierExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.JSONDoc = c.COWExpr(n.JSONDoc)
	out.Params = c.COWSliceOfRefOfJSONObjectParam(n.Params)
	return &out
}

// COWRefOfJoinCondition creates a deep clone of the input.
func (c cow) COWRefOfJoinCondition(n *JoinCondition) (*JoinCondition, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.On = c.COWExpr(n.On)
	out.Using = c.COWColumns(n.Using)
	return &out
}

// COWRefOfJoinTableExpr creates a deep clone of the input.
func (c cow) COWRefOfJoinTableExpr(n *JoinTableExpr) (*JoinTableExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.LeftExpr = c.COWTableExpr(n.LeftExpr)
	out.RightExpr = c.COWTableExpr(n.RightExpr)
	out.Condition = c.COWRefOfJoinCondition(n.Condition)
	return &out
}

// COWRefOfJtColumnDefinition creates a deep clone of the input.
func (c cow) COWRefOfJtColumnDefinition(n *JtColumnDefinition) (*JtColumnDefinition, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.JtOrdinal = c.COWRefOfJtOrdinalColDef(n.JtOrdinal)
	out.JtPath = c.COWRefOfJtPathColDef(n.JtPath)
	out.JtNestedPath = c.COWRefOfJtNestedPathColDef(n.JtNestedPath)
	return &out
}

// COWRefOfJtOnResponse creates a deep clone of the input.
func (c cow) COWRefOfJtOnResponse(n *JtOnResponse) (*JtOnResponse, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = c.COWExpr(n.Expr)
	return &out
}

// COWRefOfKeyState creates a deep clone of the input.
func (c cow) COWRefOfKeyState(n *KeyState) (*KeyState, bool) {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// COWRefOfLagLeadExpr creates a deep clone of the input.
func (c cow) COWRefOfLagLeadExpr(n *LagLeadExpr) (*LagLeadExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = c.COWExpr(n.Expr)
	out.N = c.COWExpr(n.N)
	out.Default = c.COWExpr(n.Default)
	out.OverClause = c.COWRefOfOverClause(n.OverClause)
	out.NullTreatmentClause = c.COWRefOfNullTreatmentClause(n.NullTreatmentClause)
	return &out
}

// COWRefOfLimit creates a deep clone of the input.
func (c cow) COWRefOfLimit(n *Limit) (*Limit, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Offset = c.COWExpr(n.Offset)
	out.Rowcount = c.COWExpr(n.Rowcount)
	return &out
}

// COWRefOfLiteral creates a deep clone of the input.
func (c cow) COWRefOfLiteral(n *Literal) (*Literal, bool) {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// COWRefOfLoad creates a deep clone of the input.
func (c cow) COWRefOfLoad(n *Load) (*Load, bool) {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// COWRefOfLocateExpr creates a deep clone of the input.
func (c cow) COWRefOfLocateExpr(n *LocateExpr) (*LocateExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.SubStr = c.COWExpr(n.SubStr)
	out.Str = c.COWExpr(n.Str)
	out.Pos = c.COWExpr(n.Pos)
	return &out
}

// COWRefOfLockOption creates a deep clone of the input.
func (c cow) COWRefOfLockOption(n *LockOption) (*LockOption, bool) {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// COWRefOfLockTables creates a deep clone of the input.
func (c cow) COWRefOfLockTables(n *LockTables) (*LockTables, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Tables = c.COWTableAndLockTypes(n.Tables)
	return &out
}

// COWRefOfLockingFunc creates a deep clone of the input.
func (c cow) COWRefOfLockingFunc(n *LockingFunc) (*LockingFunc, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = c.COWExpr(n.Name)
	out.Timeout = c.COWExpr(n.Timeout)
	return &out
}

// COWRefOfMatchExpr creates a deep clone of the input.
func (c cow) COWRefOfMatchExpr(n *MatchExpr) (*MatchExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Columns = c.COWSliceOfRefOfColName(n.Columns)
	out.Expr = c.COWExpr(n.Expr)
	return &out
}

// COWRefOfMax creates a deep clone of the input.
func (c cow) COWRefOfMax(n *Max) (*Max, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Arg = c.COWExpr(n.Arg)
	return &out
}

// COWRefOfMemberOfExpr creates a deep clone of the input.
func (c cow) COWRefOfMemberOfExpr(n *MemberOfExpr) (*MemberOfExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Value = c.COWExpr(n.Value)
	out.JSONArr = c.COWExpr(n.JSONArr)
	return &out
}

// COWRefOfMin creates a deep clone of the input.
func (c cow) COWRefOfMin(n *Min) (*Min, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Arg = c.COWExpr(n.Arg)
	return &out
}

// COWRefOfModifyColumn creates a deep clone of the input.
func (c cow) COWRefOfModifyColumn(n *ModifyColumn) (*ModifyColumn, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.NewColDefinition = c.COWRefOfColumnDefinition(n.NewColDefinition)
	out.After = c.COWRefOfColName(n.After)
	return &out
}

// COWRefOfNTHValueExpr creates a deep clone of the input.
func (c cow) COWRefOfNTHValueExpr(n *NTHValueExpr) (*NTHValueExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = c.COWExpr(n.Expr)
	out.N = c.COWExpr(n.N)
	out.OverClause = c.COWRefOfOverClause(n.OverClause)
	out.FromFirstLastClause = c.COWRefOfFromFirstLastClause(n.FromFirstLastClause)
	out.NullTreatmentClause = c.COWRefOfNullTreatmentClause(n.NullTreatmentClause)
	return &out
}

// COWRefOfNamedWindow creates a deep clone of the input.
func (c cow) COWRefOfNamedWindow(n *NamedWindow) (*NamedWindow, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Windows = c.COWWindowDefinitions(n.Windows)
	return &out
}

// COWNamedWindows creates a deep clone of the input.
func COWNamedWindows(n NamedWindows) NamedWindows {
	if n == nil {
		return nil
	}
	res := make(NamedWindows, len(n))
	for i, x := range n {
		res[i] = c.COWRefOfNamedWindow(x)
	}
	return res
}

// COWRefOfNextval creates a deep clone of the input.
func (c cow) COWRefOfNextval(n *Nextval) (*Nextval, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = c.COWExpr(n.Expr)
	return &out
}

// COWRefOfNotExpr creates a deep clone of the input.
func (c cow) COWRefOfNotExpr(n *NotExpr) (*NotExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = c.COWExpr(n.Expr)
	return &out
}

// COWRefOfNtileExpr creates a deep clone of the input.
func (c cow) COWRefOfNtileExpr(n *NtileExpr) (*NtileExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.N = c.COWExpr(n.N)
	out.OverClause = c.COWRefOfOverClause(n.OverClause)
	return &out
}

// COWRefOfNullTreatmentClause creates a deep clone of the input.
func (c cow) COWRefOfNullTreatmentClause(n *NullTreatmentClause) (*NullTreatmentClause, bool) {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// COWRefOfNullVal creates a deep clone of the input.
func (c cow) COWRefOfNullVal(n *NullVal) (*NullVal, bool) {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// COWRefOfOffset creates a deep clone of the input.
func (c cow) COWRefOfOffset(n *Offset) (*Offset, bool) {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// COWOnDup creates a deep clone of the input.
func COWOnDup(n OnDup) OnDup {
	if n == nil {
		return nil
	}
	res := make(OnDup, len(n))
	for i, x := range n {
		res[i] = c.COWRefOfUpdateExpr(x)
	}
	return res
}

// COWRefOfOptLike creates a deep clone of the input.
func (c cow) COWRefOfOptLike(n *OptLike) (*OptLike, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.LikeTable = c.COWTableName(n.LikeTable)
	return &out
}

// COWRefOfOrExpr creates a deep clone of the input.
func (c cow) COWRefOfOrExpr(n *OrExpr) (*OrExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Left = c.COWExpr(n.Left)
	out.Right = c.COWExpr(n.Right)
	return &out
}

// COWRefOfOrder creates a deep clone of the input.
func (c cow) COWRefOfOrder(n *Order) (*Order, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = c.COWExpr(n.Expr)
	return &out
}

// COWOrderBy creates a deep clone of the input.
func COWOrderBy(n OrderBy) OrderBy {
	if n == nil {
		return nil
	}
	res := make(OrderBy, len(n))
	for i, x := range n {
		res[i] = c.COWRefOfOrder(x)
	}
	return res
}

// COWRefOfOrderByOption creates a deep clone of the input.
func (c cow) COWRefOfOrderByOption(n *OrderByOption) (*OrderByOption, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Cols = c.COWColumns(n.Cols)
	return &out
}

// COWRefOfOtherAdmin creates a deep clone of the input.
func (c cow) COWRefOfOtherAdmin(n *OtherAdmin) (*OtherAdmin, bool) {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// COWRefOfOtherRead creates a deep clone of the input.
func (c cow) COWRefOfOtherRead(n *OtherRead) (*OtherRead, bool) {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// COWRefOfOverClause creates a deep clone of the input.
func (c cow) COWRefOfOverClause(n *OverClause) (*OverClause, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.WindowName = c.COWIdentifierCI(n.WindowName)
	out.WindowSpec = c.COWRefOfWindowSpecification(n.WindowSpec)
	return &out
}

// COWRefOfParenTableExpr creates a deep clone of the input.
func (c cow) COWRefOfParenTableExpr(n *ParenTableExpr) (*ParenTableExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Exprs = c.COWTableExprs(n.Exprs)
	return &out
}

// COWRefOfParsedComments creates a deep clone of the input.
func (c cow) COWRefOfParsedComments(n *ParsedComments) (*ParsedComments, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.comments = c.COWComments(n.comments)
	return &out
}

// COWRefOfPartitionDefinition creates a deep clone of the input.
func (c cow) COWRefOfPartitionDefinition(n *PartitionDefinition) (*PartitionDefinition, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = c.COWIdentifierCI(n.Name)
	out.Options = c.COWRefOfPartitionDefinitionOptions(n.Options)
	return &out
}

// COWRefOfPartitionDefinitionOptions creates a deep clone of the input.
func (c cow) COWRefOfPartitionDefinitionOptions(n *PartitionDefinitionOptions) (*PartitionDefinitionOptions, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.ValueRange = c.COWRefOfPartitionValueRange(n.ValueRange)
	out.Comment = c.COWRefOfLiteral(n.Comment)
	out.Engine = c.COWRefOfPartitionEngine(n.Engine)
	out.DataDirectory = c.COWRefOfLiteral(n.DataDirectory)
	out.IndexDirectory = c.COWRefOfLiteral(n.IndexDirectory)
	out.MaxRows = c.COWRefOfInt(n.MaxRows)
	out.MinRows = c.COWRefOfInt(n.MinRows)
	out.SubPartitionDefinitions = c.COWSubPartitionDefinitions(n.SubPartitionDefinitions)
	return &out
}

// COWRefOfPartitionEngine creates a deep clone of the input.
func (c cow) COWRefOfPartitionEngine(n *PartitionEngine) (*PartitionEngine, bool) {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// COWRefOfPartitionOption creates a deep clone of the input.
func (c cow) COWRefOfPartitionOption(n *PartitionOption) (*PartitionOption, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.ColList = c.COWColumns(n.ColList)
	out.Expr = c.COWExpr(n.Expr)
	out.SubPartition = c.COWRefOfSubPartition(n.SubPartition)
	out.Definitions = c.COWSliceOfRefOfPartitionDefinition(n.Definitions)
	return &out
}

// COWRefOfPartitionSpec creates a deep clone of the input.
func (c cow) COWRefOfPartitionSpec(n *PartitionSpec) (*PartitionSpec, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Names = c.COWPartitions(n.Names)
	out.Number = c.COWRefOfLiteral(n.Number)
	out.TableName = c.COWTableName(n.TableName)
	out.Definitions = c.COWSliceOfRefOfPartitionDefinition(n.Definitions)
	return &out
}

// COWRefOfPartitionValueRange creates a deep clone of the input.
func (c cow) COWRefOfPartitionValueRange(n *PartitionValueRange) (*PartitionValueRange, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Range = c.COWValTuple(n.Range)
	return &out
}

// COWPartitions creates a deep clone of the input.
func COWPartitions(n Partitions) Partitions {
	if n == nil {
		return nil
	}
	res := make(Partitions, len(n))
	for i, x := range n {
		res[i] = c.COWIdentifierCI(x)
	}
	return res
}

// COWRefOfPerformanceSchemaFuncExpr creates a deep clone of the input.
func (c cow) COWRefOfPerformanceSchemaFuncExpr(n *PerformanceSchemaFuncExpr) (*PerformanceSchemaFuncExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Argument = c.COWExpr(n.Argument)
	return &out
}

// COWRefOfPrepareStmt creates a deep clone of the input.
func (c cow) COWRefOfPrepareStmt(n *PrepareStmt) (*PrepareStmt, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = c.COWIdentifierCI(n.Name)
	out.Statement = c.COWExpr(n.Statement)
	out.Comments = c.COWRefOfParsedComments(n.Comments)
	return &out
}

// COWRefOfReferenceDefinition creates a deep clone of the input.
func (c cow) COWRefOfReferenceDefinition(n *ReferenceDefinition) (*ReferenceDefinition, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.ReferencedTable = c.COWTableName(n.ReferencedTable)
	out.ReferencedColumns = c.COWColumns(n.ReferencedColumns)
	return &out
}

// COWRefOfRegexpInstrExpr creates a deep clone of the input.
func (c cow) COWRefOfRegexpInstrExpr(n *RegexpInstrExpr) (*RegexpInstrExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = c.COWExpr(n.Expr)
	out.Pattern = c.COWExpr(n.Pattern)
	out.Position = c.COWExpr(n.Position)
	out.Occurrence = c.COWExpr(n.Occurrence)
	out.ReturnOption = c.COWExpr(n.ReturnOption)
	out.MatchType = c.COWExpr(n.MatchType)
	return &out
}

// COWRefOfRegexpLikeExpr creates a deep clone of the input.
func (c cow) COWRefOfRegexpLikeExpr(n *RegexpLikeExpr) (*RegexpLikeExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = c.COWExpr(n.Expr)
	out.Pattern = c.COWExpr(n.Pattern)
	out.MatchType = c.COWExpr(n.MatchType)
	return &out
}

// COWRefOfRegexpReplaceExpr creates a deep clone of the input.
func (c cow) COWRefOfRegexpReplaceExpr(n *RegexpReplaceExpr) (*RegexpReplaceExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = c.COWExpr(n.Expr)
	out.Pattern = c.COWExpr(n.Pattern)
	out.Repl = c.COWExpr(n.Repl)
	out.Occurrence = c.COWExpr(n.Occurrence)
	out.Position = c.COWExpr(n.Position)
	out.MatchType = c.COWExpr(n.MatchType)
	return &out
}

// COWRefOfRegexpSubstrExpr creates a deep clone of the input.
func (c cow) COWRefOfRegexpSubstrExpr(n *RegexpSubstrExpr) (*RegexpSubstrExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = c.COWExpr(n.Expr)
	out.Pattern = c.COWExpr(n.Pattern)
	out.Occurrence = c.COWExpr(n.Occurrence)
	out.Position = c.COWExpr(n.Position)
	out.MatchType = c.COWExpr(n.MatchType)
	return &out
}

// COWRefOfRelease creates a deep clone of the input.
func (c cow) COWRefOfRelease(n *Release) (*Release, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = c.COWIdentifierCI(n.Name)
	return &out
}

// COWRefOfRenameColumn creates a deep clone of the input.
func (c cow) COWRefOfRenameColumn(n *RenameColumn) (*RenameColumn, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.OldName = c.COWRefOfColName(n.OldName)
	out.NewName = c.COWRefOfColName(n.NewName)
	return &out
}

// COWRefOfRenameIndex creates a deep clone of the input.
func (c cow) COWRefOfRenameIndex(n *RenameIndex) (*RenameIndex, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.OldName = c.COWIdentifierCI(n.OldName)
	out.NewName = c.COWIdentifierCI(n.NewName)
	return &out
}

// COWRefOfRenameTable creates a deep clone of the input.
func (c cow) COWRefOfRenameTable(n *RenameTable) (*RenameTable, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.TablePairs = c.COWSliceOfRefOfRenameTablePair(n.TablePairs)
	return &out
}

// COWRefOfRenameTableName creates a deep clone of the input.
func (c cow) COWRefOfRenameTableName(n *RenameTableName) (*RenameTableName, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Table = c.COWTableName(n.Table)
	return &out
}

// COWRefOfRevertMigration creates a deep clone of the input.
func (c cow) COWRefOfRevertMigration(n *RevertMigration) (*RevertMigration, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Comments = c.COWRefOfParsedComments(n.Comments)
	return &out
}

// COWRefOfRollback creates a deep clone of the input.
func (c cow) COWRefOfRollback(n *Rollback) (*Rollback, bool) {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// COWRootNode creates a deep clone of the input.
func COWRootNode(n RootNode) RootNode {
	return *c.COWRefOfRootNode(&n)
}

// COWRefOfSRollback creates a deep clone of the input.
func (c cow) COWRefOfSRollback(n *SRollback) (*SRollback, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = c.COWIdentifierCI(n.Name)
	return &out
}

// COWRefOfSavepoint creates a deep clone of the input.
func (c cow) COWRefOfSavepoint(n *Savepoint) (*Savepoint, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = c.COWIdentifierCI(n.Name)
	return &out
}

// COWRefOfSelect creates a deep clone of the input.
func (c cow) COWRefOfSelect(n *Select) (*Select, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Cache = c.COWRefOfBool(n.Cache)
	out.From = c.COWSliceOfTableExpr(n.From)
	out.Comments = c.COWRefOfParsedComments(n.Comments)
	out.SelectExprs = c.COWSelectExprs(n.SelectExprs)
	out.Where = c.COWRefOfWhere(n.Where)
	out.With = c.COWRefOfWith(n.With)
	out.GroupBy = c.COWGroupBy(n.GroupBy)
	out.Having = c.COWRefOfWhere(n.Having)
	out.Windows = c.COWNamedWindows(n.Windows)
	out.OrderBy = c.COWOrderBy(n.OrderBy)
	out.Limit = c.COWRefOfLimit(n.Limit)
	out.Into = c.COWRefOfSelectInto(n.Into)
	return &out
}

// COWSelectExprs creates a deep clone of the input.
func COWSelectExprs(n SelectExprs) SelectExprs {
	if n == nil {
		return nil
	}
	res := make(SelectExprs, len(n))
	for i, x := range n {
		res[i] = c.COWSelectExpr(x)
	}
	return res
}

// COWRefOfSelectInto creates a deep clone of the input.
func (c cow) COWRefOfSelectInto(n *SelectInto) (*SelectInto, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Charset = c.COWColumnCharset(n.Charset)
	return &out
}

// COWRefOfSet creates a deep clone of the input.
func (c cow) COWRefOfSet(n *Set) (*Set, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Comments = c.COWRefOfParsedComments(n.Comments)
	out.Exprs = c.COWSetExprs(n.Exprs)
	return &out
}

// COWRefOfSetExpr creates a deep clone of the input.
func (c cow) COWRefOfSetExpr(n *SetExpr) (*SetExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Var = c.COWRefOfVariable(n.Var)
	out.Expr = c.COWExpr(n.Expr)
	return &out
}

// COWSetExprs creates a deep clone of the input.
func COWSetExprs(n SetExprs) SetExprs {
	if n == nil {
		return nil
	}
	res := make(SetExprs, len(n))
	for i, x := range n {
		res[i] = c.COWRefOfSetExpr(x)
	}
	return res
}

// COWRefOfShow creates a deep clone of the input.
func (c cow) COWRefOfShow(n *Show) (*Show, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Internal = c.COWShowInternal(n.Internal)
	return &out
}

// COWRefOfShowBasic creates a deep clone of the input.
func (c cow) COWRefOfShowBasic(n *ShowBasic) (*ShowBasic, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Tbl = c.COWTableName(n.Tbl)
	out.DbName = c.COWIdentifierCS(n.DbName)
	out.Filter = c.COWRefOfShowFilter(n.Filter)
	return &out
}

// COWRefOfShowCreate creates a deep clone of the input.
func (c cow) COWRefOfShowCreate(n *ShowCreate) (*ShowCreate, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Op = c.COWTableName(n.Op)
	return &out
}

// COWRefOfShowFilter creates a deep clone of the input.
func (c cow) COWRefOfShowFilter(n *ShowFilter) (*ShowFilter, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Filter = c.COWExpr(n.Filter)
	return &out
}

// COWRefOfShowMigrationLogs creates a deep clone of the input.
func (c cow) COWRefOfShowMigrationLogs(n *ShowMigrationLogs) (*ShowMigrationLogs, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Comments = c.COWRefOfParsedComments(n.Comments)
	return &out
}

// COWRefOfShowOther creates a deep clone of the input.
func (c cow) COWRefOfShowOther(n *ShowOther) (*ShowOther, bool) {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// COWRefOfShowThrottledApps creates a deep clone of the input.
func (c cow) COWRefOfShowThrottledApps(n *ShowThrottledApps) (*ShowThrottledApps, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Comments = c.COWComments(n.Comments)
	return &out
}

// COWRefOfShowThrottlerStatus creates a deep clone of the input.
func (c cow) COWRefOfShowThrottlerStatus(n *ShowThrottlerStatus) (*ShowThrottlerStatus, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Comments = c.COWComments(n.Comments)
	return &out
}

// COWRefOfStarExpr creates a deep clone of the input.
func (c cow) COWRefOfStarExpr(n *StarExpr) (*StarExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.TableName = c.COWTableName(n.TableName)
	return &out
}

// COWRefOfStd creates a deep clone of the input.
func (c cow) COWRefOfStd(n *Std) (*Std, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Arg = c.COWExpr(n.Arg)
	return &out
}

// COWRefOfStdDev creates a deep clone of the input.
func (c cow) COWRefOfStdDev(n *StdDev) (*StdDev, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Arg = c.COWExpr(n.Arg)
	return &out
}

// COWRefOfStdPop creates a deep clone of the input.
func (c cow) COWRefOfStdPop(n *StdPop) (*StdPop, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Arg = c.COWExpr(n.Arg)
	return &out
}

// COWRefOfStdSamp creates a deep clone of the input.
func (c cow) COWRefOfStdSamp(n *StdSamp) (*StdSamp, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Arg = c.COWExpr(n.Arg)
	return &out
}

// COWRefOfStream creates a deep clone of the input.
func (c cow) COWRefOfStream(n *Stream) (*Stream, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Comments = c.COWRefOfParsedComments(n.Comments)
	out.SelectExpr = c.COWSelectExpr(n.SelectExpr)
	out.Table = c.COWTableName(n.Table)
	return &out
}

// COWRefOfSubPartition creates a deep clone of the input.
func (c cow) COWRefOfSubPartition(n *SubPartition) (*SubPartition, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.ColList = c.COWColumns(n.ColList)
	out.Expr = c.COWExpr(n.Expr)
	return &out
}

// COWRefOfSubPartitionDefinition creates a deep clone of the input.
func (c cow) COWRefOfSubPartitionDefinition(n *SubPartitionDefinition) (*SubPartitionDefinition, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = c.COWIdentifierCI(n.Name)
	out.Options = c.COWRefOfSubPartitionDefinitionOptions(n.Options)
	return &out
}

// COWRefOfSubPartitionDefinitionOptions creates a deep clone of the input.
func (c cow) COWRefOfSubPartitionDefinitionOptions(n *SubPartitionDefinitionOptions) (*SubPartitionDefinitionOptions, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Comment = c.COWRefOfLiteral(n.Comment)
	out.Engine = c.COWRefOfPartitionEngine(n.Engine)
	out.DataDirectory = c.COWRefOfLiteral(n.DataDirectory)
	out.IndexDirectory = c.COWRefOfLiteral(n.IndexDirectory)
	out.MaxRows = c.COWRefOfInt(n.MaxRows)
	out.MinRows = c.COWRefOfInt(n.MinRows)
	return &out
}

// COWSubPartitionDefinitions creates a deep clone of the input.
func COWSubPartitionDefinitions(n SubPartitionDefinitions) SubPartitionDefinitions {
	if n == nil {
		return nil
	}
	res := make(SubPartitionDefinitions, len(n))
	for i, x := range n {
		res[i] = c.COWRefOfSubPartitionDefinition(x)
	}
	return res
}

// COWRefOfSubquery creates a deep clone of the input.
func (c cow) COWRefOfSubquery(n *Subquery) (*Subquery, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Select = c.COWSelectStatement(n.Select)
	return &out
}

// COWRefOfSubstrExpr creates a deep clone of the input.
func (c cow) COWRefOfSubstrExpr(n *SubstrExpr) (*SubstrExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = c.COWExpr(n.Name)
	out.From = c.COWExpr(n.From)
	out.To = c.COWExpr(n.To)
	return &out
}

// COWRefOfSum creates a deep clone of the input.
func (c cow) COWRefOfSum(n *Sum) (*Sum, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Arg = c.COWExpr(n.Arg)
	return &out
}

// COWTableExprs creates a deep clone of the input.
func COWTableExprs(n TableExprs) TableExprs {
	if n == nil {
		return nil
	}
	res := make(TableExprs, len(n))
	for i, x := range n {
		res[i] = c.COWTableExpr(x)
	}
	return res
}

// COWTableName creates a deep clone of the input.
func COWTableName(n TableName) TableName {
	return *c.COWRefOfTableName(&n)
}

// COWTableNames creates a deep clone of the input.
func COWTableNames(n TableNames) TableNames {
	if n == nil {
		return nil
	}
	res := make(TableNames, len(n))
	for i, x := range n {
		res[i] = c.COWTableName(x)
	}
	return res
}

// COWTableOptions creates a deep clone of the input.
func COWTableOptions(n TableOptions) TableOptions {
	if n == nil {
		return nil
	}
	res := make(TableOptions, len(n))
	for i, x := range n {
		res[i] = c.COWRefOfTableOption(x)
	}
	return res
}

// COWRefOfTableSpec creates a deep clone of the input.
func (c cow) COWRefOfTableSpec(n *TableSpec) (*TableSpec, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Columns = c.COWSliceOfRefOfColumnDefinition(n.Columns)
	out.Indexes = c.COWSliceOfRefOfIndexDefinition(n.Indexes)
	out.Constraints = c.COWSliceOfRefOfConstraintDefinition(n.Constraints)
	out.Options = c.COWTableOptions(n.Options)
	out.PartitionOption = c.COWRefOfPartitionOption(n.PartitionOption)
	return &out
}

// COWRefOfTablespaceOperation creates a deep clone of the input.
func (c cow) COWRefOfTablespaceOperation(n *TablespaceOperation) (*TablespaceOperation, bool) {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// COWRefOfTimestampFuncExpr creates a deep clone of the input.
func (c cow) COWRefOfTimestampFuncExpr(n *TimestampFuncExpr) (*TimestampFuncExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr1 = c.COWExpr(n.Expr1)
	out.Expr2 = c.COWExpr(n.Expr2)
	return &out
}

// COWRefOfTrimFuncExpr creates a deep clone of the input.
func (c cow) COWRefOfTrimFuncExpr(n *TrimFuncExpr) (*TrimFuncExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.TrimArg = c.COWExpr(n.TrimArg)
	out.StringArg = c.COWExpr(n.StringArg)
	return &out
}

// COWRefOfTruncateTable creates a deep clone of the input.
func (c cow) COWRefOfTruncateTable(n *TruncateTable) (*TruncateTable, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Table = c.COWTableName(n.Table)
	return &out
}

// COWRefOfUnaryExpr creates a deep clone of the input.
func (c cow) COWRefOfUnaryExpr(n *UnaryExpr) (*UnaryExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = c.COWExpr(n.Expr)
	return &out
}

// COWRefOfUnion creates a deep clone of the input.
func (c cow) COWRefOfUnion(n *Union) (*Union, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Left = c.COWSelectStatement(n.Left)
	out.Right = c.COWSelectStatement(n.Right)
	out.OrderBy = c.COWOrderBy(n.OrderBy)
	out.With = c.COWRefOfWith(n.With)
	out.Limit = c.COWRefOfLimit(n.Limit)
	out.Into = c.COWRefOfSelectInto(n.Into)
	return &out
}

// COWRefOfUnlockTables creates a deep clone of the input.
func (c cow) COWRefOfUnlockTables(n *UnlockTables) (*UnlockTables, bool) {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// COWRefOfUpdate creates a deep clone of the input.
func (c cow) COWRefOfUpdate(n *Update) (*Update, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.With = c.COWRefOfWith(n.With)
	out.Comments = c.COWRefOfParsedComments(n.Comments)
	out.TableExprs = c.COWTableExprs(n.TableExprs)
	out.Exprs = c.COWUpdateExprs(n.Exprs)
	out.Where = c.COWRefOfWhere(n.Where)
	out.OrderBy = c.COWOrderBy(n.OrderBy)
	out.Limit = c.COWRefOfLimit(n.Limit)
	return &out
}

// COWRefOfUpdateExpr creates a deep clone of the input.
func (c cow) COWRefOfUpdateExpr(n *UpdateExpr) (*UpdateExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = c.COWRefOfColName(n.Name)
	out.Expr = c.COWExpr(n.Expr)
	return &out
}

// COWUpdateExprs creates a deep clone of the input.
func COWUpdateExprs(n UpdateExprs) UpdateExprs {
	if n == nil {
		return nil
	}
	res := make(UpdateExprs, len(n))
	for i, x := range n {
		res[i] = c.COWRefOfUpdateExpr(x)
	}
	return res
}

// COWRefOfUpdateXMLExpr creates a deep clone of the input.
func (c cow) COWRefOfUpdateXMLExpr(n *UpdateXMLExpr) (*UpdateXMLExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Target = c.COWExpr(n.Target)
	out.XPathExpr = c.COWExpr(n.XPathExpr)
	out.NewXML = c.COWExpr(n.NewXML)
	return &out
}

// COWRefOfUse creates a deep clone of the input.
func (c cow) COWRefOfUse(n *Use) (*Use, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.DBName = c.COWIdentifierCS(n.DBName)
	return &out
}

// COWRefOfVExplainStmt creates a deep clone of the input.
func (c cow) COWRefOfVExplainStmt(n *VExplainStmt) (*VExplainStmt, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Statement = c.COWStatement(n.Statement)
	out.Comments = c.COWRefOfParsedComments(n.Comments)
	return &out
}

// COWRefOfVStream creates a deep clone of the input.
func (c cow) COWRefOfVStream(n *VStream) (*VStream, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Comments = c.COWRefOfParsedComments(n.Comments)
	out.SelectExpr = c.COWSelectExpr(n.SelectExpr)
	out.Table = c.COWTableName(n.Table)
	out.Where = c.COWRefOfWhere(n.Where)
	out.Limit = c.COWRefOfLimit(n.Limit)
	return &out
}

// COWValTuple creates a deep clone of the input.
func COWValTuple(n ValTuple) ValTuple {
	if n == nil {
		return nil
	}
	res := make(ValTuple, len(n))
	for i, x := range n {
		res[i] = c.COWExpr(x)
	}
	return res
}

// COWRefOfValidation creates a deep clone of the input.
func (c cow) COWRefOfValidation(n *Validation) (*Validation, bool) {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// COWValues creates a deep clone of the input.
func COWValues(n Values) Values {
	if n == nil {
		return nil
	}
	res := make(Values, len(n))
	for i, x := range n {
		res[i] = c.COWValTuple(x)
	}
	return res
}

// COWRefOfValuesFuncExpr creates a deep clone of the input.
func (c cow) COWRefOfValuesFuncExpr(n *ValuesFuncExpr) (*ValuesFuncExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = c.COWRefOfColName(n.Name)
	return &out
}

// COWRefOfVarPop creates a deep clone of the input.
func (c cow) COWRefOfVarPop(n *VarPop) (*VarPop, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Arg = c.COWExpr(n.Arg)
	return &out
}

// COWRefOfVarSamp creates a deep clone of the input.
func (c cow) COWRefOfVarSamp(n *VarSamp) (*VarSamp, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Arg = c.COWExpr(n.Arg)
	return &out
}

// COWRefOfVariable creates a deep clone of the input.
func (c cow) COWRefOfVariable(n *Variable) (*Variable, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = c.COWIdentifierCI(n.Name)
	return &out
}

// COWRefOfVariance creates a deep clone of the input.
func (c cow) COWRefOfVariance(n *Variance) (*Variance, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Arg = c.COWExpr(n.Arg)
	return &out
}

// COWVindexParam creates a deep clone of the input.
func COWVindexParam(n VindexParam) VindexParam {
	return *c.COWRefOfVindexParam(&n)
}

// COWRefOfVindexSpec creates a deep clone of the input.
func (c cow) COWRefOfVindexSpec(n *VindexSpec) (*VindexSpec, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = c.COWIdentifierCI(n.Name)
	out.Type = c.COWIdentifierCI(n.Type)
	out.Params = c.COWSliceOfVindexParam(n.Params)
	return &out
}

// COWRefOfWeightStringFuncExpr creates a deep clone of the input.
func (c cow) COWRefOfWeightStringFuncExpr(n *WeightStringFuncExpr) (*WeightStringFuncExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = c.COWExpr(n.Expr)
	out.As = c.COWRefOfConvertType(n.As)
	return &out
}

// COWRefOfWhen creates a deep clone of the input.
func (c cow) COWRefOfWhen(n *When) (*When, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Cond = c.COWExpr(n.Cond)
	out.Val = c.COWExpr(n.Val)
	return &out
}

// COWRefOfWhere creates a deep clone of the input.
func (c cow) COWRefOfWhere(n *Where) (*Where, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = c.COWExpr(n.Expr)
	return &out
}

// COWRefOfWindowDefinition creates a deep clone of the input.
func (c cow) COWRefOfWindowDefinition(n *WindowDefinition) (*WindowDefinition, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = c.COWIdentifierCI(n.Name)
	out.WindowSpec = c.COWRefOfWindowSpecification(n.WindowSpec)
	return &out
}

// COWWindowDefinitions creates a deep clone of the input.
func COWWindowDefinitions(n WindowDefinitions) WindowDefinitions {
	if n == nil {
		return nil
	}
	res := make(WindowDefinitions, len(n))
	for i, x := range n {
		res[i] = c.COWRefOfWindowDefinition(x)
	}
	return res
}

// COWRefOfWindowSpecification creates a deep clone of the input.
func (c cow) COWRefOfWindowSpecification(n *WindowSpecification) (*WindowSpecification, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = c.COWIdentifierCI(n.Name)
	out.PartitionClause = c.COWExprs(n.PartitionClause)
	out.OrderClause = c.COWOrderBy(n.OrderClause)
	out.FrameClause = c.COWRefOfFrameClause(n.FrameClause)
	return &out
}

// COWRefOfWith creates a deep clone of the input.
func (c cow) COWRefOfWith(n *With) (*With, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.ctes = c.COWSliceOfRefOfCommonTableExpr(n.ctes)
	return &out
}

// COWRefOfXorExpr creates a deep clone of the input.
func (c cow) COWRefOfXorExpr(n *XorExpr) (*XorExpr, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Left = c.COWExpr(n.Left)
	out.Right = c.COWExpr(n.Right)
	return &out
}

// COWAggrFunc creates a deep clone of the input.
func (c cow) COWAggrFunc(in AggrFunc) (AggrFunc, bool) {
	if in == nil {
		return nil, false
	}
	if c.old == in {
		return c.new, true
	}
	switch in := in.(type) {
	case *Avg:
		return c.COWRefOfAvg(in)
	case *BitAnd:
		return c.COWRefOfBitAnd(in)
	case *BitOr:
		return c.COWRefOfBitOr(in)
	case *BitXor:
		return c.COWRefOfBitXor(in)
	case *Count:
		return c.COWRefOfCount(in)
	case *CountStar:
		return c.COWRefOfCountStar(in)
	case *GroupConcatExpr:
		return c.COWRefOfGroupConcatExpr(in)
	case *Max:
		return c.COWRefOfMax(in)
	case *Min:
		return c.COWRefOfMin(in)
	case *Std:
		return c.COWRefOfStd(in)
	case *StdDev:
		return c.COWRefOfStdDev(in)
	case *StdPop:
		return c.COWRefOfStdPop(in)
	case *StdSamp:
		return c.COWRefOfStdSamp(in)
	case *Sum:
		return c.COWRefOfSum(in)
	case *VarPop:
		return c.COWRefOfVarPop(in)
	case *VarSamp:
		return c.COWRefOfVarSamp(in)
	case *Variance:
		return c.COWRefOfVariance(in)
	default:
		// this should never happen
		return nil
	}
}

// COWAlterOption creates a deep clone of the input.
func (c cow) COWAlterOption(in AlterOption) (AlterOption, bool) {
	if in == nil {
		return nil, false
	}
	if c.old == in {
		return c.new, true
	}
	switch in := in.(type) {
	case *AddColumns:
		return c.COWRefOfAddColumns(in)
	case *AddConstraintDefinition:
		return c.COWRefOfAddConstraintDefinition(in)
	case *AddIndexDefinition:
		return c.COWRefOfAddIndexDefinition(in)
	case AlgorithmValue:
		return in
	case *AlterCharset:
		return c.COWRefOfAlterCharset(in)
	case *AlterCheck:
		return c.COWRefOfAlterCheck(in)
	case *AlterColumn:
		return c.COWRefOfAlterColumn(in)
	case *AlterIndex:
		return c.COWRefOfAlterIndex(in)
	case *ChangeColumn:
		return c.COWRefOfChangeColumn(in)
	case *DropColumn:
		return c.COWRefOfDropColumn(in)
	case *DropKey:
		return c.COWRefOfDropKey(in)
	case *Force:
		return c.COWRefOfForce(in)
	case *KeyState:
		return c.COWRefOfKeyState(in)
	case *LockOption:
		return c.COWRefOfLockOption(in)
	case *ModifyColumn:
		return c.COWRefOfModifyColumn(in)
	case *OrderByOption:
		return c.COWRefOfOrderByOption(in)
	case *RenameColumn:
		return c.COWRefOfRenameColumn(in)
	case *RenameIndex:
		return c.COWRefOfRenameIndex(in)
	case *RenameTableName:
		return c.COWRefOfRenameTableName(in)
	case TableOptions:
		return c.COWTableOptions(in)
	case *TablespaceOperation:
		return c.COWRefOfTablespaceOperation(in)
	case *Validation:
		return c.COWRefOfValidation(in)
	default:
		// this should never happen
		return nil
	}
}

// COWCallable creates a deep clone of the input.
func (c cow) COWCallable(in Callable) (Callable, bool) {
	if in == nil {
		return nil, false
	}
	if c.old == in {
		return c.new, true
	}
	switch in := in.(type) {
	case *ArgumentLessWindowExpr:
		return c.COWRefOfArgumentLessWindowExpr(in)
	case *Avg:
		return c.COWRefOfAvg(in)
	case *CharExpr:
		return c.COWRefOfCharExpr(in)
	case *ConvertExpr:
		return c.COWRefOfConvertExpr(in)
	case *ConvertUsingExpr:
		return c.COWRefOfConvertUsingExpr(in)
	case *Count:
		return c.COWRefOfCount(in)
	case *CountStar:
		return c.COWRefOfCountStar(in)
	case *CurTimeFuncExpr:
		return c.COWRefOfCurTimeFuncExpr(in)
	case *ExtractFuncExpr:
		return c.COWRefOfExtractFuncExpr(in)
	case *ExtractValueExpr:
		return c.COWRefOfExtractValueExpr(in)
	case *FirstOrLastValueExpr:
		return c.COWRefOfFirstOrLastValueExpr(in)
	case *FuncExpr:
		return c.COWRefOfFuncExpr(in)
	case *GTIDFuncExpr:
		return c.COWRefOfGTIDFuncExpr(in)
	case *GroupConcatExpr:
		return c.COWRefOfGroupConcatExpr(in)
	case *InsertExpr:
		return c.COWRefOfInsertExpr(in)
	case *IntervalFuncExpr:
		return c.COWRefOfIntervalFuncExpr(in)
	case *JSONArrayExpr:
		return c.COWRefOfJSONArrayExpr(in)
	case *JSONAttributesExpr:
		return c.COWRefOfJSONAttributesExpr(in)
	case *JSONContainsExpr:
		return c.COWRefOfJSONContainsExpr(in)
	case *JSONContainsPathExpr:
		return c.COWRefOfJSONContainsPathExpr(in)
	case *JSONExtractExpr:
		return c.COWRefOfJSONExtractExpr(in)
	case *JSONKeysExpr:
		return c.COWRefOfJSONKeysExpr(in)
	case *JSONObjectExpr:
		return c.COWRefOfJSONObjectExpr(in)
	case *JSONOverlapsExpr:
		return c.COWRefOfJSONOverlapsExpr(in)
	case *JSONPrettyExpr:
		return c.COWRefOfJSONPrettyExpr(in)
	case *JSONQuoteExpr:
		return c.COWRefOfJSONQuoteExpr(in)
	case *JSONRemoveExpr:
		return c.COWRefOfJSONRemoveExpr(in)
	case *JSONSchemaValidFuncExpr:
		return c.COWRefOfJSONSchemaValidFuncExpr(in)
	case *JSONSchemaValidationReportFuncExpr:
		return c.COWRefOfJSONSchemaValidationReportFuncExpr(in)
	case *JSONSearchExpr:
		return c.COWRefOfJSONSearchExpr(in)
	case *JSONStorageFreeExpr:
		return c.COWRefOfJSONStorageFreeExpr(in)
	case *JSONStorageSizeExpr:
		return c.COWRefOfJSONStorageSizeExpr(in)
	case *JSONUnquoteExpr:
		return c.COWRefOfJSONUnquoteExpr(in)
	case *JSONValueExpr:
		return c.COWRefOfJSONValueExpr(in)
	case *JSONValueMergeExpr:
		return c.COWRefOfJSONValueMergeExpr(in)
	case *JSONValueModifierExpr:
		return c.COWRefOfJSONValueModifierExpr(in)
	case *LagLeadExpr:
		return c.COWRefOfLagLeadExpr(in)
	case *LocateExpr:
		return c.COWRefOfLocateExpr(in)
	case *MatchExpr:
		return c.COWRefOfMatchExpr(in)
	case *Max:
		return c.COWRefOfMax(in)
	case *MemberOfExpr:
		return c.COWRefOfMemberOfExpr(in)
	case *Min:
		return c.COWRefOfMin(in)
	case *NTHValueExpr:
		return c.COWRefOfNTHValueExpr(in)
	case *NamedWindow:
		return c.COWRefOfNamedWindow(in)
	case *NtileExpr:
		return c.COWRefOfNtileExpr(in)
	case *PerformanceSchemaFuncExpr:
		return c.COWRefOfPerformanceSchemaFuncExpr(in)
	case *RegexpInstrExpr:
		return c.COWRefOfRegexpInstrExpr(in)
	case *RegexpLikeExpr:
		return c.COWRefOfRegexpLikeExpr(in)
	case *RegexpReplaceExpr:
		return c.COWRefOfRegexpReplaceExpr(in)
	case *RegexpSubstrExpr:
		return c.COWRefOfRegexpSubstrExpr(in)
	case *SubstrExpr:
		return c.COWRefOfSubstrExpr(in)
	case *Sum:
		return c.COWRefOfSum(in)
	case *TimestampFuncExpr:
		return c.COWRefOfTimestampFuncExpr(in)
	case *TrimFuncExpr:
		return c.COWRefOfTrimFuncExpr(in)
	case *UpdateXMLExpr:
		return c.COWRefOfUpdateXMLExpr(in)
	case *ValuesFuncExpr:
		return c.COWRefOfValuesFuncExpr(in)
	case *WeightStringFuncExpr:
		return c.COWRefOfWeightStringFuncExpr(in)
	default:
		// this should never happen
		return nil
	}
}

// COWColTuple creates a deep clone of the input.
func (c cow) COWColTuple(in ColTuple) (ColTuple, bool) {
	if in == nil {
		return nil, false
	}
	if c.old == in {
		return c.new, true
	}
	switch in := in.(type) {
	case ListArg:
		return in
	case *Subquery:
		return c.COWRefOfSubquery(in)
	case ValTuple:
		return c.COWValTuple(in)
	default:
		// this should never happen
		return nil
	}
}

// COWConstraintInfo creates a deep clone of the input.
func (c cow) COWConstraintInfo(in ConstraintInfo) (ConstraintInfo, bool) {
	if in == nil {
		return nil, false
	}
	if c.old == in {
		return c.new, true
	}
	switch in := in.(type) {
	case *CheckConstraintDefinition:
		return c.COWRefOfCheckConstraintDefinition(in)
	case *ForeignKeyDefinition:
		return c.COWRefOfForeignKeyDefinition(in)
	default:
		// this should never happen
		return nil
	}
}

// COWDBDDLStatement creates a deep clone of the input.
func (c cow) COWDBDDLStatement(in DBDDLStatement) (DBDDLStatement, bool) {
	if in == nil {
		return nil, false
	}
	if c.old == in {
		return c.new, true
	}
	switch in := in.(type) {
	case *AlterDatabase:
		return c.COWRefOfAlterDatabase(in)
	case *CreateDatabase:
		return c.COWRefOfCreateDatabase(in)
	case *DropDatabase:
		return c.COWRefOfDropDatabase(in)
	default:
		// this should never happen
		return nil
	}
}

// COWDDLStatement creates a deep clone of the input.
func (c cow) COWDDLStatement(in DDLStatement) (DDLStatement, bool) {
	if in == nil {
		return nil, false
	}
	if c.old == in {
		return c.new, true
	}
	switch in := in.(type) {
	case *AlterTable:
		return c.COWRefOfAlterTable(in)
	case *AlterView:
		return c.COWRefOfAlterView(in)
	case *CreateTable:
		return c.COWRefOfCreateTable(in)
	case *CreateView:
		return c.COWRefOfCreateView(in)
	case *DropTable:
		return c.COWRefOfDropTable(in)
	case *DropView:
		return c.COWRefOfDropView(in)
	case *RenameTable:
		return c.COWRefOfRenameTable(in)
	case *TruncateTable:
		return c.COWRefOfTruncateTable(in)
	default:
		// this should never happen
		return nil
	}
}

// COWExplain creates a deep clone of the input.
func (c cow) COWExplain(in Explain) (Explain, bool) {
	if in == nil {
		return nil, false
	}
	if c.old == in {
		return c.new, true
	}
	switch in := in.(type) {
	case *ExplainStmt:
		return c.COWRefOfExplainStmt(in)
	case *ExplainTab:
		return c.COWRefOfExplainTab(in)
	default:
		// this should never happen
		return nil
	}
}

// COWExpr creates a deep clone of the input.
func (c cow) COWExpr(in Expr) (Expr, bool) {
	if in == nil {
		return nil, false
	}
	if c.old == in {
		return c.new, true
	}
	switch in := in.(type) {
	case *AndExpr:
		return c.COWRefOfAndExpr(in)
	case Argument:
		return in
	case *ArgumentLessWindowExpr:
		return c.COWRefOfArgumentLessWindowExpr(in)
	case *Avg:
		return c.COWRefOfAvg(in)
	case *BetweenExpr:
		return c.COWRefOfBetweenExpr(in)
	case *BinaryExpr:
		return c.COWRefOfBinaryExpr(in)
	case *BitAnd:
		return c.COWRefOfBitAnd(in)
	case *BitOr:
		return c.COWRefOfBitOr(in)
	case *BitXor:
		return c.COWRefOfBitXor(in)
	case BoolVal:
		return in
	case *CaseExpr:
		return c.COWRefOfCaseExpr(in)
	case *CastExpr:
		return c.COWRefOfCastExpr(in)
	case *CharExpr:
		return c.COWRefOfCharExpr(in)
	case *ColName:
		return c.COWRefOfColName(in)
	case *CollateExpr:
		return c.COWRefOfCollateExpr(in)
	case *ComparisonExpr:
		return c.COWRefOfComparisonExpr(in)
	case *ConvertExpr:
		return c.COWRefOfConvertExpr(in)
	case *ConvertUsingExpr:
		return c.COWRefOfConvertUsingExpr(in)
	case *Count:
		return c.COWRefOfCount(in)
	case *CountStar:
		return c.COWRefOfCountStar(in)
	case *CurTimeFuncExpr:
		return c.COWRefOfCurTimeFuncExpr(in)
	case *Default:
		return c.COWRefOfDefault(in)
	case *ExistsExpr:
		return c.COWRefOfExistsExpr(in)
	case *ExtractFuncExpr:
		return c.COWRefOfExtractFuncExpr(in)
	case *ExtractValueExpr:
		return c.COWRefOfExtractValueExpr(in)
	case *ExtractedSubquery:
		return c.COWRefOfExtractedSubquery(in)
	case *FirstOrLastValueExpr:
		return c.COWRefOfFirstOrLastValueExpr(in)
	case *FuncExpr:
		return c.COWRefOfFuncExpr(in)
	case *GTIDFuncExpr:
		return c.COWRefOfGTIDFuncExpr(in)
	case *GroupConcatExpr:
		return c.COWRefOfGroupConcatExpr(in)
	case *InsertExpr:
		return c.COWRefOfInsertExpr(in)
	case *IntervalExpr:
		return c.COWRefOfIntervalExpr(in)
	case *IntervalFuncExpr:
		return c.COWRefOfIntervalFuncExpr(in)
	case *IntroducerExpr:
		return c.COWRefOfIntroducerExpr(in)
	case *IsExpr:
		return c.COWRefOfIsExpr(in)
	case *JSONArrayExpr:
		return c.COWRefOfJSONArrayExpr(in)
	case *JSONAttributesExpr:
		return c.COWRefOfJSONAttributesExpr(in)
	case *JSONContainsExpr:
		return c.COWRefOfJSONContainsExpr(in)
	case *JSONContainsPathExpr:
		return c.COWRefOfJSONContainsPathExpr(in)
	case *JSONExtractExpr:
		return c.COWRefOfJSONExtractExpr(in)
	case *JSONKeysExpr:
		return c.COWRefOfJSONKeysExpr(in)
	case *JSONObjectExpr:
		return c.COWRefOfJSONObjectExpr(in)
	case *JSONOverlapsExpr:
		return c.COWRefOfJSONOverlapsExpr(in)
	case *JSONPrettyExpr:
		return c.COWRefOfJSONPrettyExpr(in)
	case *JSONQuoteExpr:
		return c.COWRefOfJSONQuoteExpr(in)
	case *JSONRemoveExpr:
		return c.COWRefOfJSONRemoveExpr(in)
	case *JSONSchemaValidFuncExpr:
		return c.COWRefOfJSONSchemaValidFuncExpr(in)
	case *JSONSchemaValidationReportFuncExpr:
		return c.COWRefOfJSONSchemaValidationReportFuncExpr(in)
	case *JSONSearchExpr:
		return c.COWRefOfJSONSearchExpr(in)
	case *JSONStorageFreeExpr:
		return c.COWRefOfJSONStorageFreeExpr(in)
	case *JSONStorageSizeExpr:
		return c.COWRefOfJSONStorageSizeExpr(in)
	case *JSONUnquoteExpr:
		return c.COWRefOfJSONUnquoteExpr(in)
	case *JSONValueExpr:
		return c.COWRefOfJSONValueExpr(in)
	case *JSONValueMergeExpr:
		return c.COWRefOfJSONValueMergeExpr(in)
	case *JSONValueModifierExpr:
		return c.COWRefOfJSONValueModifierExpr(in)
	case *LagLeadExpr:
		return c.COWRefOfLagLeadExpr(in)
	case ListArg:
		return in
	case *Literal:
		return c.COWRefOfLiteral(in)
	case *LocateExpr:
		return c.COWRefOfLocateExpr(in)
	case *LockingFunc:
		return c.COWRefOfLockingFunc(in)
	case *MatchExpr:
		return c.COWRefOfMatchExpr(in)
	case *Max:
		return c.COWRefOfMax(in)
	case *MemberOfExpr:
		return c.COWRefOfMemberOfExpr(in)
	case *Min:
		return c.COWRefOfMin(in)
	case *NTHValueExpr:
		return c.COWRefOfNTHValueExpr(in)
	case *NamedWindow:
		return c.COWRefOfNamedWindow(in)
	case *NotExpr:
		return c.COWRefOfNotExpr(in)
	case *NtileExpr:
		return c.COWRefOfNtileExpr(in)
	case *NullVal:
		return c.COWRefOfNullVal(in)
	case *Offset:
		return c.COWRefOfOffset(in)
	case *OrExpr:
		return c.COWRefOfOrExpr(in)
	case *PerformanceSchemaFuncExpr:
		return c.COWRefOfPerformanceSchemaFuncExpr(in)
	case *RegexpInstrExpr:
		return c.COWRefOfRegexpInstrExpr(in)
	case *RegexpLikeExpr:
		return c.COWRefOfRegexpLikeExpr(in)
	case *RegexpReplaceExpr:
		return c.COWRefOfRegexpReplaceExpr(in)
	case *RegexpSubstrExpr:
		return c.COWRefOfRegexpSubstrExpr(in)
	case *Std:
		return c.COWRefOfStd(in)
	case *StdDev:
		return c.COWRefOfStdDev(in)
	case *StdPop:
		return c.COWRefOfStdPop(in)
	case *StdSamp:
		return c.COWRefOfStdSamp(in)
	case *Subquery:
		return c.COWRefOfSubquery(in)
	case *SubstrExpr:
		return c.COWRefOfSubstrExpr(in)
	case *Sum:
		return c.COWRefOfSum(in)
	case *TimestampFuncExpr:
		return c.COWRefOfTimestampFuncExpr(in)
	case *TrimFuncExpr:
		return c.COWRefOfTrimFuncExpr(in)
	case *UnaryExpr:
		return c.COWRefOfUnaryExpr(in)
	case *UpdateXMLExpr:
		return c.COWRefOfUpdateXMLExpr(in)
	case ValTuple:
		return c.COWValTuple(in)
	case *ValuesFuncExpr:
		return c.COWRefOfValuesFuncExpr(in)
	case *VarPop:
		return c.COWRefOfVarPop(in)
	case *VarSamp:
		return c.COWRefOfVarSamp(in)
	case *Variable:
		return c.COWRefOfVariable(in)
	case *Variance:
		return c.COWRefOfVariance(in)
	case *WeightStringFuncExpr:
		return c.COWRefOfWeightStringFuncExpr(in)
	case *XorExpr:
		return c.COWRefOfXorExpr(in)
	default:
		// this should never happen
		return nil
	}
}

// COWInsertRows creates a deep clone of the input.
func (c cow) COWInsertRows(in InsertRows) (InsertRows, bool) {
	if in == nil {
		return nil, false
	}
	if c.old == in {
		return c.new, true
	}
	switch in := in.(type) {
	case *Select:
		return c.COWRefOfSelect(in)
	case *Union:
		return c.COWRefOfUnion(in)
	case Values:
		return c.COWValues(in)
	default:
		// this should never happen
		return nil
	}
}

// COWSelectExpr creates a deep clone of the input.
func (c cow) COWSelectExpr(in SelectExpr) (SelectExpr, bool) {
	if in == nil {
		return nil, false
	}
	if c.old == in {
		return c.new, true
	}
	switch in := in.(type) {
	case *AliasedExpr:
		return c.COWRefOfAliasedExpr(in)
	case *Nextval:
		return c.COWRefOfNextval(in)
	case *StarExpr:
		return c.COWRefOfStarExpr(in)
	default:
		// this should never happen
		return nil
	}
}

// COWSelectStatement creates a deep clone of the input.
func (c cow) COWSelectStatement(in SelectStatement) (SelectStatement, bool) {
	if in == nil {
		return nil, false
	}
	if c.old == in {
		return c.new, true
	}
	switch in := in.(type) {
	case *Select:
		return c.COWRefOfSelect(in)
	case *Union:
		return c.COWRefOfUnion(in)
	default:
		// this should never happen
		return nil
	}
}

// COWShowInternal creates a deep clone of the input.
func (c cow) COWShowInternal(in ShowInternal) (ShowInternal, bool) {
	if in == nil {
		return nil, false
	}
	if c.old == in {
		return c.new, true
	}
	switch in := in.(type) {
	case *ShowBasic:
		return c.COWRefOfShowBasic(in)
	case *ShowCreate:
		return c.COWRefOfShowCreate(in)
	case *ShowOther:
		return c.COWRefOfShowOther(in)
	default:
		// this should never happen
		return nil
	}
}

// COWSimpleTableExpr creates a deep clone of the input.
func (c cow) COWSimpleTableExpr(in SimpleTableExpr) (SimpleTableExpr, bool) {
	if in == nil {
		return nil, false
	}
	if c.old == in {
		return c.new, true
	}
	switch in := in.(type) {
	case *DerivedTable:
		return c.COWRefOfDerivedTable(in)
	case TableName:
		return c.COWTableName(in)
	default:
		// this should never happen
		return nil
	}
}

// COWStatement creates a deep clone of the input.
func (c cow) COWStatement(in Statement) (Statement, bool) {
	if in == nil {
		return nil, false
	}
	if c.old == in {
		return c.new, true
	}
	switch in := in.(type) {
	case *AlterDatabase:
		return c.COWRefOfAlterDatabase(in)
	case *AlterMigration:
		return c.COWRefOfAlterMigration(in)
	case *AlterTable:
		return c.COWRefOfAlterTable(in)
	case *AlterView:
		return c.COWRefOfAlterView(in)
	case *AlterVschema:
		return c.COWRefOfAlterVschema(in)
	case *Begin:
		return c.COWRefOfBegin(in)
	case *CallProc:
		return c.COWRefOfCallProc(in)
	case *CommentOnly:
		return c.COWRefOfCommentOnly(in)
	case *Commit:
		return c.COWRefOfCommit(in)
	case *CreateDatabase:
		return c.COWRefOfCreateDatabase(in)
	case *CreateTable:
		return c.COWRefOfCreateTable(in)
	case *CreateView:
		return c.COWRefOfCreateView(in)
	case *DeallocateStmt:
		return c.COWRefOfDeallocateStmt(in)
	case *Delete:
		return c.COWRefOfDelete(in)
	case *DropDatabase:
		return c.COWRefOfDropDatabase(in)
	case *DropTable:
		return c.COWRefOfDropTable(in)
	case *DropView:
		return c.COWRefOfDropView(in)
	case *ExecuteStmt:
		return c.COWRefOfExecuteStmt(in)
	case *ExplainStmt:
		return c.COWRefOfExplainStmt(in)
	case *ExplainTab:
		return c.COWRefOfExplainTab(in)
	case *Flush:
		return c.COWRefOfFlush(in)
	case *Insert:
		return c.COWRefOfInsert(in)
	case *Load:
		return c.COWRefOfLoad(in)
	case *LockTables:
		return c.COWRefOfLockTables(in)
	case *OtherAdmin:
		return c.COWRefOfOtherAdmin(in)
	case *OtherRead:
		return c.COWRefOfOtherRead(in)
	case *PrepareStmt:
		return c.COWRefOfPrepareStmt(in)
	case *Release:
		return c.COWRefOfRelease(in)
	case *RenameTable:
		return c.COWRefOfRenameTable(in)
	case *RevertMigration:
		return c.COWRefOfRevertMigration(in)
	case *Rollback:
		return c.COWRefOfRollback(in)
	case *SRollback:
		return c.COWRefOfSRollback(in)
	case *Savepoint:
		return c.COWRefOfSavepoint(in)
	case *Select:
		return c.COWRefOfSelect(in)
	case *Set:
		return c.COWRefOfSet(in)
	case *Show:
		return c.COWRefOfShow(in)
	case *ShowMigrationLogs:
		return c.COWRefOfShowMigrationLogs(in)
	case *ShowThrottledApps:
		return c.COWRefOfShowThrottledApps(in)
	case *ShowThrottlerStatus:
		return c.COWRefOfShowThrottlerStatus(in)
	case *Stream:
		return c.COWRefOfStream(in)
	case *TruncateTable:
		return c.COWRefOfTruncateTable(in)
	case *Union:
		return c.COWRefOfUnion(in)
	case *UnlockTables:
		return c.COWRefOfUnlockTables(in)
	case *Update:
		return c.COWRefOfUpdate(in)
	case *Use:
		return c.COWRefOfUse(in)
	case *VExplainStmt:
		return c.COWRefOfVExplainStmt(in)
	case *VStream:
		return c.COWRefOfVStream(in)
	default:
		// this should never happen
		return nil
	}
}

// COWTableExpr creates a deep clone of the input.
func (c cow) COWTableExpr(in TableExpr) (TableExpr, bool) {
	if in == nil {
		return nil, false
	}
	if c.old == in {
		return c.new, true
	}
	switch in := in.(type) {
	case *AliasedTableExpr:
		return c.COWRefOfAliasedTableExpr(in)
	case *JSONTableExpr:
		return c.COWRefOfJSONTableExpr(in)
	case *JoinTableExpr:
		return c.COWRefOfJoinTableExpr(in)
	case *ParenTableExpr:
		return c.COWRefOfParenTableExpr(in)
	default:
		// this should never happen
		return nil
	}
}

// COWSliceOfRefOfColumnDefinition creates a deep clone of the input.
func COWSliceOfRefOfColumnDefinition(n []*ColumnDefinition) []*ColumnDefinition {
	if n == nil {
		return nil
	}
	res := make([]*ColumnDefinition, len(n))
	for i, x := range n {
		res[i] = c.COWRefOfColumnDefinition(x)
	}
	return res
}

// COWRefOfBool creates a deep clone of the input.
func COWRefOfBool(n *bool) *bool {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// COWSliceOfDatabaseOption creates a deep clone of the input.
func COWSliceOfDatabaseOption(n []DatabaseOption) []DatabaseOption {
	if n == nil {
		return nil
	}
	res := make([]DatabaseOption, len(n))
	for i, x := range n {
		res[i] = c.COWDatabaseOption(x)
	}
	return res
}

// COWSliceOfAlterOption creates a deep clone of the input.
func COWSliceOfAlterOption(n []AlterOption) []AlterOption {
	if n == nil {
		return nil
	}
	res := make([]AlterOption, len(n))
	for i, x := range n {
		res[i] = c.COWAlterOption(x)
	}
	return res
}

// COWSliceOfIdentifierCI creates a deep clone of the input.
func COWSliceOfIdentifierCI(n []IdentifierCI) []IdentifierCI {
	if n == nil {
		return nil
	}
	res := make([]IdentifierCI, len(n))
	for i, x := range n {
		res[i] = c.COWIdentifierCI(x)
	}
	return res
}

// COWSliceOfTxAccessMode creates a deep clone of the input.
func COWSliceOfTxAccessMode(n []TxAccessMode) []TxAccessMode {
	if n == nil {
		return nil
	}
	res := make([]TxAccessMode, len(n))
	copy(res, n)
	return res
}

// COWSliceOfRefOfWhen creates a deep clone of the input.
func COWSliceOfRefOfWhen(n []*When) []*When {
	if n == nil {
		return nil
	}
	res := make([]*When, len(n))
	for i, x := range n {
		res[i] = c.COWRefOfWhen(x)
	}
	return res
}

// COWColumnType creates a deep clone of the input.
func COWColumnType(n ColumnType) ColumnType {
	return *c.COWRefOfColumnType(&n)
}

// COWRefOfColumnTypeOptions creates a deep clone of the input.
func (c cow) COWRefOfColumnTypeOptions(n *ColumnTypeOptions) (*ColumnTypeOptions, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Null = c.COWRefOfBool(n.Null)
	out.Default = c.COWExpr(n.Default)
	out.OnUpdate = c.COWExpr(n.OnUpdate)
	out.As = c.COWExpr(n.As)
	out.Comment = c.COWRefOfLiteral(n.Comment)
	out.Reference = c.COWRefOfReferenceDefinition(n.Reference)
	out.Invisible = c.COWRefOfBool(n.Invisible)
	out.EngineAttribute = c.COWRefOfLiteral(n.EngineAttribute)
	out.SecondaryEngineAttribute = c.COWRefOfLiteral(n.SecondaryEngineAttribute)
	out.SRID = c.COWRefOfLiteral(n.SRID)
	return &out
}

// COWColumnCharset creates a deep clone of the input.
func COWColumnCharset(n ColumnCharset) ColumnCharset {
	return *c.COWRefOfColumnCharset(&n)
}

// COWSliceOfString creates a deep clone of the input.
func COWSliceOfString(n []string) []string {
	if n == nil {
		return nil
	}
	res := make([]string, len(n))
	copy(res, n)
	return res
}

// COWSliceOfRefOfVariable creates a deep clone of the input.
func COWSliceOfRefOfVariable(n []*Variable) []*Variable {
	if n == nil {
		return nil
	}
	res := make([]*Variable, len(n))
	for i, x := range n {
		res[i] = c.COWRefOfVariable(x)
	}
	return res
}

// COWRefOfIdentifierCI creates a deep clone of the input.
func (c cow) COWRefOfIdentifierCI(n *IdentifierCI) (*IdentifierCI, bool) {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// COWRefOfIdentifierCS creates a deep clone of the input.
func (c cow) COWRefOfIdentifierCS(n *IdentifierCS) (*IdentifierCS, bool) {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// COWSliceOfRefOfIndexColumn creates a deep clone of the input.
func COWSliceOfRefOfIndexColumn(n []*IndexColumn) []*IndexColumn {
	if n == nil {
		return nil
	}
	res := make([]*IndexColumn, len(n))
	for i, x := range n {
		res[i] = c.COWRefOfIndexColumn(x)
	}
	return res
}

// COWSliceOfRefOfIndexOption creates a deep clone of the input.
func COWSliceOfRefOfIndexOption(n []*IndexOption) []*IndexOption {
	if n == nil {
		return nil
	}
	res := make([]*IndexOption, len(n))
	for i, x := range n {
		res[i] = c.COWRefOfIndexOption(x)
	}
	return res
}

// COWSliceOfExpr creates a deep clone of the input.
func COWSliceOfExpr(n []Expr) []Expr {
	if n == nil {
		return nil
	}
	res := make([]Expr, len(n))
	for i, x := range n {
		res[i] = c.COWExpr(x)
	}
	return res
}

// COWSliceOfRefOfJSONObjectParam creates a deep clone of the input.
func COWSliceOfRefOfJSONObjectParam(n []*JSONObjectParam) []*JSONObjectParam {
	if n == nil {
		return nil
	}
	res := make([]*JSONObjectParam, len(n))
	for i, x := range n {
		res[i] = c.COWRefOfJSONObjectParam(x)
	}
	return res
}

// COWRefOfJSONObjectParam creates a deep clone of the input.
func (c cow) COWRefOfJSONObjectParam(n *JSONObjectParam) (*JSONObjectParam, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Key = c.COWExpr(n.Key)
	out.Value = c.COWExpr(n.Value)
	return &out
}

// COWSliceOfRefOfJtColumnDefinition creates a deep clone of the input.
func COWSliceOfRefOfJtColumnDefinition(n []*JtColumnDefinition) []*JtColumnDefinition {
	if n == nil {
		return nil
	}
	res := make([]*JtColumnDefinition, len(n))
	for i, x := range n {
		res[i] = c.COWRefOfJtColumnDefinition(x)
	}
	return res
}

// COWRefOfJtOrdinalColDef creates a deep clone of the input.
func (c cow) COWRefOfJtOrdinalColDef(n *JtOrdinalColDef) (*JtOrdinalColDef, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = c.COWIdentifierCI(n.Name)
	return &out
}

// COWRefOfJtPathColDef creates a deep clone of the input.
func (c cow) COWRefOfJtPathColDef(n *JtPathColDef) (*JtPathColDef, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = c.COWIdentifierCI(n.Name)
	out.Type = c.COWColumnType(n.Type)
	out.Path = c.COWExpr(n.Path)
	out.EmptyOnResponse = c.COWRefOfJtOnResponse(n.EmptyOnResponse)
	out.ErrorOnResponse = c.COWRefOfJtOnResponse(n.ErrorOnResponse)
	return &out
}

// COWRefOfJtNestedPathColDef creates a deep clone of the input.
func (c cow) COWRefOfJtNestedPathColDef(n *JtNestedPathColDef) (*JtNestedPathColDef, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Path = c.COWExpr(n.Path)
	out.Columns = c.COWSliceOfRefOfJtColumnDefinition(n.Columns)
	return &out
}

// COWTableAndLockTypes creates a deep clone of the input.
func COWTableAndLockTypes(n TableAndLockTypes) TableAndLockTypes {
	if n == nil {
		return nil
	}
	res := make(TableAndLockTypes, len(n))
	for i, x := range n {
		res[i] = c.COWRefOfTableAndLockType(x)
	}
	return res
}

// COWSliceOfRefOfColName creates a deep clone of the input.
func COWSliceOfRefOfColName(n []*ColName) []*ColName {
	if n == nil {
		return nil
	}
	res := make([]*ColName, len(n))
	for i, x := range n {
		res[i] = c.COWRefOfColName(x)
	}
	return res
}

// COWComments creates a deep clone of the input.
func COWComments(n Comments) Comments {
	if n == nil {
		return nil
	}
	res := make(Comments, len(n))
	for i, x := range n {
		res[i] = x
	}
	return res
}

// COWRefOfInt creates a deep clone of the input.
func COWRefOfInt(n *int) *int {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// COWSliceOfRefOfPartitionDefinition creates a deep clone of the input.
func COWSliceOfRefOfPartitionDefinition(n []*PartitionDefinition) []*PartitionDefinition {
	if n == nil {
		return nil
	}
	res := make([]*PartitionDefinition, len(n))
	for i, x := range n {
		res[i] = c.COWRefOfPartitionDefinition(x)
	}
	return res
}

// COWSliceOfRefOfRenameTablePair creates a deep clone of the input.
func COWSliceOfRefOfRenameTablePair(n []*RenameTablePair) []*RenameTablePair {
	if n == nil {
		return nil
	}
	res := make([]*RenameTablePair, len(n))
	for i, x := range n {
		res[i] = c.COWRefOfRenameTablePair(x)
	}
	return res
}

// COWRefOfRootNode creates a deep clone of the input.
func (c cow) COWRefOfRootNode(n *RootNode) (*RootNode, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.SQLNode = c.COWSQLNode(n.SQLNode)
	return &out
}

// COWSliceOfTableExpr creates a deep clone of the input.
func COWSliceOfTableExpr(n []TableExpr) []TableExpr {
	if n == nil {
		return nil
	}
	res := make([]TableExpr, len(n))
	for i, x := range n {
		res[i] = c.COWTableExpr(x)
	}
	return res
}

// COWRefOfTableName creates a deep clone of the input.
func (c cow) COWRefOfTableName(n *TableName) (*TableName, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = c.COWIdentifierCS(n.Name)
	out.Qualifier = c.COWIdentifierCS(n.Qualifier)
	return &out
}

// COWRefOfTableOption creates a deep clone of the input.
func (c cow) COWRefOfTableOption(n *TableOption) (*TableOption, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Value = c.COWRefOfLiteral(n.Value)
	out.Tables = c.COWTableNames(n.Tables)
	return &out
}

// COWSliceOfRefOfIndexDefinition creates a deep clone of the input.
func COWSliceOfRefOfIndexDefinition(n []*IndexDefinition) []*IndexDefinition {
	if n == nil {
		return nil
	}
	res := make([]*IndexDefinition, len(n))
	for i, x := range n {
		res[i] = c.COWRefOfIndexDefinition(x)
	}
	return res
}

// COWSliceOfRefOfConstraintDefinition creates a deep clone of the input.
func COWSliceOfRefOfConstraintDefinition(n []*ConstraintDefinition) []*ConstraintDefinition {
	if n == nil {
		return nil
	}
	res := make([]*ConstraintDefinition, len(n))
	for i, x := range n {
		res[i] = c.COWRefOfConstraintDefinition(x)
	}
	return res
}

// COWRefOfVindexParam creates a deep clone of the input.
func (c cow) COWRefOfVindexParam(n *VindexParam) (*VindexParam, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Key = c.COWIdentifierCI(n.Key)
	return &out
}

// COWSliceOfVindexParam creates a deep clone of the input.
func COWSliceOfVindexParam(n []VindexParam) []VindexParam {
	if n == nil {
		return nil
	}
	res := make([]VindexParam, len(n))
	for i, x := range n {
		res[i] = c.COWVindexParam(x)
	}
	return res
}

// COWSliceOfRefOfCommonTableExpr creates a deep clone of the input.
func COWSliceOfRefOfCommonTableExpr(n []*CommonTableExpr) []*CommonTableExpr {
	if n == nil {
		return nil
	}
	res := make([]*CommonTableExpr, len(n))
	for i, x := range n {
		res[i] = c.COWRefOfCommonTableExpr(x)
	}
	return res
}

// COWDatabaseOption creates a deep clone of the input.
func COWDatabaseOption(n DatabaseOption) DatabaseOption {
	return *c.COWRefOfDatabaseOption(&n)
}

// COWRefOfColumnCharset creates a deep clone of the input.
func (c cow) COWRefOfColumnCharset(n *ColumnCharset) (*ColumnCharset, bool) {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// COWRefOfIndexColumn creates a deep clone of the input.
func (c cow) COWRefOfIndexColumn(n *IndexColumn) (*IndexColumn, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Column = c.COWIdentifierCI(n.Column)
	out.Length = c.COWRefOfLiteral(n.Length)
	out.Expression = c.COWExpr(n.Expression)
	return &out
}

// COWRefOfIndexOption creates a deep clone of the input.
func (c cow) COWRefOfIndexOption(n *IndexOption) (*IndexOption, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Value = c.COWRefOfLiteral(n.Value)
	return &out
}

// COWRefOfTableAndLockType creates a deep clone of the input.
func (c cow) COWRefOfTableAndLockType(n *TableAndLockType) (*TableAndLockType, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.Table = c.COWTableExpr(n.Table)
	return &out
}

// COWRefOfRenameTablePair creates a deep clone of the input.
func (c cow) COWRefOfRenameTablePair(n *RenameTablePair) (*RenameTablePair, bool) {
	if n == nil {
		return nil
	}
	out := *n
	out.FromTable = c.COWTableName(n.FromTable)
	out.ToTable = c.COWTableName(n.ToTable)
	return &out
}

// COWRefOfDatabaseOption creates a deep clone of the input.
func (c cow) COWRefOfDatabaseOption(n *DatabaseOption) (*DatabaseOption, bool) {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}
