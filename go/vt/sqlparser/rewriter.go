// Code generated by visitorgen/main/main.go. DO NOT EDIT.

package sqlparser

import (
	"reflect"
)

type replacerFunc func(newNode SQLNode, parent SQLNode)

// application carries all the shared data so we can pass it around cheaply.
type application struct {
	pre, post ApplyFunc
	cursor    Cursor
}

func replaceAliasedExprAs(new SQLNode, parent SQLNode) {
	parent.(*AliasedExpr).As = new.(ColIdent)
}

func replaceAliasedExprExpr(new SQLNode, parent SQLNode) {
	parent.(*AliasedExpr).Expr = new.(Expr)
}

func replaceAliasedTableExprAs(new SQLNode, parent SQLNode) {
	parent.(*AliasedTableExpr).As = new.(TableIdent)
}

func replaceAliasedTableExprExpr(new SQLNode, parent SQLNode) {
	parent.(*AliasedTableExpr).Expr = new.(SimpleTableExpr)
}

func replaceAliasedTableExprHints(new SQLNode, parent SQLNode) {
	parent.(*AliasedTableExpr).Hints = new.(*IndexHints)
}

func replaceAliasedTableExprPartitions(new SQLNode, parent SQLNode) {
	parent.(*AliasedTableExpr).Partitions = new.(Partitions)
}

func replaceAndExprLeft(new SQLNode, parent SQLNode) {
	parent.(*AndExpr).Left = new.(Expr)
}

func replaceAndExprRight(new SQLNode, parent SQLNode) {
	parent.(*AndExpr).Right = new.(Expr)
}

func replaceAutoIncSpecColumn(new SQLNode, parent SQLNode) {
	parent.(*AutoIncSpec).Column = new.(ColIdent)
}

func replaceAutoIncSpecSequence(new SQLNode, parent SQLNode) {
	parent.(*AutoIncSpec).Sequence = new.(TableName)
}

func replaceBinaryExprLeft(new SQLNode, parent SQLNode) {
	parent.(*BinaryExpr).Left = new.(Expr)
}

func replaceBinaryExprRight(new SQLNode, parent SQLNode) {
	parent.(*BinaryExpr).Right = new.(Expr)
}

func replaceCaseExprElse(new SQLNode, parent SQLNode) {
	parent.(*CaseExpr).Else = new.(Expr)
}

func replaceCaseExprExpr(new SQLNode, parent SQLNode) {
	parent.(*CaseExpr).Expr = new.(Expr)
}

type replaceCaseExprWhens int

func (r *replaceCaseExprWhens) replace(new, container SQLNode) {
	container.(*CaseExpr).Whens[int(*r)] = new.(*When)
}

func (r *replaceCaseExprWhens) inc() {
	*r++
}

func replaceColNameName(new SQLNode, parent SQLNode) {
	parent.(*ColName).Name = new.(ColIdent)
}

func replaceColNameQualifier(new SQLNode, parent SQLNode) {
	parent.(*ColName).Qualifier = new.(TableName)
}

func replaceCollateExprExpr(new SQLNode, parent SQLNode) {
	parent.(*CollateExpr).Expr = new.(Expr)
}

func replaceColumnDefinitionName(new SQLNode, parent SQLNode) {
	parent.(*ColumnDefinition).Name = new.(ColIdent)
}

func replaceColumnTypeAutoincrement(new SQLNode, parent SQLNode) {
	parent.(*ColumnType).Autoincrement = new.(BoolVal)
}

func replaceColumnTypeComment(new SQLNode, parent SQLNode) {
	parent.(*ColumnType).Comment = new.(*SQLVal)
}

func replaceColumnTypeDefault(new SQLNode, parent SQLNode) {
	parent.(*ColumnType).Default = new.(Expr)
}

func replaceColumnTypeLength(new SQLNode, parent SQLNode) {
	parent.(*ColumnType).Length = new.(*SQLVal)
}

func replaceColumnTypeNotNull(new SQLNode, parent SQLNode) {
	parent.(*ColumnType).NotNull = new.(BoolVal)
}

func replaceColumnTypeOnUpdate(new SQLNode, parent SQLNode) {
	parent.(*ColumnType).OnUpdate = new.(Expr)
}

func replaceColumnTypeScale(new SQLNode, parent SQLNode) {
	parent.(*ColumnType).Scale = new.(*SQLVal)
}

func replaceColumnTypeUnsigned(new SQLNode, parent SQLNode) {
	parent.(*ColumnType).Unsigned = new.(BoolVal)
}

func replaceColumnTypeZerofill(new SQLNode, parent SQLNode) {
	parent.(*ColumnType).Zerofill = new.(BoolVal)
}

type replaceColumnsItems int

func (r *replaceColumnsItems) replace(new, container SQLNode) {
	container.(Columns)[int(*r)] = new.(ColIdent)
}

func (r *replaceColumnsItems) inc() {
	*r++
}

func replaceComparisonExprEscape(new SQLNode, parent SQLNode) {
	parent.(*ComparisonExpr).Escape = new.(Expr)
}

func replaceComparisonExprLeft(new SQLNode, parent SQLNode) {
	parent.(*ComparisonExpr).Left = new.(Expr)
}

func replaceComparisonExprRight(new SQLNode, parent SQLNode) {
	parent.(*ComparisonExpr).Right = new.(Expr)
}

func replaceConstraintDefinitionDetails(new SQLNode, parent SQLNode) {
	parent.(*ConstraintDefinition).Details = new.(ConstraintInfo)
}

func replaceConvertExprExpr(new SQLNode, parent SQLNode) {
	parent.(*ConvertExpr).Expr = new.(Expr)
}

func replaceConvertExprType(new SQLNode, parent SQLNode) {
	parent.(*ConvertExpr).Type = new.(*ConvertType)
}

func replaceConvertTypeLength(new SQLNode, parent SQLNode) {
	parent.(*ConvertType).Length = new.(*SQLVal)
}

func replaceConvertTypeScale(new SQLNode, parent SQLNode) {
	parent.(*ConvertType).Scale = new.(*SQLVal)
}

func replaceConvertUsingExprExpr(new SQLNode, parent SQLNode) {
	parent.(*ConvertUsingExpr).Expr = new.(Expr)
}

func replaceCurTimeFuncExprFsp(new SQLNode, parent SQLNode) {
	parent.(*CurTimeFuncExpr).Fsp = new.(Expr)
}

func replaceCurTimeFuncExprName(new SQLNode, parent SQLNode) {
	parent.(*CurTimeFuncExpr).Name = new.(ColIdent)
}

func replaceDDLAutoIncSpec(new SQLNode, parent SQLNode) {
	parent.(*DDL).AutoIncSpec = new.(*AutoIncSpec)
}

func replaceDDLFromTables(new SQLNode, parent SQLNode) {
	parent.(*DDL).FromTables = new.(TableNames)
}

func replaceDDLOptLike(new SQLNode, parent SQLNode) {
	parent.(*DDL).OptLike = new.(*OptLike)
}

func replaceDDLPartitionSpec(new SQLNode, parent SQLNode) {
	parent.(*DDL).PartitionSpec = new.(*PartitionSpec)
}

func replaceDDLTable(new SQLNode, parent SQLNode) {
	parent.(*DDL).Table = new.(TableName)
}

func replaceDDLTableSpec(new SQLNode, parent SQLNode) {
	parent.(*DDL).TableSpec = new.(*TableSpec)
}

func replaceDDLToTables(new SQLNode, parent SQLNode) {
	parent.(*DDL).ToTables = new.(TableNames)
}

type replaceDDLVindexCols int

func (r *replaceDDLVindexCols) replace(new, container SQLNode) {
	container.(*DDL).VindexCols[int(*r)] = new.(ColIdent)
}

func (r *replaceDDLVindexCols) inc() {
	*r++
}

func replaceDDLVindexSpec(new SQLNode, parent SQLNode) {
	parent.(*DDL).VindexSpec = new.(*VindexSpec)
}

func replaceDeleteComments(new SQLNode, parent SQLNode) {
	parent.(*Delete).Comments = new.(Comments)
}

func replaceDeleteLimit(new SQLNode, parent SQLNode) {
	parent.(*Delete).Limit = new.(*Limit)
}

func replaceDeleteOrderBy(new SQLNode, parent SQLNode) {
	parent.(*Delete).OrderBy = new.(OrderBy)
}

func replaceDeletePartitions(new SQLNode, parent SQLNode) {
	parent.(*Delete).Partitions = new.(Partitions)
}

func replaceDeleteTableExprs(new SQLNode, parent SQLNode) {
	parent.(*Delete).TableExprs = new.(TableExprs)
}

func replaceDeleteTargets(new SQLNode, parent SQLNode) {
	parent.(*Delete).Targets = new.(TableNames)
}

func replaceDeleteWhere(new SQLNode, parent SQLNode) {
	parent.(*Delete).Where = new.(*Where)
}

func replaceExistsExprSubquery(new SQLNode, parent SQLNode) {
	parent.(*ExistsExpr).Subquery = new.(*Subquery)
}

type replaceExprsItems int

func (r *replaceExprsItems) replace(new, container SQLNode) {
	container.(Exprs)[int(*r)] = new.(Expr)
}

func (r *replaceExprsItems) inc() {
	*r++
}

func replaceForeignKeyDefinitionOnDelete(new SQLNode, parent SQLNode) {
	parent.(*ForeignKeyDefinition).OnDelete = new.(ReferenceAction)
}

func replaceForeignKeyDefinitionOnUpdate(new SQLNode, parent SQLNode) {
	parent.(*ForeignKeyDefinition).OnUpdate = new.(ReferenceAction)
}

func replaceForeignKeyDefinitionReferencedColumns(new SQLNode, parent SQLNode) {
	parent.(*ForeignKeyDefinition).ReferencedColumns = new.(Columns)
}

func replaceForeignKeyDefinitionReferencedTable(new SQLNode, parent SQLNode) {
	parent.(*ForeignKeyDefinition).ReferencedTable = new.(TableName)
}

func replaceForeignKeyDefinitionSource(new SQLNode, parent SQLNode) {
	parent.(*ForeignKeyDefinition).Source = new.(Columns)
}

func replaceFuncExprExprs(new SQLNode, parent SQLNode) {
	parent.(*FuncExpr).Exprs = new.(SelectExprs)
}

func replaceFuncExprName(new SQLNode, parent SQLNode) {
	parent.(*FuncExpr).Name = new.(ColIdent)
}

func replaceFuncExprQualifier(new SQLNode, parent SQLNode) {
	parent.(*FuncExpr).Qualifier = new.(TableIdent)
}

type replaceGroupByItems int

func (r *replaceGroupByItems) replace(new, container SQLNode) {
	container.(GroupBy)[int(*r)] = new.(Expr)
}

func (r *replaceGroupByItems) inc() {
	*r++
}

func replaceGroupConcatExprExprs(new SQLNode, parent SQLNode) {
	parent.(*GroupConcatExpr).Exprs = new.(SelectExprs)
}

func replaceGroupConcatExprOrderBy(new SQLNode, parent SQLNode) {
	parent.(*GroupConcatExpr).OrderBy = new.(OrderBy)
}

func replaceIndexDefinitionInfo(new SQLNode, parent SQLNode) {
	parent.(*IndexDefinition).Info = new.(*IndexInfo)
}

type replaceIndexHintsIndexes int

func (r *replaceIndexHintsIndexes) replace(new, container SQLNode) {
	container.(*IndexHints).Indexes[int(*r)] = new.(ColIdent)
}

func (r *replaceIndexHintsIndexes) inc() {
	*r++
}

func replaceIndexInfoName(new SQLNode, parent SQLNode) {
	parent.(*IndexInfo).Name = new.(ColIdent)
}

func replaceInsertColumns(new SQLNode, parent SQLNode) {
	parent.(*Insert).Columns = new.(Columns)
}

func replaceInsertComments(new SQLNode, parent SQLNode) {
	parent.(*Insert).Comments = new.(Comments)
}

func replaceInsertOnDup(new SQLNode, parent SQLNode) {
	parent.(*Insert).OnDup = new.(OnDup)
}

func replaceInsertPartitions(new SQLNode, parent SQLNode) {
	parent.(*Insert).Partitions = new.(Partitions)
}

func replaceInsertRows(new SQLNode, parent SQLNode) {
	parent.(*Insert).Rows = new.(InsertRows)
}

func replaceInsertTable(new SQLNode, parent SQLNode) {
	parent.(*Insert).Table = new.(TableName)
}

func replaceIntervalExprExpr(new SQLNode, parent SQLNode) {
	parent.(*IntervalExpr).Expr = new.(Expr)
}

func replaceIsExprExpr(new SQLNode, parent SQLNode) {
	parent.(*IsExpr).Expr = new.(Expr)
}

func replaceJoinConditionOn(new, parent SQLNode) {
	tmp := parent.(JoinCondition)
	tmp.On = new.(Expr)
}

func replaceJoinConditionUsing(new, parent SQLNode) {
	tmp := parent.(JoinCondition)
	tmp.Using = new.(Columns)
}

func replaceJoinTableExprCondition(new SQLNode, parent SQLNode) {
	parent.(*JoinTableExpr).Condition = new.(JoinCondition)
}

func replaceJoinTableExprLeftExpr(new SQLNode, parent SQLNode) {
	parent.(*JoinTableExpr).LeftExpr = new.(TableExpr)
}

func replaceJoinTableExprRightExpr(new SQLNode, parent SQLNode) {
	parent.(*JoinTableExpr).RightExpr = new.(TableExpr)
}

func replaceLimitOffset(new SQLNode, parent SQLNode) {
	parent.(*Limit).Offset = new.(Expr)
}

func replaceLimitRowcount(new SQLNode, parent SQLNode) {
	parent.(*Limit).Rowcount = new.(Expr)
}

func replaceMatchExprColumns(new SQLNode, parent SQLNode) {
	parent.(*MatchExpr).Columns = new.(SelectExprs)
}

func replaceMatchExprExpr(new SQLNode, parent SQLNode) {
	parent.(*MatchExpr).Expr = new.(Expr)
}

func replaceNextvalExpr(new, parent SQLNode) {
	tmp := parent.(Nextval)
	tmp.Expr = new.(Expr)
}

func replaceNotExprExpr(new SQLNode, parent SQLNode) {
	parent.(*NotExpr).Expr = new.(Expr)
}

type replaceOnDupItems int

func (r *replaceOnDupItems) replace(new, container SQLNode) {
	container.(OnDup)[int(*r)] = new.(*UpdateExpr)
}

func (r *replaceOnDupItems) inc() {
	*r++
}

func replaceOptLikeLikeTable(new SQLNode, parent SQLNode) {
	parent.(*OptLike).LikeTable = new.(TableName)
}

func replaceOrExprLeft(new SQLNode, parent SQLNode) {
	parent.(*OrExpr).Left = new.(Expr)
}

func replaceOrExprRight(new SQLNode, parent SQLNode) {
	parent.(*OrExpr).Right = new.(Expr)
}

func replaceOrderExpr(new SQLNode, parent SQLNode) {
	parent.(*Order).Expr = new.(Expr)
}

type replaceOrderByItems int

func (r *replaceOrderByItems) replace(new, container SQLNode) {
	container.(OrderBy)[int(*r)] = new.(*Order)
}

func (r *replaceOrderByItems) inc() {
	*r++
}

func replaceParenExprExpr(new SQLNode, parent SQLNode) {
	parent.(*ParenExpr).Expr = new.(Expr)
}

func replaceParenSelectSelect(new SQLNode, parent SQLNode) {
	parent.(*ParenSelect).Select = new.(SelectStatement)
}

func replaceParenTableExprExprs(new SQLNode, parent SQLNode) {
	parent.(*ParenTableExpr).Exprs = new.(TableExprs)
}

func replacePartitionDefinitionLimit(new SQLNode, parent SQLNode) {
	parent.(*PartitionDefinition).Limit = new.(Expr)
}

func replacePartitionDefinitionName(new SQLNode, parent SQLNode) {
	parent.(*PartitionDefinition).Name = new.(ColIdent)
}

type replacePartitionSpecDefinitions int

func (r *replacePartitionSpecDefinitions) replace(new, container SQLNode) {
	container.(*PartitionSpec).Definitions[int(*r)] = new.(*PartitionDefinition)
}

func (r *replacePartitionSpecDefinitions) inc() {
	*r++
}

func replacePartitionSpecName(new SQLNode, parent SQLNode) {
	parent.(*PartitionSpec).Name = new.(ColIdent)
}

type replacePartitionsItems int

func (r *replacePartitionsItems) replace(new, container SQLNode) {
	container.(Partitions)[int(*r)] = new.(ColIdent)
}

func (r *replacePartitionsItems) inc() {
	*r++
}

func replaceRangeCondFrom(new SQLNode, parent SQLNode) {
	parent.(*RangeCond).From = new.(Expr)
}

func replaceRangeCondLeft(new SQLNode, parent SQLNode) {
	parent.(*RangeCond).Left = new.(Expr)
}

func replaceRangeCondTo(new SQLNode, parent SQLNode) {
	parent.(*RangeCond).To = new.(Expr)
}

func replaceSelectComments(new SQLNode, parent SQLNode) {
	parent.(*Select).Comments = new.(Comments)
}

func replaceSelectFrom(new SQLNode, parent SQLNode) {
	parent.(*Select).From = new.(TableExprs)
}

func replaceSelectGroupBy(new SQLNode, parent SQLNode) {
	parent.(*Select).GroupBy = new.(GroupBy)
}

func replaceSelectHaving(new SQLNode, parent SQLNode) {
	parent.(*Select).Having = new.(*Where)
}

func replaceSelectLimit(new SQLNode, parent SQLNode) {
	parent.(*Select).Limit = new.(*Limit)
}

func replaceSelectOrderBy(new SQLNode, parent SQLNode) {
	parent.(*Select).OrderBy = new.(OrderBy)
}

func replaceSelectSelectExprs(new SQLNode, parent SQLNode) {
	parent.(*Select).SelectExprs = new.(SelectExprs)
}

func replaceSelectWhere(new SQLNode, parent SQLNode) {
	parent.(*Select).Where = new.(*Where)
}

type replaceSelectExprsItems int

func (r *replaceSelectExprsItems) replace(new, container SQLNode) {
	container.(SelectExprs)[int(*r)] = new.(SelectExpr)
}

func (r *replaceSelectExprsItems) inc() {
	*r++
}

func replaceSetComments(new SQLNode, parent SQLNode) {
	parent.(*Set).Comments = new.(Comments)
}

func replaceSetExprs(new SQLNode, parent SQLNode) {
	parent.(*Set).Exprs = new.(SetExprs)
}

func replaceSetExprExpr(new SQLNode, parent SQLNode) {
	parent.(*SetExpr).Expr = new.(Expr)
}

func replaceSetExprName(new SQLNode, parent SQLNode) {
	parent.(*SetExpr).Name = new.(ColIdent)
}

type replaceSetExprsItems int

func (r *replaceSetExprsItems) replace(new, container SQLNode) {
	container.(SetExprs)[int(*r)] = new.(*SetExpr)
}

func (r *replaceSetExprsItems) inc() {
	*r++
}

func replaceShowOnTable(new SQLNode, parent SQLNode) {
	parent.(*Show).OnTable = new.(TableName)
}

func replaceShowTable(new SQLNode, parent SQLNode) {
	parent.(*Show).Table = new.(TableName)
}

func replaceShowFilterFilter(new SQLNode, parent SQLNode) {
	parent.(*ShowFilter).Filter = new.(Expr)
}

func replaceStarExprTableName(new SQLNode, parent SQLNode) {
	parent.(*StarExpr).TableName = new.(TableName)
}

func replaceStreamComments(new SQLNode, parent SQLNode) {
	parent.(*Stream).Comments = new.(Comments)
}

func replaceStreamSelectExpr(new SQLNode, parent SQLNode) {
	parent.(*Stream).SelectExpr = new.(SelectExpr)
}

func replaceStreamTable(new SQLNode, parent SQLNode) {
	parent.(*Stream).Table = new.(TableName)
}

func replaceSubquerySelect(new SQLNode, parent SQLNode) {
	parent.(*Subquery).Select = new.(SelectStatement)
}

func replaceSubstrExprFrom(new SQLNode, parent SQLNode) {
	parent.(*SubstrExpr).From = new.(Expr)
}

func replaceSubstrExprName(new SQLNode, parent SQLNode) {
	parent.(*SubstrExpr).Name = new.(*ColName)
}

func replaceSubstrExprStrVal(new SQLNode, parent SQLNode) {
	parent.(*SubstrExpr).StrVal = new.(*SQLVal)
}

func replaceSubstrExprTo(new SQLNode, parent SQLNode) {
	parent.(*SubstrExpr).To = new.(Expr)
}

type replaceTableExprsItems int

func (r *replaceTableExprsItems) replace(new, container SQLNode) {
	container.(TableExprs)[int(*r)] = new.(TableExpr)
}

func (r *replaceTableExprsItems) inc() {
	*r++
}

func replaceTableNameName(new, parent SQLNode) {
	tmp := parent.(TableName)
	tmp.Name = new.(TableIdent)
}

func replaceTableNameQualifier(new, parent SQLNode) {
	tmp := parent.(TableName)
	tmp.Qualifier = new.(TableIdent)
}

type replaceTableNamesItems int

func (r *replaceTableNamesItems) replace(new, container SQLNode) {
	container.(TableNames)[int(*r)] = new.(TableName)
}

func (r *replaceTableNamesItems) inc() {
	*r++
}

type replaceTableSpecColumns int

func (r *replaceTableSpecColumns) replace(new, container SQLNode) {
	container.(*TableSpec).Columns[int(*r)] = new.(*ColumnDefinition)
}

func (r *replaceTableSpecColumns) inc() {
	*r++
}

type replaceTableSpecConstraints int

func (r *replaceTableSpecConstraints) replace(new, container SQLNode) {
	container.(*TableSpec).Constraints[int(*r)] = new.(*ConstraintDefinition)
}

func (r *replaceTableSpecConstraints) inc() {
	*r++
}

type replaceTableSpecIndexes int

func (r *replaceTableSpecIndexes) replace(new, container SQLNode) {
	container.(*TableSpec).Indexes[int(*r)] = new.(*IndexDefinition)
}

func (r *replaceTableSpecIndexes) inc() {
	*r++
}

func replaceTimestampFuncExprExpr1(new SQLNode, parent SQLNode) {
	parent.(*TimestampFuncExpr).Expr1 = new.(Expr)
}

func replaceTimestampFuncExprExpr2(new SQLNode, parent SQLNode) {
	parent.(*TimestampFuncExpr).Expr2 = new.(Expr)
}

func replaceUnaryExprExpr(new SQLNode, parent SQLNode) {
	parent.(*UnaryExpr).Expr = new.(Expr)
}

func replaceUnionLeft(new SQLNode, parent SQLNode) {
	parent.(*Union).Left = new.(SelectStatement)
}

func replaceUnionLimit(new SQLNode, parent SQLNode) {
	parent.(*Union).Limit = new.(*Limit)
}

func replaceUnionOrderBy(new SQLNode, parent SQLNode) {
	parent.(*Union).OrderBy = new.(OrderBy)
}

func replaceUnionRight(new SQLNode, parent SQLNode) {
	parent.(*Union).Right = new.(SelectStatement)
}

func replaceUpdateComments(new SQLNode, parent SQLNode) {
	parent.(*Update).Comments = new.(Comments)
}

func replaceUpdateExprs(new SQLNode, parent SQLNode) {
	parent.(*Update).Exprs = new.(UpdateExprs)
}

func replaceUpdateLimit(new SQLNode, parent SQLNode) {
	parent.(*Update).Limit = new.(*Limit)
}

func replaceUpdateOrderBy(new SQLNode, parent SQLNode) {
	parent.(*Update).OrderBy = new.(OrderBy)
}

func replaceUpdateTableExprs(new SQLNode, parent SQLNode) {
	parent.(*Update).TableExprs = new.(TableExprs)
}

func replaceUpdateWhere(new SQLNode, parent SQLNode) {
	parent.(*Update).Where = new.(*Where)
}

func replaceUpdateExprExpr(new SQLNode, parent SQLNode) {
	parent.(*UpdateExpr).Expr = new.(Expr)
}

func replaceUpdateExprName(new SQLNode, parent SQLNode) {
	parent.(*UpdateExpr).Name = new.(*ColName)
}

type replaceUpdateExprsItems int

func (r *replaceUpdateExprsItems) replace(new, container SQLNode) {
	container.(UpdateExprs)[int(*r)] = new.(*UpdateExpr)
}

func (r *replaceUpdateExprsItems) inc() {
	*r++
}

func replaceUseDBName(new SQLNode, parent SQLNode) {
	parent.(*Use).DBName = new.(TableIdent)
}

type replaceValTupleItems int

func (r *replaceValTupleItems) replace(new, container SQLNode) {
	container.(ValTuple)[int(*r)] = new.(Expr)
}

func (r *replaceValTupleItems) inc() {
	*r++
}

type replaceValuesItems int

func (r *replaceValuesItems) replace(new, container SQLNode) {
	container.(Values)[int(*r)] = new.(ValTuple)
}

func (r *replaceValuesItems) inc() {
	*r++
}

func replaceValuesFuncExprName(new SQLNode, parent SQLNode) {
	parent.(*ValuesFuncExpr).Name = new.(*ColName)
}

func replaceVindexParamKey(new, parent SQLNode) {
	tmp := parent.(VindexParam)
	tmp.Key = new.(ColIdent)
}

func replaceVindexSpecName(new SQLNode, parent SQLNode) {
	parent.(*VindexSpec).Name = new.(ColIdent)
}

type replaceVindexSpecParams int

func (r *replaceVindexSpecParams) replace(new, container SQLNode) {
	container.(*VindexSpec).Params[int(*r)] = new.(VindexParam)
}

func (r *replaceVindexSpecParams) inc() {
	*r++
}

func replaceVindexSpecType(new SQLNode, parent SQLNode) {
	parent.(*VindexSpec).Type = new.(ColIdent)
}

func replaceWhenCond(new SQLNode, parent SQLNode) {
	parent.(*When).Cond = new.(Expr)
}

func replaceWhenVal(new SQLNode, parent SQLNode) {
	parent.(*When).Val = new.(Expr)
}

func replaceWhereExpr(new SQLNode, parent SQLNode) {
	parent.(*Where).Expr = new.(Expr)
}

// apply is where the visiting happens. Here is where we keep the big switch-case that will be used
// to do the actual visiting of SQLNodes
func (a *application) apply(parent, node SQLNode, replacer replacerFunc) {
	if node == nil || isNilValue(node) {
		return
	}

	// avoid heap-allocating a new cursor for each apply call; reuse a.cursor instead
	saved := a.cursor
	a.cursor.replacer = replacer
	a.cursor.node = node
	a.cursor.parent = parent

	if a.pre != nil && !a.pre(&a.cursor) {
		a.cursor = saved
		return
	}

	// walk children
	// (the order of the cases is alphabetical)
	switch n := node.(type) {
	case nil:
	case *AliasedExpr:
		a.apply(node, n.As, replaceAliasedExprAs)
		a.apply(node, n.Expr, replaceAliasedExprExpr)

	case *AliasedTableExpr:
		a.apply(node, n.As, replaceAliasedTableExprAs)
		a.apply(node, n.Expr, replaceAliasedTableExprExpr)
		a.apply(node, n.Hints, replaceAliasedTableExprHints)
		a.apply(node, n.Partitions, replaceAliasedTableExprPartitions)

	case *AndExpr:
		a.apply(node, n.Left, replaceAndExprLeft)
		a.apply(node, n.Right, replaceAndExprRight)

	case *AutoIncSpec:
		a.apply(node, n.Column, replaceAutoIncSpecColumn)
		a.apply(node, n.Sequence, replaceAutoIncSpecSequence)

	case *Begin:

	case *BinaryExpr:
		a.apply(node, n.Left, replaceBinaryExprLeft)
		a.apply(node, n.Right, replaceBinaryExprRight)

	case BoolVal:

	case *CaseExpr:
		a.apply(node, n.Else, replaceCaseExprElse)
		a.apply(node, n.Expr, replaceCaseExprExpr)
		replacerWhens := replaceCaseExprWhens(0)
		replacerWhensB := &replacerWhens
		for _, item := range n.Whens {
			a.apply(node, item, replacerWhensB.replace)
			replacerWhensB.inc()
		}

	case ColIdent:

	case *ColName:
		a.apply(node, n.Name, replaceColNameName)
		a.apply(node, n.Qualifier, replaceColNameQualifier)

	case *CollateExpr:
		a.apply(node, n.Expr, replaceCollateExprExpr)

	case *ColumnDefinition:
		a.apply(node, n.Name, replaceColumnDefinitionName)

	case *ColumnType:
		a.apply(node, n.Autoincrement, replaceColumnTypeAutoincrement)
		a.apply(node, n.Comment, replaceColumnTypeComment)
		a.apply(node, n.Default, replaceColumnTypeDefault)
		a.apply(node, n.Length, replaceColumnTypeLength)
		a.apply(node, n.NotNull, replaceColumnTypeNotNull)
		a.apply(node, n.OnUpdate, replaceColumnTypeOnUpdate)
		a.apply(node, n.Scale, replaceColumnTypeScale)
		a.apply(node, n.Unsigned, replaceColumnTypeUnsigned)
		a.apply(node, n.Zerofill, replaceColumnTypeZerofill)

	case Columns:
		replacer := replaceColumnsItems(0)
		replacerRef := &replacer
		for _, item := range n {
			a.apply(node, item, replacerRef.replace)
			replacerRef.inc()
		}

	case Comments:

	case *Commit:

	case *ComparisonExpr:
		a.apply(node, n.Escape, replaceComparisonExprEscape)
		a.apply(node, n.Left, replaceComparisonExprLeft)
		a.apply(node, n.Right, replaceComparisonExprRight)

	case *ConstraintDefinition:
		a.apply(node, n.Details, replaceConstraintDefinitionDetails)

	case *ConvertExpr:
		a.apply(node, n.Expr, replaceConvertExprExpr)
		a.apply(node, n.Type, replaceConvertExprType)

	case *ConvertType:
		a.apply(node, n.Length, replaceConvertTypeLength)
		a.apply(node, n.Scale, replaceConvertTypeScale)

	case *ConvertUsingExpr:
		a.apply(node, n.Expr, replaceConvertUsingExprExpr)

	case *CurTimeFuncExpr:
		a.apply(node, n.Fsp, replaceCurTimeFuncExprFsp)
		a.apply(node, n.Name, replaceCurTimeFuncExprName)

	case *DBDDL:

	case *DDL:
		a.apply(node, n.AutoIncSpec, replaceDDLAutoIncSpec)
		a.apply(node, n.FromTables, replaceDDLFromTables)
		a.apply(node, n.OptLike, replaceDDLOptLike)
		a.apply(node, n.PartitionSpec, replaceDDLPartitionSpec)
		a.apply(node, n.Table, replaceDDLTable)
		a.apply(node, n.TableSpec, replaceDDLTableSpec)
		a.apply(node, n.ToTables, replaceDDLToTables)
		replacerVindexCols := replaceDDLVindexCols(0)
		replacerVindexColsB := &replacerVindexCols
		for _, item := range n.VindexCols {
			a.apply(node, item, replacerVindexColsB.replace)
			replacerVindexColsB.inc()
		}
		a.apply(node, n.VindexSpec, replaceDDLVindexSpec)

	case *Default:

	case *Delete:
		a.apply(node, n.Comments, replaceDeleteComments)
		a.apply(node, n.Limit, replaceDeleteLimit)
		a.apply(node, n.OrderBy, replaceDeleteOrderBy)
		a.apply(node, n.Partitions, replaceDeletePartitions)
		a.apply(node, n.TableExprs, replaceDeleteTableExprs)
		a.apply(node, n.Targets, replaceDeleteTargets)
		a.apply(node, n.Where, replaceDeleteWhere)

	case *ExistsExpr:
		a.apply(node, n.Subquery, replaceExistsExprSubquery)

	case Exprs:
		replacer := replaceExprsItems(0)
		replacerRef := &replacer
		for _, item := range n {
			a.apply(node, item, replacerRef.replace)
			replacerRef.inc()
		}

	case *ForeignKeyDefinition:
		a.apply(node, n.OnDelete, replaceForeignKeyDefinitionOnDelete)
		a.apply(node, n.OnUpdate, replaceForeignKeyDefinitionOnUpdate)
		a.apply(node, n.ReferencedColumns, replaceForeignKeyDefinitionReferencedColumns)
		a.apply(node, n.ReferencedTable, replaceForeignKeyDefinitionReferencedTable)
		a.apply(node, n.Source, replaceForeignKeyDefinitionSource)

	case *FuncExpr:
		a.apply(node, n.Exprs, replaceFuncExprExprs)
		a.apply(node, n.Name, replaceFuncExprName)
		a.apply(node, n.Qualifier, replaceFuncExprQualifier)

	case GroupBy:
		replacer := replaceGroupByItems(0)
		replacerRef := &replacer
		for _, item := range n {
			a.apply(node, item, replacerRef.replace)
			replacerRef.inc()
		}

	case *GroupConcatExpr:
		a.apply(node, n.Exprs, replaceGroupConcatExprExprs)
		a.apply(node, n.OrderBy, replaceGroupConcatExprOrderBy)

	case *IndexDefinition:
		a.apply(node, n.Info, replaceIndexDefinitionInfo)

	case *IndexHints:
		replacerIndexes := replaceIndexHintsIndexes(0)
		replacerIndexesB := &replacerIndexes
		for _, item := range n.Indexes {
			a.apply(node, item, replacerIndexesB.replace)
			replacerIndexesB.inc()
		}

	case *IndexInfo:
		a.apply(node, n.Name, replaceIndexInfoName)

	case *Insert:
		a.apply(node, n.Columns, replaceInsertColumns)
		a.apply(node, n.Comments, replaceInsertComments)
		a.apply(node, n.OnDup, replaceInsertOnDup)
		a.apply(node, n.Partitions, replaceInsertPartitions)
		a.apply(node, n.Rows, replaceInsertRows)
		a.apply(node, n.Table, replaceInsertTable)

	case *IntervalExpr:
		a.apply(node, n.Expr, replaceIntervalExprExpr)

	case *IsExpr:
		a.apply(node, n.Expr, replaceIsExprExpr)

	case JoinCondition:
		a.apply(node, n.On, replaceJoinConditionOn)
		a.apply(node, n.Using, replaceJoinConditionUsing)

	case *JoinTableExpr:
		a.apply(node, n.Condition, replaceJoinTableExprCondition)
		a.apply(node, n.LeftExpr, replaceJoinTableExprLeftExpr)
		a.apply(node, n.RightExpr, replaceJoinTableExprRightExpr)

	case *Limit:
		a.apply(node, n.Offset, replaceLimitOffset)
		a.apply(node, n.Rowcount, replaceLimitRowcount)

	case ListArg:

	case *MatchExpr:
		a.apply(node, n.Columns, replaceMatchExprColumns)
		a.apply(node, n.Expr, replaceMatchExprExpr)

	case Nextval:
		a.apply(node, n.Expr, replaceNextvalExpr)

	case *NotExpr:
		a.apply(node, n.Expr, replaceNotExprExpr)

	case *NullVal:

	case OnDup:
		replacer := replaceOnDupItems(0)
		replacerRef := &replacer
		for _, item := range n {
			a.apply(node, item, replacerRef.replace)
			replacerRef.inc()
		}

	case *OptLike:
		a.apply(node, n.LikeTable, replaceOptLikeLikeTable)

	case *OrExpr:
		a.apply(node, n.Left, replaceOrExprLeft)
		a.apply(node, n.Right, replaceOrExprRight)

	case *Order:
		a.apply(node, n.Expr, replaceOrderExpr)

	case OrderBy:
		replacer := replaceOrderByItems(0)
		replacerRef := &replacer
		for _, item := range n {
			a.apply(node, item, replacerRef.replace)
			replacerRef.inc()
		}

	case *OtherAdmin:

	case *OtherRead:

	case *ParenExpr:
		a.apply(node, n.Expr, replaceParenExprExpr)

	case *ParenSelect:
		a.apply(node, n.Select, replaceParenSelectSelect)

	case *ParenTableExpr:
		a.apply(node, n.Exprs, replaceParenTableExprExprs)

	case *PartitionDefinition:
		a.apply(node, n.Limit, replacePartitionDefinitionLimit)
		a.apply(node, n.Name, replacePartitionDefinitionName)

	case *PartitionSpec:
		replacerDefinitions := replacePartitionSpecDefinitions(0)
		replacerDefinitionsB := &replacerDefinitions
		for _, item := range n.Definitions {
			a.apply(node, item, replacerDefinitionsB.replace)
			replacerDefinitionsB.inc()
		}
		a.apply(node, n.Name, replacePartitionSpecName)

	case Partitions:
		replacer := replacePartitionsItems(0)
		replacerRef := &replacer
		for _, item := range n {
			a.apply(node, item, replacerRef.replace)
			replacerRef.inc()
		}

	case *RangeCond:
		a.apply(node, n.From, replaceRangeCondFrom)
		a.apply(node, n.Left, replaceRangeCondLeft)
		a.apply(node, n.To, replaceRangeCondTo)

	case ReferenceAction:

	case *Rollback:

	case *SQLVal:

	case *Select:
		a.apply(node, n.Comments, replaceSelectComments)
		a.apply(node, n.From, replaceSelectFrom)
		a.apply(node, n.GroupBy, replaceSelectGroupBy)
		a.apply(node, n.Having, replaceSelectHaving)
		a.apply(node, n.Limit, replaceSelectLimit)
		a.apply(node, n.OrderBy, replaceSelectOrderBy)
		a.apply(node, n.SelectExprs, replaceSelectSelectExprs)
		a.apply(node, n.Where, replaceSelectWhere)

	case SelectExprs:
		replacer := replaceSelectExprsItems(0)
		replacerRef := &replacer
		for _, item := range n {
			a.apply(node, item, replacerRef.replace)
			replacerRef.inc()
		}

	case *Set:
		a.apply(node, n.Comments, replaceSetComments)
		a.apply(node, n.Exprs, replaceSetExprs)

	case *SetExpr:
		a.apply(node, n.Expr, replaceSetExprExpr)
		a.apply(node, n.Name, replaceSetExprName)

	case SetExprs:
		replacer := replaceSetExprsItems(0)
		replacerRef := &replacer
		for _, item := range n {
			a.apply(node, item, replacerRef.replace)
			replacerRef.inc()
		}

	case *Show:
		a.apply(node, n.OnTable, replaceShowOnTable)
		a.apply(node, n.Table, replaceShowTable)

	case *ShowFilter:
		a.apply(node, n.Filter, replaceShowFilterFilter)

	case *StarExpr:
		a.apply(node, n.TableName, replaceStarExprTableName)

	case *Stream:
		a.apply(node, n.Comments, replaceStreamComments)
		a.apply(node, n.SelectExpr, replaceStreamSelectExpr)
		a.apply(node, n.Table, replaceStreamTable)

	case *Subquery:
		a.apply(node, n.Select, replaceSubquerySelect)

	case *SubstrExpr:
		a.apply(node, n.From, replaceSubstrExprFrom)
		a.apply(node, n.Name, replaceSubstrExprName)
		a.apply(node, n.StrVal, replaceSubstrExprStrVal)
		a.apply(node, n.To, replaceSubstrExprTo)

	case TableExprs:
		replacer := replaceTableExprsItems(0)
		replacerRef := &replacer
		for _, item := range n {
			a.apply(node, item, replacerRef.replace)
			replacerRef.inc()
		}

	case TableIdent:

	case TableName:
		a.apply(node, n.Name, replaceTableNameName)
		a.apply(node, n.Qualifier, replaceTableNameQualifier)

	case TableNames:
		replacer := replaceTableNamesItems(0)
		replacerRef := &replacer
		for _, item := range n {
			a.apply(node, item, replacerRef.replace)
			replacerRef.inc()
		}

	case *TableSpec:
		replacerColumns := replaceTableSpecColumns(0)
		replacerColumnsB := &replacerColumns
		for _, item := range n.Columns {
			a.apply(node, item, replacerColumnsB.replace)
			replacerColumnsB.inc()
		}
		replacerConstraints := replaceTableSpecConstraints(0)
		replacerConstraintsB := &replacerConstraints
		for _, item := range n.Constraints {
			a.apply(node, item, replacerConstraintsB.replace)
			replacerConstraintsB.inc()
		}
		replacerIndexes := replaceTableSpecIndexes(0)
		replacerIndexesB := &replacerIndexes
		for _, item := range n.Indexes {
			a.apply(node, item, replacerIndexesB.replace)
			replacerIndexesB.inc()
		}

	case *TimestampFuncExpr:
		a.apply(node, n.Expr1, replaceTimestampFuncExprExpr1)
		a.apply(node, n.Expr2, replaceTimestampFuncExprExpr2)

	case *UnaryExpr:
		a.apply(node, n.Expr, replaceUnaryExprExpr)

	case *Union:
		a.apply(node, n.Left, replaceUnionLeft)
		a.apply(node, n.Limit, replaceUnionLimit)
		a.apply(node, n.OrderBy, replaceUnionOrderBy)
		a.apply(node, n.Right, replaceUnionRight)

	case *Update:
		a.apply(node, n.Comments, replaceUpdateComments)
		a.apply(node, n.Exprs, replaceUpdateExprs)
		a.apply(node, n.Limit, replaceUpdateLimit)
		a.apply(node, n.OrderBy, replaceUpdateOrderBy)
		a.apply(node, n.TableExprs, replaceUpdateTableExprs)
		a.apply(node, n.Where, replaceUpdateWhere)

	case *UpdateExpr:
		a.apply(node, n.Expr, replaceUpdateExprExpr)
		a.apply(node, n.Name, replaceUpdateExprName)

	case UpdateExprs:
		replacer := replaceUpdateExprsItems(0)
		replacerRef := &replacer
		for _, item := range n {
			a.apply(node, item, replacerRef.replace)
			replacerRef.inc()
		}

	case *Use:
		a.apply(node, n.DBName, replaceUseDBName)

	case ValTuple:
		replacer := replaceValTupleItems(0)
		replacerRef := &replacer
		for _, item := range n {
			a.apply(node, item, replacerRef.replace)
			replacerRef.inc()
		}

	case Values:
		replacer := replaceValuesItems(0)
		replacerRef := &replacer
		for _, item := range n {
			a.apply(node, item, replacerRef.replace)
			replacerRef.inc()
		}

	case *ValuesFuncExpr:
		a.apply(node, n.Name, replaceValuesFuncExprName)

	case VindexParam:
		a.apply(node, n.Key, replaceVindexParamKey)

	case *VindexSpec:
		a.apply(node, n.Name, replaceVindexSpecName)
		replacerParams := replaceVindexSpecParams(0)
		replacerParamsB := &replacerParams
		for _, item := range n.Params {
			a.apply(node, item, replacerParamsB.replace)
			replacerParamsB.inc()
		}
		a.apply(node, n.Type, replaceVindexSpecType)

	case *When:
		a.apply(node, n.Cond, replaceWhenCond)
		a.apply(node, n.Val, replaceWhenVal)

	case *Where:
		a.apply(node, n.Expr, replaceWhereExpr)

	default:
		panic("unknown ast type " + reflect.TypeOf(node).String())
	}

	if a.post != nil && !a.post(&a.cursor) {
		panic(abort)
	}

	a.cursor = saved
}

func isNilValue(i interface{}) bool {
	valueOf := reflect.ValueOf(i)
	kind := valueOf.Kind()
	isNullable := kind == reflect.Ptr || kind == reflect.Array || kind == reflect.Slice
	return isNullable && valueOf.IsNil()
}
